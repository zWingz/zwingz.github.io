[{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/20","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/20/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/20/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/20/events","html_url":"https://github.com/zWingz/my-blog-config/issues/20","id":383783892,"node_id":"MDU6SXNzdWUzODM3ODM4OTI=","number":20,"title":"使用jest+enzyme测试react组件","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false},{"id":989715361,"node_id":"MDU6TGFiZWw5ODk3MTUzNjE=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/react","name":"react","color":"a6c613","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2018-11-23T11:07:18Z","updated_at":"2018-11-30T08:25:34Z","closed_at":null,"author_association":"OWNER","body":"## 前言\r\n\r\n最近第一次给一个项目写一个完整的测试流程, 也算是我第一次写完整的测试.\r\n于是记一下整个测试流程\r\n[项目地址](https://github.com/zWingz/react-image)\r\n目前项目使用的测试框架是主流的`jest`+`enzyme`\r\n\r\n## 依赖\r\n\r\n### 必要依赖\r\n\r\n- Jest\r\n- enzyme\r\n- enzyme-adapter-react-16\r\n\r\n### 按需\r\n\r\n- 如果使用`babel`，则需要`babel-jest`\r\n- 如果使用`typescript`， 则需要`ts-jest`\r\n\r\n\r\n\r\n## Jest 配置\r\n\r\n起初项目使用`babel`进行编译，后面统一转成了`ts`\r\n\r\n```json\r\n\"jest\": {\r\n    \"moduleNameMapper\": {\r\n      \"\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|scss)$\":\"<rootDir>/test/utils.ts\"\r\n    },\r\n    \"moduleFileExtensions\": [\r\n      \"ts\",\r\n      \"tsx\",\r\n      \"js\"\r\n    ],\r\n    \"setupTestFrameworkScriptFile\": \"<rootDir>/test/setup.ts\",\r\n    \"collectCoverageFrom\": [\r\n      \"src/**/*.{ts,tsx}\"\r\n    ],\r\n    \"coverageDirectory\": \"./coverage/\",\r\n    \"collectCoverage\": true,\r\n    \"transform\": {\r\n      \"^.+\\\\.(ts|tsx)$\": \"ts-jest\"\r\n    },\r\n    \"testMatch\": [\r\n      \"**/__test__/*.(ts|tsx)\"\r\n    ]\r\n  }\r\n```\r\n\r\n如果使用`babel`的话, 只要将`ts`转成`js`, `ts-jest`转成`babel-jest`即可。\r\n\r\n\r\n\r\n#### moduleNameMapper\r\n用来`mock`一些额外`module`, 比如`sass`, `jpg`等等.\r\n```typescript\r\n// /test/utils.ts\r\nmodule.exports = 'test-file-stub'\r\n```\r\n\r\n#### setupTestFrameworkScriptFile\r\n\r\n>The path to a module that runs some code to configure or set up the testing framework before each test. \r\n\r\n可以用来初始化`test`配置, 在这里需要使用`enzyme-adapter`\r\n```typescript\r\n// /test/setup.ts\r\nimport { configure } from 'enzyme'\r\nimport * as ReactSixteenAdapter from 'enzyme-adapter-react-16'\r\n\r\nconfigure({ adapter: new ReactSixteenAdapter() })\r\n\r\n```\r\n\r\n#### collectCoverageFrom\r\n\r\n需要测试覆盖率的文件\r\n\r\n#### coverageDirectory\r\n\r\n覆盖率输出目录\r\n\r\n#### transform\r\n\r\n> A map from regular expressions to paths to transformers. A transformer is a module that provides a synchronous function for transforming source files\r\n\r\n跟`webpack-loader`类似\r\n\r\n### testMatch\r\n\r\n>The glob patterns Jest uses to detect test files.\r\n\r\n测试文件匹配规则, 如果跟官方不同, 则修改此值.\r\n\r\n\r\n## Enzyme 使用\r\n\r\n[官方文档](https://airbnb.io/enzyme/)\r\n\r\n### 简单介绍\r\n\r\n其实`enzyme`上手挺简单的, 它有三个`API`\r\n\r\n包括`shallow`、`mount`和`render`, 其中`shallow`和`mount`是常用的\r\n\r\n他们区别是\r\n\r\n- `shallow`: 只会渲染顶级组件, 而子组件不会渲染, 渲染结果是一颗`react`树, 效率最高\r\n- `mount`: 会渲染整个组件, 包括子组件, 如果需要深入组件内部测试, 则需要使用`mount`\r\n- `render`: 直接选择普通的`html`结构.\r\n\r\n`shallow`和`mount`得到结果是一个`ReactWrapper`对象, 可以进行多种操作, 包括`find()`、`prop()`、`instance()`等。\r\n\r\n\r\n### 基本使用\r\n\r\n``` typescript\r\nimport * as React from 'react'\r\nimport { shallow, mount } from 'enzyme'\r\nimport MyComponent from '../MyComponent'\r\nimport ChildComponent from '../ChildComponent'\r\n\r\ndescribt('测试xxxxx', () => {\r\n    it('组件state以及渲染情况', () => {\r\n        const wrapper = shallow(<MyComponent />)\r\n        expect(wrapper.state().msg).toEqual('test msg')\r\n        expect(wrapper.find('#childId')).toHaveLength(1) // 测试是否包含某个`element`\r\n        expect(wrapper.find(ChildComponent)).toHaveLength(1) // 测试是否包含某个子组件\r\n    })\r\n    it('触发事件', () => {\r\n\t    const click = jest.fn()\r\n        const wrapper = shallow(<MyComponent onClick={click}/>)\r\n        // 触发#triggerClickElement的click事件\r\n\t\twrapper.find('#triggerClickElement').simulate('click')\r\n\t\t// 判断click事件是否被触发\r\n\t\texpect(click).toBeCalledTimes(1)\r\n    })\r\n    // 测试函数调用\r\n    // 默认该函数声明方式通过class.method声明\r\n    // class MyComponent{\r\n    //   someMethod() {} \r\n    // }\r\n    it('测试函数调用', () => {\r\n        const spy = jest.spyOn(MyComponent.prototype, 'someMethod')\r\n        const wrapper = shallow(<MyComponent />)\r\n        // 暂且认为组件挂载时会调用`someMethod`\r\n        // 在此测试是否正确调用\r\n        expect(spy).toBeCalledTimes(1)\r\n    })\r\n    // 但是由于react需要绑定this\r\n    // 所以一般会这样声明\r\n    // class MyComponent {\r\n    //   someMethod = () => {}    \r\n    // }\r\n    // 这时候通过babel或者typescript编译后\r\n    // 会变成类似\r\n    // class MyComponent{\r\n    //   constructor() {\r\n    //     this.someMethod = () => {}     \r\n    //   }    \r\n    // }\r\n    // 这时候someMethod不属于MyComponent.prototype\r\n    // 所以要改变测试方式\r\n    it('测试函数调用', () => {\r\n        const wrapper = shallow(<MyComponent />)\r\n        const ins = wrapper.instance()\r\n        const spy = jest.spyOn(ins, 'someMethod')\r\n        wrapper.update()\r\n  \t\tins.forceUpdate()\r\n        expect(spy).toBeCalledTimes(1)\r\n    })\r\n    it('触发特定事件, 并传递参数', () => {\r\n    \t// 如果要触发特定事件, 比如mousemove, keyup等等\r\n    \t// 可以通过构造自定义事件, 并且使用dispatchEvent来触发\r\n        const wrapper = shallow(<MyComponent />)\r\n        const element = wrapper.find('.some-element')\r\n        const event = new MouseEvent('mousemove', {\r\n            clientX: 100,\r\n            clientY: 100\r\n        })\r\n        element.getDOMNode().dispatchEvent(event)\r\n        expect(wrapper.state.x).toEqueal(100)\r\n    })\r\n})\r\n```\r\n\r\n其实`enzyme`常用的api大概就是几个, 按照本项目中用到的, \r\n- state\r\n- find\r\n- prop\r\n- simulate\r\n\r\n## 进行测试\r\n\r\n编写完`test case`后, 只要调用`jest`即可进行测试, 同时会输出覆盖率\r\n如果带上`--watch`则可以监听文件改动并进行测试\r\n\r\n## 上传测试覆盖率\r\n\r\n目前使用`Codecov`来管理测试覆盖率\r\n如果在本地上传, 则需要带上`token`, 如果通过`travisCi`, 则不需要, 直接调用`codecov`即可。\r\n\r\n## 完结\r\n\r\n至此， 整套`jest`+`enzyme`测试流程已经跑完.\r\n目前看来没有用高更深的测试功能, 比如说`jsdom`, `enzyme.render`等\r\n"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/19","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/19/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/19/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/19/events","html_url":"https://github.com/zWingz/my-blog-config/issues/19","id":380665113,"node_id":"MDU6SXNzdWUzODA2NjUxMTM=","number":19,"title":"多package下babel编译问题","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":1127343300,"node_id":"MDU6TGFiZWwxMTI3MzQzMzAw","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/babel","name":"babel","color":"866bef","default":false},{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-11-14T11:56:24Z","updated_at":"2018-11-14T12:06:33Z","closed_at":null,"author_association":"OWNER","body":"## 项目背景\r\n\r\n之前一直使用`typescript` + `babel` 编译项目\r\n\r\n`typescript`作用只是单纯用来做强类型检查, `babel`则真正用来编译代码.\r\n\r\n```json\r\n  {\r\n     \"target\": \"exnext\"\r\n  }\r\n```\r\n\r\n偶然一次机会, 发现编译后的部分代码并没有编译`object-rest-spread`\r\n而这部分代码全都在一个子目录下\r\n\r\n由于我的项目使用了`git-submodules`来管理组件, 所以该组件目录下带有`package.json`文件\r\n\r\n恰好这部分文件只经过了`typescript`的编译, 而没有经过`babel`\r\n\r\n其他`Page`都正确的被`babel`编译, 不存在问题.\r\n\r\n于是想起是否子目录下的文件不被`babel`编译, 看了下官方文档, 的确有相关的描述.\r\n\r\n## 问题原因\r\n\r\n当项目目录中含有多个`package.json`时候, 原有的`.babelrc`已经不再适用\r\n\r\n![image](https://user-images.githubusercontent.com/13031838/48480504-a09f9300-e845-11e8-9edc-3f42bb145c2f.png).\r\n\r\n这时候经过`webpack`编译\r\n只有`src`下的文件会被正确编译, `sub`下的文件不会被`babel`编译\r\n\r\n此时`webpack`会报错\r\n\r\n![image](https://user-images.githubusercontent.com/13031838/48480915-d4c78380-e846-11e8-80e5-b4bc1c518474.png)\r\n\r\n原因就是这部分文件没有被`babel`正确编译\r\n\r\n\r\n## 上述问题解决办法\r\n\r\n官方有[详细说明](https://babeljs.io/docs/en/config-files#project-wide-configuration)\r\n\r\n将`.babelrc`改成`babel.config.js`, 此时`sub`下的文件可以被正确编译\r\n\r\n![image](https://user-images.githubusercontent.com/13031838/48481024-15270180-e847-11e8-909b-3af7c5a7b209.png)\r\n\r\n当然, 使用`babel.config.js`还可以灵活的配置各个`package`中`babel`编译规则.\r\n具体的还是请看官方文档"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/18","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/18/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/18/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/18/events","html_url":"https://github.com/zWingz/my-blog-config/issues/18","id":346031510,"node_id":"MDU6SXNzdWUzNDYwMzE1MTA=","number":18,"title":"使用Fabric+docker部署前端项目","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":1010053146,"node_id":"MDU6TGFiZWwxMDEwMDUzMTQ2","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/depoly","name":"depoly","color":"47f790","default":false},{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2018-07-31T04:32:38Z","updated_at":"2018-11-30T09:22:20Z","closed_at":null,"author_association":"OWNER","body":"## 部署过程\r\n\r\n- 合并`develop`到`master`\r\n- `push`代码\r\n- 远程服务器`pull`代码\r\n- npm install(如果需要)\r\n- npm run test (如果需要)\r\n- npm run build\r\n\r\n## Docker配置, 使用docker+node完成编译\r\n\r\n使用docker来部署, 则线上不需要有`node`环境.\r\n\r\n### 使用docker安装依赖\r\n\r\n- 将本地目录映射到`docker`中\r\n- 在`docker`中跑`npm`命令\r\n\r\n``` docker\r\n# docker-compose.yml\r\nversion: '3'\r\nservices:\r\n  depoly:\r\n    container_name: project-container\r\n    image: node:carbon\r\n    working_dir: /project\r\n    volumes:\r\n        - .:/project\r\n```\r\n\r\n\r\n## Shell脚本, 更好的执行docker\r\n\r\n```bash\r\n#!/bin/bash\r\n\r\n# 判断最近一次提交是否修改过package-lock, 以及node_modules是否为空\r\n# 如果是, 则重新执行npm install\r\npackage=$(git diff --name-only HEAD~ HEAD | grep \"package-lock.json\")\r\n\r\nif [ ! -d \"./node_modules\" -o -n \"$package\" ]; then\r\n  echo -e \"\\n\\033[41;37m Install dependence:\\033[0m\\n \"\r\n  # 跑docker命令\r\n  docker-compose run --rm depoly npm install\r\n  if [[ \"$?\" == 1 ]]; then\r\n    echo -e \"\\t\\033[31m Error in npm install, pleace check your package.json\\n\\033[0m\"\r\n    exit 1\r\n  fi\r\nfi;\r\n\r\n# 执行编译\r\necho -e \"\\n\\n\\033[41;37m Build... :\\033[0m\\n \"\r\n\r\n# 跑docker命令\r\ndocker-compose run --rm depoly npm run build\r\nif [[ \"$?\" == 1 ]]; then\r\n  echo -e \"\\t\\033[31m Error in npm run build \\n\\033[0m\"\r\n  exit 1\r\nelse\r\n  echo -e \"\\033[32mBuild Success \\033[0m\\n\"\r\nfi\r\n\r\nexit $?\r\n```\r\n\r\n## Fabric使用, 更快的完成部署\r\n\r\n### fabric基本介绍\r\n\r\n`fabric`是一个`python`库, 可以通过`ssh`在远程服务器执行命令.\r\n\r\n它有两个`1.0`和`2.0`版本, 其中`1.0`只支持`py2`, `2.0`版本可以支持`py2`和`py3`, 而且两个版本的`api`区别很大, 具体请参考官方文档.\r\n\r\n以下所使用的是`fabric2.0`, 附上[fabric2.x文档](http://docs.fabfile.org/en/2.2/)\r\n\r\n### 用途\r\n\r\n可以利用它来`pull`代码, 并执行代码编译\r\n\r\n同时, 线上一般只拉`master`分支, 所以`fabric`也能帮助我们在本地合并到`master`分支后`push`到`git`上\r\n\r\n### 配置文件\r\n\r\n``` python\r\nfrom fabric import Connection\r\nfrom invoke import task\r\n\r\nc = Connection(host='server_name')\r\n\r\n# 制定task\r\n# 可以通过fab depoly 调用\r\n@task\r\ndef depoly(d):\r\n    c.local('git checkout master') # 切换到master\r\n    c.local('git rebase develop') # 合并develop分支\r\n    c.local('git push origin master') # push到master\r\n    with c.cd('/home/ubuntu/path/your_project'):\r\n        c.run('git pull', pty=True) # 远程拉取代码\r\n        c.run('./depoly.sh') # 远程执行build\r\n    c.local('git checkout develop') # 本地切换回develop\r\n\r\n```\r\n\r\n执行`fab depoly`就可以完成一系列部署\r\n\r\n\r\n## 结语\r\n\r\n上述过程其实完全可以由各种`CI`完成\r\n\r\n但是对于私有`gitlab`, 同时又没有部署`gitlab-runner`或者不想接入第三方的话\r\n\r\n`fabric`是个不错的选择"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/17","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/17/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/17/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/17/events","html_url":"https://github.com/zWingz/my-blog-config/issues/17","id":339905815,"node_id":"MDU6SXNzdWUzMzk5MDU4MTU=","number":17,"title":"记一下从Vue转向React的感想","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false},{"id":819211023,"node_id":"MDU6TGFiZWw4MTkyMTEwMjM=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/js","name":"js","color":"c5def5","default":false},{"id":989715361,"node_id":"MDU6TGFiZWw5ODk3MTUzNjE=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/react","name":"react","color":"a6c613","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-07-10T15:56:23Z","updated_at":"2018-07-31T11:55:10Z","closed_at":null,"author_association":"OWNER","body":"# 关于React, 想说几点\r\n\r\n没有干货, 只有感想.\r\n没有源码分析, 只有需求实现.\r\n\r\n\r\n## React跟Vue对比\r\n\r\n之前写过一篇[vue后台系统开发实践](https://zwing.site/posts/275254986.html)\r\n\r\n那时候主要写`vue`, 有时间也会关注下`React`相关内容, 但没有实际开发经验.\r\n\r\n最近终于从`vue`转向了`React`\r\n\r\n虽说两者都是`MVVM`框架, 都是数据驱动型, 但是两者区别还真的很明显.\r\n\r\n曾经看过一段话, 大概是这么一个意思\r\n\r\n`vue`就是帮你封装了所有东西, 比如数据监听、指令、模板渲染等等\r\n\r\n写起来就像是一门新的语言一样,你只要按照他的语法, 你就能很轻易的写出一套系统. \r\n\r\n而`React`只提供了最基础的东西, 比如`vnode`, dom渲染等, 其余得都要靠自己去组合实现. 写起来就跟写原生`JavaScript`没什么区别. 可以玩出很多花样.\r\n\r\n我是很赞同这个说法\r\n\r\n在刚开始写`React`时候, 时不时都会带上`vue`的思想去写\r\n\r\n耳边偶尔会响起一句话 '怎么React这么麻烦, 我用vue一下子就能完成的东西, 在这里要写半天'\r\n\r\n例子? `Form`表单的双向绑定就是一个例子.\r\n\r\n\r\n### 初探React\r\n\r\n刚开始写, 由于不太熟练, 就选择了`Antd`作为UI框架.\r\n\r\n但其实我是不太喜欢使用第三方库的\r\n\r\n在刚开始写`vue`时候, 也是选择`ElementUI`, 后面熟练之后也逐步抛弃, 改用自己实现的组件\r\n\r\n除了几个特别麻烦的, 比如 `DataPicker` . 我还是选择使用第三方. \r\n\r\n我也写过一个[固定表格组件](https://zwing.site/posts/295960409.html), 个人感觉挺良好. 666\r\n\r\n那么对于`React`,  我也选择了同样的入手方式, 先从第三方库用起, 后续逐步替代.\r\n\r\n当然, `Antd` 用起来也是很麻烦, 花了几天勉强搭起了一个简单功能的后台. \r\n\r\n当时的想法就是, 这么几个页面, 用`vue`一天就搞定, 这个`react`花了我几天.\r\n\r\n可能当时也是太年轻了.\r\n\r\n后来开发第二个系统, 就开始结合上文所说的`vue后台实践` 所提到的几个要点去重新写系统\r\n\r\n\r\n\r\n## React的router选择\r\n\r\nreact的路由选择目前有两种, 一种是官方的`react-router`, 另一个是刚出不久的`reach-router`.\r\n\r\n而`react-router`也是从`v3`升级到了`v4`,  这次升级可以说是颠覆了传统的声明式路由\r\n\r\n改成了路由组件化, 而不是传统的配置形式。\r\n\r\n对于, `reach-router`可以说是麻雀虽小五脏俱全， 可以满足基本的路由功能,, `API`和路由组件使用起来也是比较简单的。\r\n\r\n刚搭建项目时候，我从`v3`和`v4`中做过选择， 最后决定使用`v4`, 因为我个人喜欢用新不用旧。\r\n\r\n在开发过程中，可能由于自己对`React`还不够熟悉， 在使用`Router`上也遇到不少问题。\r\n\r\n比如最简单的路由跳转\r\n\r\n`v3`只需要直接调用`api`即可完成跳转\r\n\r\n```js\r\n/* react-router v3*/\r\nimport { browserHistory } from 'react-router'; \r\nbrowserHistory.push('/some/path');\r\n```\r\n\r\n`v4`需要引入高阶组件后才能从`props`中调用api.\r\n```js\r\n/* react-router v3*/\r\nimport React from 'react'\r\nimport { withRouter } from 'react-router'\r\nclass Component extends React.Component {\r\n    // ...\r\n    push() {\r\n        this.props.history.push('/some/path')\r\n    }\r\n   \t// ...\r\n}\r\nexport default withRouter(Component)\r\n```\r\n\r\n但是`v4`也有优点, 就是路由配置很灵活, 在需要用到的地方引入`Route`即可。\r\n\r\n但是中途用着不爽，我就直接换成了`reach-router`。\r\n\r\n这会`reach-router`用起来可爽了, 简单直接。\r\n\r\n可是由于还不足够的成熟, 用了一段时间后，我又很无耻的改回了`react-router`\r\n\r\n不过我个人还是很欣赏`reach-router`, 希望后续能真正的发展起来。\r\n\r\n\r\n\r\n## React+mobx结合\r\n\r\n一般看到`React`, 一般也会伴随着`Redux`。\r\n\r\n而我从`vue`和`vuex`那套过来的，不是很喜欢`Redux`那套复杂的规则和写法。\r\n\r\n当然，也有很多成熟的解决方案，比如`dva`, `rematch`等, 轮子可不少啊。\r\n\r\n但是我个人更偏向于使用`mobx`，或者跟`vuex`脱不了干系吧。\r\n\r\n使用多`store`组合，或许能让组件更加的灵活。而且使用简单，不需要复杂的流程。\r\n\r\n## React在项目中使用\r\n\r\n主要是根据以往的[vue开发实践](https://zwing.site/posts/275254986.html)，将其搬到`react`中来。\r\n\r\n- 用户登录态管理\r\n- router的钩子\r\n- 列表页的数据加载，数据展示流程控制\r\n- 列表页查询参数与url查询参数双向绑定\r\n- 部分组件的实现\r\n\r\n\r\n...后续再补\r\n"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/16","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/16/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/16/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/16/events","html_url":"https://github.com/zWingz/my-blog-config/issues/16","id":316337025,"node_id":"MDU6SXNzdWUzMTYzMzcwMjU=","number":16,"title":"Promise/A+规范以及实现","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false},{"id":819211023,"node_id":"MDU6TGFiZWw4MTkyMTEwMjM=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/js","name":"js","color":"c5def5","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-04-20T16:40:56Z","updated_at":"2018-08-13T12:06:09Z","closed_at":null,"author_association":"OWNER","body":"# Promise 实现原理\r\n[源码](https://github.com/zWingz/Promise)\r\n\r\n## Promise基本用法\r\n\r\n```javascript\r\nnew Promise(function(resolve, reject) {\r\n    resolve()\r\n}).then(function(val) {\r\n    return val\r\n}, function(error) {\r\n    catch(error)\r\n}).catch(function(error) {\r\n    catch(error)\r\n})\r\n```\r\n\r\nPromise对象基本方法是`then`, 而`catch`是`then`的一个变形, 相当于`then(undefined, onReject)`\r\n\r\n## 实现过程\r\n\r\n根据Promise用法, 我们初步想到需要实现的方法是\r\n\r\n- 构造函数\r\n- resolve函数\r\n- reject函数\r\n- then函数\r\n\r\n此时Promise原型应为\r\n\r\n```javascript\r\nconst PENDING = 'PENDING'\r\nconst RESOLVED = 'RESOLVED'\r\nconst REJECT = 'REJECT'\r\n\r\nclass Promise {\r\n    constructor(func) {}\r\n    resolve(){}\r\n    reject(){}\r\n    then(onReslove, onReject){}\r\n}\r\n```\r\n\r\n### 根据`Promise/A+规范`(以下简称规范)中所说的\r\n\r\n- Promise有三个状态 `PENDING`, `RESOLVED`, `REJECTED`\r\n- 状态只会从`PENDING`转换到`RESOLVED`或者`REJECTED`其中一个, 并且之后不会再改变\r\n- 当Promise处于执行态时, 会有一个终值, 并且该值不会再改变\r\n- 当Promise处于拒绝态时, 会有一个据因, 并且该据因不会再改变\r\n- 当Promise由PENDING转换为RESOLVED时, 会触发`onResolve`回调, 并且只执行一次\r\n- 当Promise由PENDING转换为REJECTED时, 会触发`onReject`回调, 并且只执行一次\r\n- Promise状态的转换时机在于开发者何时调用promise的resolve或者reject函数\r\n\r\n```javascript\r\nclass Promise {\r\n    constructor(func) {\r\n        this.value = null // 终值或者据因\r\n        this.status = PENDING // 状态\r\n        this.onResolveCallBack = [] // resolved 回调\r\n        this.onRejectCallBack = [] // rejected 回调\r\n        try {\r\n            func(this.resolve.bind(this), this.reject.bind(this))\r\n        } catch (e) {\r\n            this.reject(e)\r\n        }\r\n    }\r\n    resolve(val){\r\n        if(this.status === PENDING) {\r\n            this.value = val // 设置终值\r\n            this.status = RESOLVED // 设置状态\r\n            this.onResolveCallBack.forEach(each => {\r\n                each(val) // 执行回调\r\n            })\r\n        }\r\n    }\r\n    reject(reason){\r\n        if(this.status === PENDING) {\r\n            this.value = reason // 设置据因\r\n            this.status = REJECT // 设置状态\r\n            this.onRejectCallBack.forEach(each => {\r\n                each(reason) // 执行回调\r\n            })\r\n        }\r\n    }\r\n    then(onReslove, onReject){}\r\n}\r\n```\r\n\r\n这里可能有人会说Promise应该是一个异步的过程, 在上面代码中并没有看到任何的异步. 比如说: setTimeout。\r\n\r\n解答：\r\n\r\n其实当创建一个Promise实例的时候，整个过程是同步的。\r\n\r\n也就是说\r\n\r\n```javascript\r\nconst ins = new Promise(function(res, rej) {\r\n    res(10)\r\n})\r\nconsole.log(ins)\r\nconsole.log('after ins')\r\n\r\n// 输出\r\n// Promise {<resolved>: 10}\r\n// after ins\r\n\r\n```\r\n\r\n当你执行完这一句， ins的状态会马上变成`RESOLVED`. 说明在构造方法中并没有执行异步操作。如果真的需要异步的话，则需要主动在调用`res`前，加上`setTimeout`来触发异步。\r\n\r\n```javascript\r\nconst ins = new Promise(function(res, rej) {\r\n    setTimeout(() => {\r\n        res(10)\r\n    })\r\n})\r\nconsole.log(ins)\r\nconsole.log('after ins')\r\n\r\n// 输出\r\n// Promise {<pending>}\r\n// after ins\r\n```\r\n\r\n### 还有一个`then`方法没有完成. 先看下规范怎么说\r\n\r\n- 一个promise必须提供一个`then`方法以访问当前值, 终止和据因\r\n- then接受两个参数`then(onResolve, onReject)`\r\n- onResolve和onReject都是可选, 如果不是函数则被忽略\r\n- onResolve方法在promise执行结束后被调用, 其第一个参数为promise的终值, 被调用次数不超过一次\r\n- onReject方法在promise被拒绝后被调用, 其第一个参数为promise的据因, 同样被调用次数不超过一次\r\n- onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用 \r\n- 如果onResolve和onReject返回一个值x, 则执行 **Promise解决过程**\r\n- then方法必须返回一个`promise`对象\r\n\r\n简单说就是\r\n\r\n- 如果promise处于pending, 则将then回调放入promise的回调\b列表中\r\n- 如果promise处于resolved, 则实行then方法中的onResolve\r\n- 如果promise处于rejected, 则执行then方法中的onReject\r\n- then方法要确保onResolve和onReject异步执行\r\n- onResolve和onReject返回的值都将用来解决下一个promise(后面再讲解)\r\n- 返回新的promise(注意: 一定是新的promise)\r\n\r\n```javascript\r\nclass Promise() {\r\n    // ...\r\n    then(onResolve, onReject){\r\n        const self = this\r\n        return new Promise(function(nextResolve, nextReject) {\r\n            if(self.status === PENDING) {\r\n                // 加入到任务队列\r\n                self.onResolveCallback.push(onResolve)\r\n                self.onRejectCallback.push(onReject)\r\n            } else if(self.status === RESOLVED) {\r\n                // 异步执行\r\n                setTimeout(onResolve, 0, self.value)\r\n            } else {\r\n                // 异步执行\r\n                setTimeout(onReject, 0, self.value)\r\n            }\r\n        })\r\n    }\r\n}\r\n```\r\n\r\n此时Promise已经可以完成异步操作.\r\n但是Promise还有一个关键特点是可以链式调用. 目前是还没有实现链式调用这一步.\r\n具体代码看[promise2.js](https://github.com/zWingz/Promise/blob/master/promise2.js)\r\n\r\n### 接下来继续看下规范怎么说\r\n\r\nPromise 解决过程\r\n\r\n- blablabla 这里比较长\r\n\r\n**简单说就是**\r\n\r\n`x`为`then`方法中`onResolve`或者`onReject`中返回的值, `promise2`为`then`方法返回的新`promise`.\r\n\r\n`promise`的解决过程是一个抽象步骤. 需要输入一个`promise`和一个**值**. 表示为`[[Resolve]](promise, x)`\r\n\r\n- 如果`x`和`promise2`相等, 则以`TypeError`为据因拒绝执行promise2\r\n- 如果`x`为`Promise`实例, 则让`promise2`接受x的状态\r\n- 如果`x`为`thenable`对象, 则调用其`then`方法\r\n- 如果都不满足, 则用`x`为参数执行`promise2`\r\n\r\n继续修改then方法, 以及添加`resolvePromise`来执行`Promise`解决过程\r\n\r\n```javascript\r\nfunction _isFunction(val) {\r\n  return typeof val === 'function'\r\n}\r\nfunction _isThenable(x) {\r\n  return _isFunction(x) || (typeof x === 'object' && x !== null)\r\n}\r\n\r\n/**\r\n * Promise 解决过程\r\n * 如果是thenable对象, 则触发该对象的then方法\r\n * 如果是一个值, 则直接调用resolve解析这个值\r\n * @param {Promise}} promise\r\n * @param {Object} x\r\n * @param {Function} resolve\r\n * @param {Function} reject\r\n */\r\nfunction resolvePromise(promise, x, resolve, reject) {\r\n  // 要求每次返回新的promise\r\n  // 如果返回是当前的promise, 则抛出typeError\r\n  if (x === promise) {\r\n    reject(new TypeError('Chaining cycle detected for promise'))\r\n  }\r\n  let called = false\r\n  // 判断是否thenable对象\r\n  if (_isThenable(x)) {\r\n    try {\r\n      const { then } = x\r\n      if (_isFunction(then)) {\r\n        then.call(\r\n          x,\r\n          val => {\r\n            if (!called) {\r\n              called = true\r\n              // 如果不断的返回thenable\r\n              // 则需要不断地递归\r\n              // 但是实际上不应该不断的返回thenable\r\n              resolvePromise(promise, val, resolve, reject)\r\n            }\r\n          },\r\n          reason => {\r\n            if (!called) {\r\n              called = true\r\n              reject(reason)\r\n            }\r\n          }\r\n        )\r\n      } else {\r\n        resolve(x)\r\n      }\r\n    } catch (e) {\r\n      if (called) {\r\n        return\r\n      }\r\n      called = true\r\n      reject(e)\r\n    }\r\n  } else {\r\n    //  非thenable, 则以该值来执行resolve\r\n    resolve(x)\r\n  }\r\n}\r\nclass Promise() {\r\n    // ...\r\n    /**\r\n   * then方法\r\n   * @param {Function} [onFulfilled] 前then的resolve函数, 当promise为RESOLVE时,处理当前结果\r\n   * @param {Function} onRejected 当前then的reject函数, 当promise被REJECT时调用\r\n   * @returns {Promise}\r\n   * @memberof Promise\r\n   */\r\n  then(onFulfilled, onRejected) {\r\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val\r\n    onRejected =\r\n      typeof onRejected === 'function'\r\n        ? onRejected\r\n        : err => {\r\n            throw err\r\n          }\r\n    const self = this\r\n    // 如果有then方法调用, 则将hasThenHandle设为true\r\n    // console.log(this);\r\n    this.hasThenHandle = true\r\n    /**\r\n     * 返回一个新的promise, 用于链式调用\r\n     */\r\n    const ret = new Promise(function(resolve, reject) {\r\n      // 用try..catch包裹执行方法\r\n      const tryCatchWrapper = function(fnc) {\r\n        return function() {\r\n          try {\r\n            fnc()\r\n          } catch (e) {\r\n            reject(e)\r\n          }\r\n        }\r\n      }\r\n      // 封装resolve方法回调\r\n      const doResolve = tryCatchWrapper(function() {\r\n        resolvePromise(ret, onFulfilled(self.value), resolve, reject)\r\n      })\r\n      // 封装reject方法回调\r\n      // 如果当前then没有相应的reject回调\r\n      const doReject = tryCatchWrapper(function() {\r\n        resolvePromise(ret, onRejected(self.value), resolve, reject)\r\n      })\r\n      if (self.status === PENDING) {\r\n        // 如果当前promise还未执行完毕, 则设置回调\r\n        self.onResolveCallback.push(doResolve)\r\n        self.onRejectCallback.push(doReject)\r\n      } else if (self.status === RESOLVED) {\r\n        // 如果为RESOLVE, 则异步执行resolve\r\n        setTimeout(doResolve, 0)\r\n      } else {\r\n        // 如果为REJECT, 则异步执行reject\r\n        setTimeout(doReject, 0)\r\n      }\r\n    })\r\n    return ret\r\n  }\r\n}\r\n```\r\n\r\n至此一个`Promise`可以说基本完成了.(完整代码请看[index.js](https://github.com/zWingz/Promise/blob/master/index.js))\r\n\r\n\r\n### 规范外的一些东西\r\n\r\n其实规范中定义的是`Promise`的构建和执行过程.\r\n\r\n而我们日常用到的却不至于规范中所提到的.\r\n\r\n比如\r\n\r\n- catch\r\n- finally\r\n- Promise.resolve\r\n- Promise.reject\r\n- all (未实现)\r\n- race (未实现)\r\n\r\n那接下来就说下关于这部分的实现\r\n\r\n#### catch\r\n\r\n上面有提到. catch其实是`then(undefined, reject)` 的简写. 所以这里比较简单\r\n\r\n``` javascript\r\nclass Promise() {\r\n    // ...\r\n    catch(reject) {\r\n        // 相当于新加入一个then方法\r\n        return this.then(undefined, reject)\r\n    }\r\n}\r\n```\r\n\r\n#### finally (ES2018引入标准)\r\n\r\nfinally函数作用我想大家都应该知道, 就是无论当前promise状态是如何. 都一定会执行回调.\r\n\r\nfinally方法中, 不接收任何参数, 所以并不能知道前面的Promise的状态.\r\n\r\n同时, 他不会对promise产生影响.总是返回原来的值 所以在`finally`中的操作,应该是与状态无关, 不依赖于promise的执行结果\r\n\r\n```javascript\r\nclass Promise() {\r\n    // ...\r\n    finally(fnc = () => {}) {\r\n        return this.then(val => {\r\n            fnc()\r\n            return val\r\n        }, err => {\r\n            fnc()\r\n            throw err\r\n        })\r\n    }\r\n}\r\n```\r\n\r\n#### Promise.resolve和Promise.reject (这里是从ES6入门中看到的定义)\r\n\r\n```javascript\r\n// 调用形式\r\nPromise.resolve(arg)\r\nPromise.reject(arg)\r\n```\r\n\r\n- Promise.resolve\r\n\r\n    根据arg的不同, 会执行不同的操作\r\n       - arg为Promise实例, 则原封不动的返回这个实例\r\n       - arg为thenable对象, 则会将arg转成promise, 并且立即执行`arg.then`方法(并不代表同步, 而是本轮事件循环结束时执行)\r\n       - arg不满足上述情况, 则返回一个新的Promise实例, 状态为resolved, 终值为arg\r\n    因此`Promise.resolve`是一个更方便的创建`Promise`实例的方法.\r\n\r\n- Promise.reject\r\n\r\n    这里就不会区分arg, 而是原封不动的把arg作为据因, 执行后续方法的调用.\r\n\r\n实现代码\r\n\r\n```javascript\r\nclass Promise() {\r\n    // ...\r\n    /**\r\n     * Promise.resolve\r\n     * 将参数转成Promise对象\r\n     * @static\r\n     * @param {any} val\r\n     * @returns {MPromise}\r\n     * @memberof MPromise\r\n     */\r\n    static resolve(x) {\r\n        // 如果为MPromise实例\r\n        // 则返回该实例\r\n        if(x instanceof Promise) {\r\n            return val\r\n        } else if(_isThenable(x)) {\r\n            // 如果为具有then方法的对象\r\n            // 则转为MPromise对象, 并且执行thenable\r\n            /**\r\n             * @example\r\n             * MPromise.resolve({\r\n             *      then(res) {\r\n             *          console.log('do promise')\r\n             *          res(10)\r\n             *      }\r\n             *  })\r\n             */\r\n            return new Promise(function(res, rej) {\r\n                // 执行异步\r\n                setTimeout(function() {\r\n                    val.then(res, rej)\r\n                }, 0)\r\n            })\r\n        }\r\n        // 如果val为一个原始值,或者不具有then方法的对象\r\n        // 则返回一个新的MPromise对象,状态为resolved\r\n        /**\r\n         * @example\r\n         * MPromise.resolve()\r\n         */\r\n        return new Promise(function(res) {res(x)})\r\n    }\r\n    /**\r\n     * reject方法参数会原封不动的作为据因而变成后续方法的参数\r\n     * 且初始状态为REJECT\r\n     * 不存在判别thenable\r\n     * @static\r\n     * @param {any} reason \r\n     * @returns \r\n     * @memberof MPromise\r\n     */\r\n    static reject(reason) {\r\n        /**\r\n         * @example\r\n         * MPromise.reject('some error')\r\n         */\r\n        return new Promise(function(res, rej) {rej(reason)})\r\n    }\r\n}\r\n```\r\n\r\n### 开发过程中遇到其他问题\r\n\r\n#### node中的`unhandledRejection`和浏览器中的`Uncaught (in promise)` 提示\r\n\r\n在Promise中产生的所有错误都会被Promise吞掉. 当没有相应的错误处理函数时候, node和浏览器分别有不同的表现.\r\n\r\n但是这并不是一个新的错误, 因为不能用`try{} catch(){}` 捕获.\r\n\r\n所以在浏览器端, 是一个`console.error`的错误提示, 在`node`中, 这个算是一个事件. 具体可以通过`process.on`来监听\r\n\r\n```javascript\r\nprocess.on('unhandledRejection', function (err, p) {\r\n  throw err;\r\n});\r\n```\r\n\r\n在编写代码中, 一开始卡在这一步挺久.\r\n\r\n由于无法知道promise实例后续是否有相应的错误处理函数.\r\n\r\n简单的判断`onReject === undefined` 是不行的.\r\n\r\n形如:\r\n\r\n```javascript\r\nPromise.reject(10)\r\n// 或者\r\nnew Promise(function(res, rej) {\r\n    rej(10)\r\n})\r\n```\r\n\r\n这类是同步执行的, `onReject === undefined` 恒为`true`.\r\n\r\n我的做法是给promise实例添加一个`hasThenHandle`的属性, 在`then`方法中将其设为`true`\r\n\r\n在`reject`方法中使用`setTimeout`异步判断该值是否为`true`, 如果不是则通过`console.error`抛出提示.\r\n\r\n其实在原生Promise中, 抛出的`unhandledRejection` 也是属于异步的.\r\n\r\n```javascript\r\nPromise.reject(10)\r\nconsole.log('after Promise.reject')\r\nnew Promise(function(res, rej) {\r\n    rej(10)\r\n})\r\nconsole.log('after new Promise')\r\n\r\n// 输出\r\n// after Promise.reject\r\n// after new Promise\r\n// Uncaught (in promise) 10\r\n// Uncaught (in promise) 10\r\n```\r\n\r\n于是这个问题也能得到很好地解决.\r\n\r\n至此完整代码已经结束, 具体看`index.js`.\r\n\r\n## 存在的问题\r\n\r\n- 由于用的是setTimeout模拟, 所以优先级不能保证高于setTimeout\r\n    - 浏览器中可以用MessageChannel(macrotask)\r\n    - node中可以用setImmediate(优先级在某些情况下比setTimeout高一些)\r\n    - setTimeout和setImmediate在无IO操作下,两者执行顺序不确定,但是在IO操作下,setImmediate比setTimeout优先级高. 且setImmediate只在IE下有效\r\n\r\n## 参考\r\n\r\n[【翻译】Promises/A+规范](http://www.ituring.com.cn/article/66566)\r\n\r\n[ECMAScript 6入门](http://es6.ruanyifeng.com/#docs/promise#Promise-prototype-finally)\r\n"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/15","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/15/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/15/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/15/events","html_url":"https://github.com/zWingz/my-blog-config/issues/15","id":310330786,"node_id":"MDU6SXNzdWUzMTAzMzA3ODY=","number":15,"title":"初次制作戚风蛋糕（6寸）","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211325,"node_id":"MDU6TGFiZWw4MTkyMTEzMjU=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/%E6%9D%82%E4%BA%8B","name":"杂事","color":"537fbc","default":false},{"id":819211211,"node_id":"MDU6TGFiZWw4MTkyMTEyMTE=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/%E7%83%98%E7%84%99","name":"烘焙","color":"fcd5b0","default":false},{"id":819211260,"node_id":"MDU6TGFiZWw4MTkyMTEyNjA=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/%E7%94%9F%E6%B4%BB","name":"生活","color":"95ed9b","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-04-01T15:13:17Z","updated_at":"2018-04-01T15:13:17Z","closed_at":null,"author_association":"OWNER","body":"## 材料\r\n\r\n- 低筋面粉 45g\r\n- 鸡蛋 3个\r\n- 色拉油(植物油/玉米油) 20g\r\n- 牛奶25g (没有牛奶.所以用了奶粉+水冲兑)\r\n- 砂糖 40g(蛋白30g 蛋黄10g)\r\n- 打蛋盆和有同样大的盆子\r\n- 6寸模具（我的模具是8寸）\r\n\r\n## 步骤\r\n- 用电子秤准确称取上次材料.。糖要分开秤,因为用途不一样。\r\n- 是蛋清分离器将蛋白和蛋黄分开。每次分离时候在小碗里面分离，分离完了才将蛋白倒入打蛋盆中，以免污染了打蛋盆中的蛋白。将蛋黄放入另一个盆子中。\r\n- 加入10g砂糖到打蛋盆中，使用电动打蛋器低速搅动。待出现大量泡泡时候，倒入10g糖，开高速档进行搅动，当蛋清出现纹路后，加入最后10g砂糖，继续搅动。直到打蛋器提起后蛋白不会掉落，此时蛋白已经算打发完成。\r\n- 用手动打蛋器搅拌蛋黄，搅拌完后，倒入10g砂糖、25g牛奶、20g植物油。继续搅拌。\r\n- 用面粉筛将低筋面粉塞入蛋黄液中。\r\n- 使用刮刀将面粉和蛋黄液混合，此处不能用打蛋器。刮刀混合时候从下往上翻，不能想打鸡蛋一样顺时针转动。要像炒菜一样。\r\n- 混合搅拌至面粉糊没有颗粒。\r\n- 烤箱150°预热10分钟。\r\n- 取1/3打发好的蛋白，混入面糊当中，继续用刮刀将两者搅拌均匀。\r\n- 将面糊全部倒入到打蛋盆中，与剩余的蛋白继续搅拌均匀，直到没有颗粒。\r\n- 将搅拌好的面糊倒入蛋糕模中。\r\n- 烤箱150°烤30-40分钟。\r\n- 完成后取出。\r\n- 摔模：将模具举高离台面5-8cm，摔下。\r\n- 然后将模具倒扣在烤网上面，待蛋糕冷却后脱模。\r\n- 此时戚风蛋糕制作完成。\r\n\r\n## 失败点与总结\r\n\r\n- 烤的中途打开了烤箱门，可能导致蛋糕回缩了。 因为一开始时候蛋糕还是逐渐增高，后面不知道为什么缩回去了，有可能是因为我打开了烤箱门。\r\n- 第三个鸡蛋蛋清分离失败了，然后就直接把整个鸡蛋放入蛋黄液中，也不清楚是否有影响。\r\n- 没有用牛奶而是用奶粉+水，可能有影响。 \r\n\r\n\r\n## 图片\r\n\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-4-1/92583692.jpg)\r\n\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-4-1/31921272.jpg)\r\n\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-4-1/61126157.jpg)\r\n\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-4-1/44394098.jpg)\r\n\r\n## 最后\r\n\r\n这次戚风蛋糕第一次尝试，还是挺不错的，评个80分吧。\r\n\r\n本来是打算弄芝士蛋糕，奈何没有奶油奶酪，只能做原味戚风蛋糕了。\r\n下次可以买奶油奶酪试试做芝士蛋糕。\r\n\r\n周末做了下蛋包饭，差点就做成了蛋炒饭。\r\n\r\n原因还是材料太多了，炒起来鸡蛋都保不住。\r\n\r\n不过吃起来还是挺好吃，可能下次要注意下材料分量，鸡蛋能包起来就更好吃了。"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/14","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/14/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/14/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/14/events","html_url":"https://github.com/zWingz/my-blog-config/issues/14","id":308242286,"node_id":"MDU6SXNzdWUzMDgyNDIyODY=","number":14,"title":"记：再一次制作蛋挞。","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211325,"node_id":"MDU6TGFiZWw4MTkyMTEzMjU=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/%E6%9D%82%E4%BA%8B","name":"杂事","color":"537fbc","default":false},{"id":819211211,"node_id":"MDU6TGFiZWw4MTkyMTEyMTE=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/%E7%83%98%E7%84%99","name":"烘焙","color":"fcd5b0","default":false},{"id":819211260,"node_id":"MDU6TGFiZWw4MTkyMTEyNjA=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/%E7%94%9F%E6%B4%BB","name":"生活","color":"95ed9b","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-03-24T09:13:45Z","updated_at":"2018-03-24T09:15:27Z","closed_at":null,"author_association":"OWNER","body":"## 材料\r\n\r\n- 蛋黄3个 (蛋清分离，只要蛋黄)\r\n- 糖霜 10g （太少了，下次可以试着20g）\r\n- 牛奶250ml\r\n- 低筋粉 15g （有点多，下次试着10g）\r\n- 蛋挞皮9个 （刚好的）\r\n\r\n## 过程\r\n\r\n- 用蛋清分离器，将鸡蛋逐个进行蛋清分离。将蛋黄放入打蛋盆中，蛋清可以另外存放，可以作为双皮奶原料。\r\n- 由于没有牛奶，于是用了4勺奶粉代替。\r\n- 电子秤称取10g糖霜。此次蛋挞不够甜，下次可以尝试放20g，或者15g砂糖也可以。\r\n- 将糖霜倒入奶粉中，并用热水冲兑，搅拌，静置到常温。\r\n- 用电子秤称取15g低筋粉（此次感觉过多，下次只称取10g），放入小碗中存放。\r\n- 用打蛋器（手动）将蛋黄打散，并逐步加入混入糖霜的牛奶，分三次倒入，一边倒一边搅拌。\r\n- 用面粉筛分三次筛入低筋面粉，并且一边筛入一边搅拌，尽量让蛋液和面粉混合。\r\n- 筛入面粉后，此时蛋液有较多的泡沫。\r\n- 使用过滤筛，过滤掉过多的泡沫。此次我一共过滤了三遍。\r\n- 烤箱220度预热10分钟。\r\n- 取出烤盆，铺上油纸，放入9个蛋挞皮。\r\n- 倒入蛋挞液，9成满。\r\n- 烤箱预热完毕，则放入蛋挞烤即可。\r\n- 220度烤25分钟即可完成。\r\n\r\n## 上图\r\n\r\n### 倒入蛋挞液后\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-3-24/45790429.jpg)\r\n\r\n### 放入烤箱\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-3-24/75661678.jpg)\r\n\r\n### 正在烤的蛋挞\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-3-24/33388698.jpg)\r\n\r\n### 成品\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-3-24/38696134.jpg)\r\n\r\n## 结语\r\n\r\n- 不够甜，需要加多点糖。\r\n- 面粉太多了，有点沉底。"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/13","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/13/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/13/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/13/events","html_url":"https://github.com/zWingz/my-blog-config/issues/13","id":303526921,"node_id":"MDU6SXNzdWUzMDM1MjY5MjE=","number":13,"title":"开发环境搭建","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-03-08T15:45:19Z","updated_at":"2018-03-08T15:45:53Z","closed_at":null,"author_association":"OWNER","body":"# mac开发环境\r\n\r\n## 安装 brew\r\n\r\n```bash\r\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\r\n```\r\n\r\n\r\n\r\n\r\n## 终端环境\r\n\r\n- [iterm2](https://www.iterm2.com/)\r\n\r\n- [oh-my-zsh](http://ohmyz.sh/)\r\n\r\n  安装\r\n\r\n  ```bash\r\n  sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\r\n  ```\r\n\r\n  添加插件\r\n\r\n  ```bash\r\n  vim ~/.zshrc\r\n  ```\r\n\r\n  ```bash\r\n  plugins=(\r\n    git\r\n    z\r\n  )\r\n  ```\r\n\r\n  ​\r\n\r\n## node 环境搭建\r\n\r\n+ 安装 nvm\r\n\r\n  ```shell\r\n  curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\r\n  # or\r\n  wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\r\n   \r\n   \r\n  # then\r\n  # vim ~/.bash_profile or ~/.zshrc or ~/.profile or ~/.bashrc\r\n  # insert\r\n  export NVM_DIR=\"$HOME/.nvm\"\r\n  [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm\r\n   \r\n   \r\n  # last\r\n  source ~/.your_rcprofile\r\n  ```\r\n\r\n  ​\r\n\r\n  使用方法\r\n\r\n  ```shell\r\n  # 本地node版本\r\n  nvm ls\r\n   \r\n   \r\n  # node所有版本\r\n  nvm ls-remote\r\n   \r\n   \r\n  # 安装最新node(稳定版,即偶数版)\r\n  nvm install --lts\r\n   \r\n   \r\n  # 安装指定版本node\r\n  nvm install v8.9.4\r\n   \r\n   \r\n  # 切换到指定版本/别名node\r\n  nvm use v8.9.4\r\n   \r\n   \r\n  # 给node版本起别名\r\n  nvm alias default v8.9.4\r\n  ```\r\n\r\n+ 安装 node\r\n\r\n  `nvm install v8.9.4`\r\n\r\n+ npm 换源\r\n\r\n  ```bash\r\n  # npm 源\r\n  npm config set registry https://registry.npm.taobao.org\r\n  # sass 源\r\n  npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/\r\n  ```\r\n\r\n  ​\r\n\r\n## git 配置\r\n\r\n+ 安装\r\n\r\n  ```\r\n  brew install git\r\n  ```\r\n\r\n+ 配置 ssh-key\r\n\r\n  ```bash\r\n  git config --global user.name ''\r\n  git config --global user.email ''\r\n\r\n  ssh-keygen -t res -C 'email'\r\n  ```\r\n\r\n  ​\r\n\r\n+ 配置 hosts\r\n\r\n  ```bash\r\n  cd ~/.ssh\r\n  vim config\r\n\r\n  # 写入\r\n  Host github.com\r\n  HostName github.com\r\n  User git\r\n  IdentityFile ~/.ssh/id_rsa_github\r\n\r\n  Host gitlab.com\r\n  HostName gitlab.com\r\n  User git\r\n  IdentityFile ~/.ssh/id_rsa_gitlab\r\n\r\n\r\n  # 注入密码,下次不需要再输密码(除非重启)\r\n  ssh-add -k ~/.ssh/id_rsa_gitlab\r\n  ```\r\n\r\n  ​\r\n\r\n## [vscode](https://code.visualstudio.com/) 编辑器\r\n\r\n+ 安装插件 `Setting Sync`\r\n+ 设置 gist `\"sync.gist\": \"8162a18bd9632ab95c50704e92e1a57c\"`\r\n+ 同步 Setting\r\n+ 主要插件` eslint` `vetur` `document this` `javascript code snippets` `project manager`\r\n\r\n\r\n\r\n\r\n\r\n\r\n开发环境搭建完毕\r\n------------------\r\n\r\n"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/11","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/11/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/11/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/11/events","html_url":"https://github.com/zWingz/my-blog-config/issues/11","id":295960409,"node_id":"MDU6SXNzdWUyOTU5NjA0MDk=","number":11,"title":"vue组件-固定表格","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false},{"id":819211105,"node_id":"MDU6TGFiZWw4MTkyMTExMDU=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/vue","name":"vue","color":"dd4970","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-02-09T18:10:56Z","updated_at":"2018-02-21T16:32:31Z","closed_at":null,"author_association":"OWNER","body":"# 固定表格\r\n后台管理系统,多多少少会有列表页.\r\n\r\n而列表页又正是由表格形成.\r\n\r\n但是原生的表头并不能固定头部以及两侧.\r\n\r\n一旦数据多了,查看起来就不方便了.\r\n\r\n于是乎就出现很多固定表头/两侧的表格组件\r\n\r\n## 实现原理\r\n\r\n### 绝对定位\r\n- 实现方式\r\n  这种应该是最普遍也是最简单的方式.\r\n\r\n  就是将一个表格分成多个表格.\r\n\r\n  包括表头/左侧/右侧/表体, 共四个表格\r\n\r\n  然后通过 css 方式将表头以及两侧固定\r\n\r\n  之后通过 scroll 事件的监听,同步表头以及两侧的 scroll 值,就可以达到固定的效果\r\n\r\n- 优点\r\n  实现起来简单,而且无缝滚动\r\n\r\n- 缺点\r\n  表格都是使用 table-layout:fixed; 使得每个单元格宽度固定.\r\n\r\n  如果不使用 fixed 的话.则需要一个 <col> 管理每一列的宽度.\r\n\r\n  这样不能达到宽度自适应的情况\r\n\r\n  滚动必须是局部滚动.而不是跟随全局.\r\n\r\n- 例子\r\n  elementUI 的表格就是这样实现的.\r\n  ![](http://ol1hthxqp.bkt.clouddn.com/18-2-10/39962386.jpg)\r\n  同一个表格的表头,表体分别复制了3次.用来形成表头和两侧的固定.\r\n\r\n  使用绝对定位固定两侧.\r\n\r\n  通过管理 scroll 的值管理表头以及两侧滚动.\r\n\r\n  这样就会导致 dom 数量的增加.\r\n\r\n\r\n## css 方法 - position: sticky\r\n\r\n此方法原生支持固定表头.\r\n\r\n但是目前[兼容性](https://caniuse.com/#feat=css-sticky)不客观\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-2-10/67634294.jpg)\r\n\r\n\r\n\r\n## 本文实现\r\n\r\n- [DEMO](http://zwing.site/vue-fixed-table/release/demo.html)(原谅我没弄样式)\r\n\r\n### 背景\r\n当固定表头的需求提出来时,我也是曾经想过直接使用 elementUI 的表格.\r\n\r\n但是发现使用 elementUI 的表格插件需要改动不少代码.而且感觉不够灵活.\r\n\r\n于是就自己去实现\r\n\r\n### 第一版\r\n由于考虑到不想使用 fixed 布局以及组个单元格去管理宽度.\r\n\r\n而且不想使用局部滚动\r\n\r\n所以一开始就决定使用 监听全局滚动+transition 方式.让表格头跟随滚动走\r\n\r\n也就是说.当表头贴近浏览器上端的时候才固定.\r\n\r\n而不是局部滚动式的固定.\r\n\r\n这样 thead 和 tbody 就是一体,不存在宽度不一致问题\r\n\r\n### 兼容性问题\r\n一旦thead产生了 transform. 表格的 border-collapse 会失效.表格头的边框会消失.\r\n\r\n为了解决这个问题.我使用阴影来替代 border.\r\n\r\n但是在 safari 上.transform 部分不会显示出阴影..暂无解\r\n\r\n对于 transition 问题.\r\n\r\n在 chrome 下不存在闪烁卡顿现象, 而在 Firefox 和 safari 则存在闪烁和卡顿现象.\r\n\r\n由于是内部系统, 使用 chrome 居多.所以 firefox 和 safari 下只做了兼容性处理.\r\n\r\n### 第二版\r\n在第一版完成后, 基本实现了固定表格头功能. 而且在 chrome 下表现顺畅.\r\n\r\n于是着手实现固定两侧.这里实现原理一样.所以很容易实现\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-2-10/60520413.jpg)\r\n\r\n这种虽然右侧是固定在浏览器右侧.\r\n\r\n但是整体页面还是被撑开的.\r\n\r\n那么对于表格上下的其他组件,他们依旧是被浏览器隐藏.需要横向滚动才能看到.\r\n\r\n于是我继续开始第三版改造\r\n\r\n\r\n\r\n### 第三版\r\n\r\n这一版主要就是为了页面的其他组件不被表格的宽高影响.也就是说不管表格多高多宽.\r\n\r\n都可以在不滚动的前提下看到.\r\n\r\n那么就是将表格变成局部滚动了.\r\n\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-2-10/99932867.jpg)\r\n\r\n其实就是一个自适应的内滚动容器.\r\n\r\n前提是页面高度宽度都是100%\r\n\r\n也就是说要有环境让容器产生滚动\r\n\r\n监听此容器的滚动来控制表格头和两侧的固定.\r\n\r\n但是收到反馈说这种表格看起来很狭小.不够大气\r\n\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-2-10/42701513.jpg)\r\n\r\n\r\n\r\n没办法,只能继续进行思考改进\r\n\r\n\r\n\r\n### ### 思考改进\r\n\r\n在开始之前我的想法是\r\n\r\n结合第二第三版.\r\n\r\n将垂直滚动交给页面.横向滚动自管理.\r\n\r\n什么意思呢?\r\n\r\n就是页面高度可以被撑开. 但是宽度不能被撑开.\r\n\r\n也就是说全局只有 y 轴滚动.没有 x 轴滚动.\r\n\r\n其实第三版是可以实现的.\r\n\r\n页面只需限制宽度为100%.高度不做限制,就可以轻松的达到要求.\r\n\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-2-10/27128653.jpg)\r\n\r\n注意这里的高度其实没有做限制的.也就是说容器滚动条被隐藏了.\r\n\r\n那如果要横向滚动怎么办.\r\n\r\n很简单啊.按着 shift 再滚动就是横向滚动了.\r\n\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-2-10/42701513.jpg)\r\n\r\n这是不科学的.不是每个人都知道.\r\n\r\n那样是不是可以有一条虚拟的横向滚动条, 来管理表格的横向滚动呢.\r\n\r\n于是就有第四版\r\n\r\n\r\n\r\n### 第四版\r\n\r\n就是就是额外添加一个虚拟滚动条的组件.\r\n\r\n当容器底部被浏览器隐藏时候.则平移这个滚动条至屏幕底部\r\n\r\n- 原生滚动条被隐藏时候,显示虚拟滚动条\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-2-10/24267221.jpg)\r\n- 原生滚动条显示时候,隐藏虚拟滚动条\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-2-10/61056576.jpg)\r\n\r\n\r\n\r\n这样, 既能使得页面不被撑开. 同时高度也不需要限定在100%.\r\n\r\n刚好能满足需求.\r\n\r\n\r\n\r\n### 实现方法\r\n\r\n实现方法其实就是使用 transform 以及监听滚动来实现固定咯.\r\n\r\n但是在使用上,则需要有一定的规则.\r\n\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-2-10/81508433.jpg)\r\n\r\n也就是说\r\n\r\n在使用的时候.要通过 slot 分别配置 head,left,right 的内容.\r\n\r\n简单说就是把表格拆分成左/中/右\r\n\r\n那么 thead 和 tbody 就能保持列宽度.\r\n\r\n关键处理:\r\n\r\n- 通过 slot配置左/中/右以及表格头/表格体 \r\n\r\n\r\n- hover 样式需要通过 mouseOver 和 mouseleave 去管理\r\n- 通过监听表格和窗口的 resize 事件,以及使用 MutationObserver 来监听表格子节点的变化来重新获取表格宽度.(因为双侧固定需要依赖左中右的宽度)\r\n- 通过监听全局滚动, 固定表格头\r\n- 通过监听父容器的横向滚动, 固定两侧\r\n\r\n\r\n\r\n### 不足之处\r\n\r\n- 兼容性不太好, 在 chrome 表现良好(至少高版本的流畅), firefox 和 safari 则有卡顿现象,目前做法是在滚动时候,使用 opcity 将固定部分隐藏.滚动结束后显示\r\n\r\n- table 宽度变更时候. 右侧会有闪烁. 因为右侧固定算是很依赖表格宽度以及自身宽度.所以宽度变化对右侧影响很大. 暂未解决\r\n\r\n- 需要有 css 支持. 让容易有一个可滚动的环境.\r\n\r\n- 使用时候会把正常的 table 拆分成几部分. \r\n\r\n  ![](http://ol1hthxqp.bkt.clouddn.com/18-2-10/67633591.jpg)\r\n\r\n\r\n\r\n\r\n\r\n### AlignCell 是什么 ?\r\n\r\n其实就是 th 或者 td.\r\n\r\n封装起来就是因为设计师想要达到表格每一列整体居中的前提下,左或者右对齐.\r\n\r\n当然, 当数据量多的时候,每个单元格基本都是刚满足宽度. 直接左对齐是没问题的.\r\n\r\n但是当数据不多.每个单元格宽度都是充足时候,这时候直接使用左对齐是不行的\r\n\r\n那么,我也只好封装一层了. 这里就不介绍了\r\n\r\n\r\n## 结语\r\n虽然瑕疵比较多.但是开发整个组件过程,我个人是收获不少的.\r\n\r\n由于是内部系统.也没怎么考虑兼容性.能在 chrome 顺利跑就问题不大了.\r\n\r\n后续会继续优化\r\n\r\n\r\n## 放假了, 过年了\r\n\r\n祝大家新年快乐 !"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/10","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/10/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/10/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/10/events","html_url":"https://github.com/zWingz/my-blog-config/issues/10","id":294718179,"node_id":"MDU6SXNzdWUyOTQ3MTgxNzk=","number":10,"title":"使用vuexStore.registerModule构建命令式组件","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false},{"id":819211023,"node_id":"MDU6TGFiZWw4MTkyMTEwMjM=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/js","name":"js","color":"c5def5","default":false},{"id":819211105,"node_id":"MDU6TGFiZWw4MTkyMTExMDU=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/vue","name":"vue","color":"dd4970","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-02-06T11:04:40Z","updated_at":"2018-02-06T11:06:39Z","closed_at":null,"author_association":"OWNER","body":"## 命令式组件\r\n例如Notification, MessageBox, Alert, ConfirmBox 等等\r\n\r\n这类组件都是通过命令式来调用.\r\n\r\n例如`elementUi`中`this.$message`或者`Message`来调用.\r\n\r\n对于我们来说,`this.$message`这种调用方法莫过于是最方便.因为不需要处处引入`Message`或者在`webpack`中配置插件使得`Message`暴露于全局\r\n\r\n那么我就从`this.$message`这类讲起\r\n\r\n## 组件编写\r\n其实也只是编写一个Comp组件, 这里不多说.\r\n\r\n\r\n## 接入方式\r\n\r\n### 第一种接入方式\r\n将`Vue`组件挂载到一个`dom`上,也就是将组件实例化.\r\n\r\n然后将组件实例挂载命名空间中或者`Vue.prototype`中,\r\n\r\n这样相当于直接操作组件实例的`methods`来改变组件的状态.\r\n\r\n`ElementUI`使用的是这种方式.\r\n\r\n无入侵式\r\n\r\n\r\n### 第二种接入方式\r\n这方式前提必须要使用Vuex, 因为他是依赖vuex.registerStore实现\r\n\r\n关于registerStore请移步到[文档](https://vuex.vuejs.org/en/modules.html)中\r\n\r\n其实就是动态注册一个storeModule, 用来管理组件的状态.\r\n\r\n所有操作都通过细改store的状态来引起组件的改变\r\n```javascript\r\n// 引入组件\r\nimport Comp from 'Comp.vue'\r\nfunction registerModule(store) {\r\n    store.registerModule('compNameSpaceState', {\r\n        namespaced: true,\r\n        state: {},\r\n        getters: {},\r\n        mutations: {},\r\n        actions: {}\r\n    })\r\n}\r\n```\r\n\r\n之后可以将通过对象将调用接口暴露出去\r\n```javascript\r\nlet $compApi = function () {\r\n    return {\r\n    \t// 此处需要使用建投函数,确保this指向\r\n    \taction: () => {\r\n          this.$store.dispatch('compNameSpaceState/compAction')\r\n    \t}\r\n    }\r\n}\r\n```\r\n\r\n接下来很简单,就是将$compApi.prototype中.\r\n\r\n那么如何保证`$compApi`中`this`指向`Vue`实例呢\r\n```javascript\r\nlet bind = false\r\n// Vue.use() 会自动调用install方法,此时可以注册组件\r\nComp.install = function (Vue) {\r\n    // 代理带vue原形上.可以通过this.$spin调用\r\n    Object.defineProperties(Vue.prototype, {\r\n        $compApi: { // 挂载到Vue.prototype中的$compApi\r\n            get() {\r\n                if(!bind) {\r\n                \t// 注册store\r\n                    registerModule(this.$store)\r\n                    // 只需要绑定一次即可\r\n                    // 绑定后可以将原来的$compApi覆盖掉\r\n                    // 调用bind函数确保this指向\r\n                    $compApi = $compApi.bind(this)()\r\n                    bind = true\r\n                }\r\n                return $compApi\r\n            }\r\n        }\r\n    })\r\n    // 将组件注册为Vue全局组件\r\n    Vue.component('Comp', Comp)\r\n}\r\nexport default Comp\r\n```\r\n\r\n最后一步则需要在App.vue将Comp挂载上去\r\n```javascript\r\n// 这一步自动调用install, 会全局注册Comp\r\n// 但是在第一次调用$compApi时候才会进行registerStore.\r\nVue.use(Comp)\r\n```\r\n```html\r\n<!-- App.vue-->\r\n<template>\r\n\t<Comp/>\r\n</template>\r\n```\r\n\r\n这种方法是入侵式的\r\n\r\n但是可以很方便的追踪组件状态, 而且实现起来也很方便.\r\n\r\n在自己开发组件的时候可以考虑"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/9","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/9/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/9/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/9/events","html_url":"https://github.com/zWingz/my-blog-config/issues/9","id":294606689,"node_id":"MDU6SXNzdWUyOTQ2MDY2ODk=","number":9,"title":"[about]About me","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-02-06T02:01:17Z","updated_at":"2018-03-24T09:23:10Z","closed_at":null,"author_association":"OWNER","body":"- Beat Ganon \r\n- Save Zelda\r\n- Liberate Hyrule\r\n\r\n![image](https://user-images.githubusercontent.com/13031838/35838096-9b7c7522-0b24-11e8-948a-159854024ee5.png)\r\n"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/8","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/8/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/8/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/8/events","html_url":"https://github.com/zWingz/my-blog-config/issues/8","id":294602245,"node_id":"MDU6SXNzdWUyOTQ2MDIyNDU=","number":8,"title":"Eventloop中的microtask和macrotask","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false},{"id":819211023,"node_id":"MDU6TGFiZWw4MTkyMTEwMjM=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/js","name":"js","color":"c5def5","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-02-06T01:35:11Z","updated_at":"2018-02-06T10:21:25Z","closed_at":null,"author_association":"OWNER","body":"# EventLoop\r\n\r\njs是单线程的, 所有异步都需要经过Eventloop(事件循环).这里不介绍eventloop\r\n\r\n\r\n 主要记录下eventloop中的microtask 和macrotask\r\n\r\n\r\n\r\n## microtask\r\n\r\n- process.nextTick\r\n- Promise\r\n- Object.observe\r\n- MutationObserver\r\n\r\n\r\n\r\n## macrotask\r\n\r\n- setTimeout\r\n- setImmediate\r\n- setInterval\r\n- UI rendering\r\n- 网络I/O以及用户I/O\r\n- network\r\n\r\n\r\n\r\n## 优先级\r\n\r\n- microtask > macrotask\r\n- process.nextTick > promise (process.nextTick只在node使用)\r\n- setTimeout和setImmediate在无IO操作下,两者执行顺序不确定,但是在IO操作下,setImmediate比setTimeout优先级高. 且setImmediate只在IE下有效\r\n\r\n\r\n\r\n## 应用\r\n\r\nVue.nextTick源码中,分别使用了microtask和macrotask\r\n\r\n在Vue2.4版本之前,默认都是使用microtask.优先判断是否支持promise,如果不支持则退回到MutationObserver,如果再不支持则回退到setTimeout\r\n\r\n\r\n但在后续更新中,Vue已经修改nextTick实现方式.默认使用microtask, 同时也提供方法强制使用macrotask,例如由v-on绑定的事件处理.\r\n\r\n\r\n原因就是因为microtask优先级太高.甚至高于事件冒泡. 而macrotask则会引起一些问题.\r\n\r\n\r\n详情请看[Vue.nextTick源码](https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L20:4)\r\n\r\n```javascript\r\n// Here we have async deferring wrappers using both micro and macro tasks.\r\n// In < 2.4 we used micro tasks everywhere, but there are some scenarios where\r\n// micro tasks have too high a priority and fires in between supposedly\r\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\r\n// event (#6566). However, using macro tasks everywhere also has subtle problems\r\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\r\n// Here we use micro task by default, but expose a way to force macro task when\r\n// needed (e.g. in event handlers attached by v-on).\r\nlet microTimerFunc\r\nlet macroTimerFunc\r\nlet useMacroTask = false\r\n\r\n// Determine (macro) Task defer implementation.\r\n// Technically setImmediate should be the ideal choice, but it's only available\r\n// in IE. The only polyfill that consistently queues the callback after all DOM\r\n// events triggered in the same loop is by using MessageChannel.\r\n/* istanbul ignore if */\r\nif (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\r\n  macroTimerFunc = () => {\r\n    setImmediate(flushCallbacks)\r\n  }\r\n} else if (typeof MessageChannel !== 'undefined' && (\r\n  isNative(MessageChannel) ||\r\n  // PhantomJS\r\n  MessageChannel.toString() === '[object MessageChannelConstructor]'\r\n)) {\r\n  const channel = new MessageChannel()\r\n  const port = channel.port2\r\n  channel.port1.onmessage = flushCallbacks\r\n  macroTimerFunc = () => {\r\n    port.postMessage(1)\r\n  }\r\n} else {\r\n  /* istanbul ignore next */\r\n  macroTimerFunc = () => {\r\n    setTimeout(flushCallbacks, 0)\r\n  }\r\n}\r\n\r\n// Determine MicroTask defer implementation.\r\n/* istanbul ignore next, $flow-disable-line */\r\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\r\n  const p = Promise.resolve()\r\n  microTimerFunc = () => {\r\n    p.then(flushCallbacks)\r\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\r\n    // it can get stuck in a weird state where callbacks are pushed into the\r\n    // microtask queue but the queue isn't being flushed, until the browser\r\n    // needs to do some other work, e.g. handle a timer. Therefore we can\r\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\r\n    if (isIOS) setTimeout(noop)\r\n  }\r\n} else {\r\n  // fallback to macro\r\n  microTimerFunc = macroTimerFunc\r\n}\r\n```\r\n\r\n"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/7","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/7/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/7/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/7/events","html_url":"https://github.com/zWingz/my-blog-config/issues/7","id":293431355,"node_id":"MDU6SXNzdWUyOTM0MzEzNTU=","number":7,"title":"多个git 配置ssh key","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-02-01T07:37:09Z","updated_at":"2018-02-06T10:21:40Z","closed_at":null,"author_association":"OWNER","body":"## 安装\r\n\r\n```bash\r\nbrew install git\r\n# or\r\n# apt-get install git\r\n\r\n## 配置ssh-key\r\n\r\ngit config --global user.name ''\r\ngit config --global user.email ''\r\n\r\nssh-keygen -t res -C 'email'\r\n# 然后就是自定义\r\n# 要不要密码随便你\r\n# 反正下面都会进行ssh-add\r\n```\r\n\r\n上github或者gitlab, 进入setting,找到ssh-key, 点击new SSH Key 把id_rsa.pub内容粘贴进去就ok了\r\n\r\n![image](https://user-images.githubusercontent.com/13031838/35666461-2aaa5d40-0765-11e8-9e62-1ae17cb933a2.png)\r\n\r\n## 检查\r\n`ssh git@github.com`\r\n\r\n![image](https://user-images.githubusercontent.com/13031838/35666525-620a3544-0765-11e8-8590-1018bdabae20.png)\r\n\r\n## 配置hosts\r\n\r\n```bash\r\ncd ~/.ssh\r\nvim config\r\n\r\nHost github.com\r\nHostName github.com\r\nUser git\r\nIdentityFile ~/.ssh/id_rsa_github\r\n\r\nHost gitlab.com\r\nHostName gitlab.com\r\nUser git\r\nIdentityFile ~/.ssh/id_rsa_gitlab\r\n\r\n\r\n# 注入密码,下次不需要再输密码(除非重启)\r\nssh-add -k ~/.ssh/id_rsa_gitlab\r\n```\r\n\r\n### 简单快捷完成git配置了"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/6","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/6/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/6/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/6/events","html_url":"https://github.com/zWingz/my-blog-config/issues/6","id":293426099,"node_id":"MDU6SXNzdWUyOTM0MjYwOTk=","number":6,"title":"记一次webpack优化 --- 从babelrc和UglifyPlugin下手","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false},{"id":819211088,"node_id":"MDU6TGFiZWw4MTkyMTEwODg=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/webpack","name":"webpack","color":"1faf32","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-02-01T07:13:03Z","updated_at":"2018-02-01T07:19:30Z","closed_at":null,"author_association":"OWNER","body":"## 优化前\r\n\r\n先来看优化前打包速度\r\n大的第三方库大概有vue+axios+vueRouter+vuex+elementUI(datepicker, message两个插件)+jquery\r\n打包总体积为2648k, 一共14个chunk(使用了异步路由)\r\n![image](https://user-images.githubusercontent.com/13031838/35665400-19f380fc-0761-11e8-944b-85a5117364c2.png)\r\n\r\n在我本地打包一次需要31s\r\n\r\n![image](https://user-images.githubusercontent.com/13031838/35664714-26a6075a-075e-11e8-8df9-1cde8b4f1878.png)\r\n\r\n而在服务器打包时候则要70s以上, 这里就不贴图了. \r\n\r\n## 优化后\r\n\r\n优化后时间\r\n打包总体积上升为2700k, 上升了50k\r\n\r\n![image](https://user-images.githubusercontent.com/13031838/35665453-3ce893ea-0761-11e8-8d79-2c8b3555acb5.png)\r\n\r\n本地打包18s\r\n\r\n![image](https://user-images.githubusercontent.com/13031838/35664879-c88ec336-075e-11e8-88c0-a61590c97cad.png)\r\n\r\n服务器打包时间40s\r\n\r\n![image](https://user-images.githubusercontent.com/13031838/35664898-d966d888-075e-11e8-8e6b-70b4043afe8b.png)\r\n\r\n\r\n**提升很明显有没有**\r\n\r\n## 修改了哪些地方 ?\r\n\r\n### UglifePlugin\r\n主要修改地方还是在UglifyPlugin配置中\r\n由于我是用的并不是webpack自带的,而是独立的[uglifyjs-webpack-plugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin)\r\n\r\n其实官方使用的也是这个插件. 只不过官方使用的暂且不是最新版,而webpack4.0-beta已经使用此插件最新版本\r\n\r\n用法很简单\r\n```javascript\r\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')\r\n\r\nmodule.exports = {\r\n  plugins: [\r\n    new UglifyJsPlugin()\r\n  ]\r\n}\r\n```\r\n如果使用默认配置,那么打包速度并不会有提升.\r\n\r\n而且uglifyplugin在打包过程中其实也会进行一些压缩优化,比如内敛静态变量等等.\r\n\r\n那么我们可以从这里面入手,去除一切不必要的压缩优化.可以提升压缩速度.\r\n\r\n同时.我们需要开启parallel和cache选项,对压缩进行缓存和多线程执行\r\n\r\n具体配置规则请参考官方文档[UglifyOptions](https://github.com/mishoo/UglifyJS2/tree/harmony#minify-options)\r\n\r\n我的最终配置如下\r\n```javascript\r\n    new UglifyEsPlugin({\r\n            parallel: true,\r\n            cache: true,\r\n            sourceMap: true,\r\n            uglifyOptions: {\r\n                ecma: 8,\r\n                // 详细规则\r\n                // https://github.com/mishoo/UglifyJS2/tree/harmony#minify-options\r\n                compress: {\r\n                    // 在UglifyJs删除没有用到的代码时不输出警告\r\n                    warnings: false,\r\n                    // 删除所有的 `console` 语句\r\n                    drop_console: true,\r\n                    // 将()=>{return x} 转成 ()=>x\r\n                    // 关闭.eslint有做检查\r\n                    arrows: false,\r\n                    // 转换类似!!a ? b : c → a ? b : c\r\n                    // 关闭.eslint做检查\r\n                    booleans: false,\r\n                    // 转换由计算得来的属性名 {[\"computed\"]: 1} is converted to {computed: 1}.\r\n                    // 关闭,eslint做检查\r\n                    computed_props: false,\r\n                    // 自动转换判断\r\n                    // e.g. a = !b && !c && !d && !e → a=!(b||c||d||e) etc.\r\n                    // 关闭,请自行做规范\r\n                    comparisons: false,\r\n                    // 去掉死代码\r\n                    // 关闭.eslint做检查\r\n                    dead_code: false,\r\n                    // 关闭debugger\r\n                    // eslint做检查\r\n                    drop_debugger: false,\r\n                    // 自动进行静态算术计算\r\n                    // 开启\r\n                    evaluate: true,\r\n                    // 函数声明提升\r\n                    // 默认就是关闭,不需要开启\r\n                    hoist_funs: false,\r\n                    // For example: var o={p:1, q:2}; f(o.p, o.q); is converted to f(1, 2);\r\n                    // 不需要咯\r\n                    hoist_props: false,\r\n                    // 变量提升\r\n                    // 不需要咯\r\n                    hoist_vars: false,\r\n                    //  optimizations for if/return and if/continue\r\n                    // 不需要, eslint做检查\r\n                    if_return: false,\r\n                    /**\r\n                     * 无法用言语表达,自行理解\r\n                     * inline (default: true) -- inline calls to function with simple/return statement:\r\n                        false -- same as 0\r\n                        0 -- disabled inlining\r\n                        1 -- inline simple functions\r\n                        2 -- inline functions with arguments\r\n                        3 -- inline functions with arguments and variables\r\n                        true -- same as 3\r\n                     */\r\n                    inline: false,\r\n                    // join consecutive var statements\r\n                    // 就是将变量声明合并到一个var中\r\n                    // 关闭, eslin做检查\r\n                    join_vars: false,\r\n                    // 自动去除无用的function参数\r\n                    // 关闭. eslint做检查\r\n                    keep_fargs: false,\r\n                    //  Pass true to prevent Infinity from being compressed into 1/0\r\n                    // 禁止将infinity转成1/0\r\n                    keep_infinity: true,\r\n                    // optimizations for do, while and for loops when we can statically determine the condition.\r\n                    // 优化循环\r\n                    // 此处关闭,应该由开发者自行优化\r\n                    loops: false,\r\n                    // negate \"Immediately-Called Function Expressions\" where the return value is discarded, to avoid the parens that the code generator would insert.\r\n                    // 自行体会\r\n                    negate_iife: true,\r\n                    //  rewrite property access using the dot notation, for example foo[\"bar\"] → foo.bar\r\n                    // 关闭.eslint检查\r\n                    properties: false,\r\n                    // 将只用到一次的function,通过inline方式插入\r\n                    // 关闭.开发者自行把控\r\n                    reduce_funcs: false,\r\n                    // 将静态变量直接lnline紧代码里\r\n                    // 可以开启\r\n                    reduce_vars: true,\r\n                    // 使用逗号运算符连接连续的简单语句\r\n                    // 自行把控\r\n                    sequences: false,\r\n                    /**\r\n                     *  Pass false to disable potentially dropping functions marked as \"pure\". \r\n                     * A function call is marked as \"pure\" if a comment annotation \\/*@__PURE__*\\/ or \\/*#__PURE__*\\/ immediately precedes the call. \r\n                     * For example: \\/*@__PURE__*\\/foo();\r\n                     * 就是关闭标注纯函数的注释了\r\n                     */\r\n                    side_effects: false,\r\n                    // 去掉重复和无法到达的switch分支\r\n                    // eslint做检查, 以及开发者把控\r\n                    switches: false,\r\n                    // Transforms typeof foo == \"undefined\" into foo === void 0\r\n                    typeofs: false,\r\n                }\r\n            }\r\n```\r\n\r\n其实很多优化点都是可以通过eslint来检查,而不需要在压缩过程检查\r\n\r\n再配合自身的开发习惯以及规范,可以去掉很多压缩检查, 压缩效率就能提升\r\n\r\n但是带来的负面影响就是压缩体积会有上升/\r\n\r\n因为对于第三方库来说,并不会安装项目配置的eslint来跑.自然就达不到要求.\r\n\r\n再少了uglifyplugin的压缩优化,体积就会上升.\r\n\r\n以我的例子来看,总体积上升了50k. 尚可以接受.\r\n\r\n而打包时间足足提升了30s. \r\n\r\n但可能也有人说上线打包不必在乎打包时间.\r\n\r\n其实这些都看具体业务需求,以及自身的开发规范来配置.\r\n\r\n重要的还是在打包速度和打包体积两者中找出一个最合适的平衡点\r\n\r\n### .babelrc\r\n其实babel并不会影响到打包速度.我也只是顺便提下\r\n\r\n我的配置如下\r\n```javascript\r\n{\r\n    \"plugins\": [\r\n        [\r\n            \"component\",\r\n            [{\r\n                \"libraryName\": \"element-ui\",\r\n                \"styleLibraryName\": \"theme-default\"\r\n            }]]\r\n    ],\r\n    \"comments\": false,\r\n    \"env\": {\r\n        \"development\": {\r\n            \"plugins\": [\"transform-object-rest-spread\", \"syntax-dynamic-import\"]\r\n        },\r\n        \"production\": {\r\n            \"presets\": [[\"es2015\", {\"modules\": false}], \"stage-2\"],\r\n            \"plugins\": [\"transform-runtime\"]\r\n        },\r\n        \"test\": {\r\n            \"presets\": [\"env\", \"stage-2\"],\r\n            \"plugins\": [\"transform-runtime\", \"istanbul\"]\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n我把babel配置区分成了三个阶段,开发,生产和测试.\r\n\r\n在开发过程不使用preset,直接跑原生代码. \r\n\r\n在生产环境则使用es2015的preset\r\n\r\n也许这样能提高开发环境的编译速度? 暂时不清楚,因为没感觉.一向很快.\r\n\r\n这也看个人喜好了.\r\n\r\n\r\n## ps\r\neslint的作用真的很大很大.\r\n\r\n但是在开发阶段使用eslint真的很烦很烦.\r\n\r\n所以,我目前的做法就是在开发阶段关闭eslint检查.因为我的vscode有带插件提示\r\n\r\n即便检查到有错误,也可以正常编译.\r\n\r\n但是在commit的时候添加了一层pre-commit来对修改的文件执行eslint.\r\n\r\n这样就确保上传到git的代码是经过eslint检查的\r\n\r\n这样既能确保开发不被干扰,也能确保代码能按照规范.\r\n\r\n\r\n"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/5","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/5/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/5/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/5/events","html_url":"https://github.com/zWingz/my-blog-config/issues/5","id":292217983,"node_id":"MDU6SXNzdWUyOTIyMTc5ODM=","number":5,"title":"烹饪和烘焙的点滴","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211211,"node_id":"MDU6TGFiZWw4MTkyMTEyMTE=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/%E7%83%98%E7%84%99","name":"烘焙","color":"fcd5b0","default":false},{"id":819211260,"node_id":"MDU6TGFiZWw4MTkyMTEyNjA=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/%E7%94%9F%E6%B4%BB","name":"生活","color":"95ed9b","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-01-28T16:34:04Z","updated_at":"2018-01-28T16:40:10Z","closed_at":null,"author_association":"OWNER","body":"突然想写些什么..\r\n那就写下这周做了什么吃的..\r\n除了晚餐之外.\r\n这周做了特别的可能就是**炸薯条**, **火烧云**以及**芒果千层**了.\r\n下面就大概回忆下过程\r\n\r\n##  炸薯条\r\n  其实炸薯条本不是本人的意思, 只是女友说突然想吃薯条, 就在买菜的时候买多了一个土豆.\r\n  由于不是本人的意思,过程也只是大概记得.\r\n- 土豆去皮, 切成条\r\n- 用保鲜袋装好,放冰箱冷冻(其实嘛.我也不知道这一步是不是必须,也可能是那晚我们吃得饱,所以才放冰箱,留到下次弄得)\r\n- 先把薯条煮一边,放盐, 软了后捞出\r\n- 倒掉水, 并擦干平底锅\r\n- 放油,(新买的一瓶油我放了三分一)\r\n- 油热了之后把薯条放进去炸就ok了..\r\n- 炸完捞出可以再撒些盐. 然后放置一阵子就能吃了\r\n\r\n其实一开始全程都是女友在弄.只不过她炸的时候油放的太少了..然后跑过来跟我说像是在炒薯条..\r\n于是乎我就自己上了..其实这也是我第一次炸薯条.\r\n炸完之后油也只能倒掉.感觉很浪费.炸一个土豆用了1/3瓶油..\r\n感觉以后都不会再炸东西了.除非量大. 这里就没图了.很简单的\r\n\r\n\r\n## 火烧云\r\n  这个其实我上星期就有做过了.只不过做失败了.\r\n  其实就是面包再加工一下啦, 外表看起来逼格挺高. 吃起来也还ok\r\n\r\n- 材料(鸡蛋两个, 吐司(方包)4片, 炼奶, 沙拉酱)\r\n- 蛋清分离, 用蛋清分离器分离, 将蛋清倒入无水碗中, 然后将蛋黄放另外一个碗(两个鸡蛋的蛋清可以放于同一个碗中, 蛋黄必须放于两个不同的碗, 同时蛋黄一定不能破, 一旦破了混入到了蛋清中,就不容易打发蛋清了, 上周失败就是因为分离的时候蛋黄破了, 导致打发失败)\r\n- 将蛋清倒入打蛋盆中, 加入一勺糖(根据自己喜好添加), 使用电动打蛋器进行打发, 当出现纹路的时候, 再加入一勺糖, 继续打发, 当感觉打发出现阻力时候, 继续加入一勺糖, 继续打发. 直到达到硬性打发程度, 就是打蛋器提起来, 蛋清不会掉下来, 就像我们平常吃的奶油一样. 整个步骤一定不能有水, 有水就不容易打发了. 砂糖除了调味, 还能促进打发\r\n- 此时我们有的东西就是打发了的蛋清,以及两个蛋黄\r\n- 取一片吐司, 涂上一层炼奶, 再涂上一层沙拉酱(也可以是其他,也可以不要,看个人), 再取一片方包, 盖在上面.\r\n- 用刮刀将打发的蛋清涂到上一步中的吐司上方, 一共取一般的蛋清, 并对其进行造型, 弄成你觉得好看的样子.\r\n- 在蛋清中间挖个孔, 将蛋黄倒进去, 此时已经完成一个火烧云了.\r\n- 另一个就根据上述步骤一样就行\r\n- 烤箱150度预热5分钟\r\n- 将面包放入烤箱15分钟即可\r\n- 这时候的蛋黄其实是溏心蛋, 我个人是很喜欢\r\n\r\n就是由于上周失败了, 并且找到原因, 所以这周就铁了心要把它完成. 当然这里肯定有图了\r\n+ 这是入烤箱前\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-1-29/645802.jpg)\r\n\r\n+ 烤完后\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-1-29/84359394.jpg)\r\n味道还是不错的, 也挺简单.\r\n\r\n##  芒果千层\r\n\r\n做这个芒果千层, 耗时3小时, 也是不容易啊\r\n这里先上图, 之后再补充制作过程\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-1-29/38760413.jpg)\r\n\r\n\r\n## 其他\r\n\r\n其实烤箱双十一就购入了, 同时也购入了一批烘焙工具,从此入了烘焙的坑,\r\n不入不知道, 一入深似海\r\n这里就顺便贴下图吧.过程就先忽略了\r\n\r\n\r\n- 鸡蛋布丁\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-1-29/42554020.jpg)\r\n\r\n\r\n\r\n- 西多士\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-1-29/69072942.jpg)\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-1-29/52839589.jpg)\r\n\r\n\r\n- 蛋挞\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-1-29/59916873.jpg)\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-1-29/70796582.jpg)\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-1-29/48233877.jpg)\r\n\r\n\r\n\r\n- 风琴土豆\r\n![](http://ol1hthxqp.bkt.clouddn.com/18-1-29/33495732.jpg)\r\n\r\n"},{"url":"https://api.github.com/repos/zWingz/my-blog-config/issues/2","repository_url":"https://api.github.com/repos/zWingz/my-blog-config","labels_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/2/labels{/name}","comments_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/2/comments","events_url":"https://api.github.com/repos/zWingz/my-blog-config/issues/2/events","html_url":"https://github.com/zWingz/my-blog-config/issues/2","id":275254986,"node_id":"MDU6SXNzdWUyNzUyNTQ5ODY=","number":2,"title":"vue后台系统开发实践","user":{"login":"zWingz","id":13031838,"node_id":"MDQ6VXNlcjEzMDMxODM4","avatar_url":"https://avatars1.githubusercontent.com/u/13031838?v=4","gravatar_id":"","url":"https://api.github.com/users/zWingz","html_url":"https://github.com/zWingz","followers_url":"https://api.github.com/users/zWingz/followers","following_url":"https://api.github.com/users/zWingz/following{/other_user}","gists_url":"https://api.github.com/users/zWingz/gists{/gist_id}","starred_url":"https://api.github.com/users/zWingz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/zWingz/subscriptions","organizations_url":"https://api.github.com/users/zWingz/orgs","repos_url":"https://api.github.com/users/zWingz/repos","events_url":"https://api.github.com/users/zWingz/events{/privacy}","received_events_url":"https://api.github.com/users/zWingz/received_events","type":"User","site_admin":false},"labels":[{"id":819211154,"node_id":"MDU6TGFiZWw4MTkyMTExNTQ=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/front-end","name":"front-end","color":"92efc8","default":false},{"id":819211023,"node_id":"MDU6TGFiZWw4MTkyMTEwMjM=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/js","name":"js","color":"c5def5","default":false},{"id":819211105,"node_id":"MDU6TGFiZWw4MTkyMTExMDU=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/vue","name":"vue","color":"dd4970","default":false},{"id":819211088,"node_id":"MDU6TGFiZWw4MTkyMTEwODg=","url":"https://api.github.com/repos/zWingz/my-blog-config/labels/webpack","name":"webpack","color":"1faf32","default":false}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-11-20T07:02:07Z","updated_at":"2018-08-02T10:20:37Z","closed_at":null,"author_association":"OWNER","body":"## Vue后台系统开发实践\r\n\r\n### 依赖库\r\n\r\n- vue@2.4.4\r\n- vue-router@3.0.0\r\n- vuex@3.0.0\r\n- axios\r\n- element-ui\r\n\r\n### 搭建流程\r\n1. [webpack-template](https://github.com/zWingz/vue-webpack-template)\r\n\r\n2. createApp.js, createRouter.js, store.js, http.js\r\n    + createaApp.js 多页时候用来配置各个页面相同的vue选项,比如配置api,mixin等等\r\n    + createRouter.js 多页时候用到配置各个页面相同的路由选项,比如配置路由模式,路由钩子等等\r\n    + store.js 配置全局状态管理.state,action,mutation,getter\r\n    + http.js 配置异步请求, 例如: baseRoot, 请求钩子interceptors\r\n3. utils.js, ConstValue.js, mixin.js, registerComponent.js\r\n    + utils.js 工具类函数\r\n    + ConstValue.js 常量,例如: isProduction, httpRoot(后端地址)\r\n    + mixin.js 混合\r\n    + registerComponent.js 将经常用到的组件在这里引入并注册为全局组件\r\n4. route.js, app.js\r\n    + route/.js 具体的路由\r\n    + app.js 每个页面的app启动页\r\n5. page-view&components\r\n    + 页面级内容\r\n\r\n\r\n### 后台大致内容\r\n\r\n+ 登录/权限\r\n+ 列表页\r\n+ 详情/审核页\r\n+ 创建/修改页\r\n\r\n### 问题分析\r\n+ 登录/权限\r\n    + 登录态的保存.以及用户权限的判断\r\n        1. 后端设置sessionid, 前端只需要在axios配置withCredentials=true.(此方法在Safari行不通,safari默认选项(仅)允许来自我访问的网站, 由于后端地址不是直接访问.所以safari不会带上cookie去请求.部署的时候将前后端都部署到同一个nginx就可以解决)\r\n        2. json web token(jwt)\r\n        3. 后端生成token,并由保存在http header.\r\n        4. 权限判断一种是导航显示控制,一种是直接通过url进去后的判断\r\n\r\n+ 列表页\r\n    + 内容过多.会引起页面滚动.表头以及两侧需固定\r\n        1. 全局滚动.(表格过大.页面整体会被撑开)\r\n        2. 容器内滚动.(表格显得很狭窄)\r\n        3. 垂直方向全局滚动, 水平方向是局部滚动. (页面宽度不被撑开, 加虚拟滚动条辅助时候水平滚动不需要拉到最后)\r\n        4. [Demo](https://zwingz.github.io/vue-fixed-table/release/demo.html)\r\n\r\n    + 有很多的查询条件\r\n        + 查询需要被保留,同时url需要被查询条件修改(`$router.replace`)\r\n\r\n    + 每一个列表页类似.但又有不同,主要差异在于查询条件以及表格内容\r\n        + 使用mixin\r\n        + 设置查询query\r\n        + 根据query以及url获取数据\r\n        + 对数据进行处理,比如: loading态设为false, 初始化多选等. 看具体\r\n\r\n    + 列表页/详情页切换后列表数据的保存(保留列表页状态)\r\n        + vuex(全局状态管理, 写起来会很多,一个页面一个state,action,mutation,getters)\r\n        + keepAlive(active/mounted获取数据, active会导致数据次数过多, mounted会导致数据不同步. 此时可以使用trigger,主动触发列表页拉取数据)\r\n\r\n+ 详情页/审核页\r\n    + 数据展示形式类似. 形如: label: content;\r\n        + 声明式会导致页面重复内容过多\r\n        + 封装Field组件,通过js去配置数据展示\r\n\r\n    + 布局类似\r\n        + 这是无解的,除非真的很像很像.就可以用mixin解决\r\n\r\n+ 创建/修改页\r\n    + 数据形式类似. 形如: label: form\r\n        + 声明式同样导致重复内容过多\r\n        + 依然使用封装的Field组件,通过js去配置form.\r\n\r\n    + 数据验证. 简单点就是能否提交\r\n        + 要么逐个验证\r\n        + 要么简单粗暴添加一个canSave的computed.保证数据不为空\r\n\r\n### 组件\r\n+ Table(如上所说) [Demo](https://zwingz.github.io/vue-fixed-table/release/demo.html)\r\n+ LoadingBar(顶部的进度条,主要是切换路由时候出现,挂在beforeEach和afterEach中调用, 有异步路由时候建议使用)\r\n+ Message(消息提示)\r\n\r\n    #### 实现方式\r\n        1. 使用createElement创建dom元素,并且把message组件挂载上去即可,不过需要使用到vue完整版\r\n        2. 将组件挂在到App.vue中,并使用vuex管理其状态. 可以在初次调用message时候才注册store\r\n+ Modal 没什么好说.哪里用到就声明一个Modal.\r\n+ Confirm(确认式提升,与message一样的实现方式)\r\n+ AsyncButton(会触发异步操作的按钮,监听异步请求的路由,当请求未结束时button处于loading态.)\r\n+ AutoCompleteInput(带搜索建议的Input. 可以封装多装搜索框)\r\n+ Panel (可收缩面包.很简单)\r\n+ Field (label: content\\form; 类型展示组件)\r\n+ Pagination (分页,很简单)\r\n+ Tree (树, 使用递归组件即可, 如果要做节点多选, 管理选择状态会比较麻烦.)\r\n+ Select, Checkbox, Radio, Switch (自定义组件v-model即可,简单)\r\n+ Spin (请求时间很长的时候, 可以弹出model,并构建一个假的进度条. 上传文件的时候也能用到,当然这时候的进度是真实的.通过onprogress获取)\r\n+ BackToTop (回到顶部, 加个贝塞尔动画就好了)\r\n+ Scroller (自定义非原生滚动条, 建议直接用css来设置原生scroll样式.目前应该firefox不支持设置原生滚动条样式)\r\n+ Img (hover时候出现蒙层.点击时候出现查看器)\r\n\r\n### 建议\r\n1. 如果对组件进行for命令,必须加上:key,这是官方指定.\r\n    但对于原生dom进行for循环时候.其实可以不加:key,或者使用index作为key. \r\n    一旦设置了key,只有key得值不一样,会直接销毁重建dom. 那么用index作为key的话,则只会更新dom而不会销毁重建\r\n\r\n2.  任何通过addEventListeners添加的监听事件,销毁时最好使用removeEventListeners给去掉\r\n3. 如果不需要运行时构建,可以在webpack中指定使用vue.runtime.js, 会剩了几十k体积\r\n\r\n4. sass-loader前再加一层sass-resources-loader可以将一些变量或者方法全局引入,那就不用到处import了.\r\n    \r\n```javascrit\r\n    {\r\n        loader: 'sass-resources-loader',\r\n        options: {\r\n            resources: [path.resolve(__dirname, '../src/sass/variable.scss')]\r\n        }\r\n    }\r\n```\r\n\r\n### 安利\r\n[Fundebug](https://fundebug.com/)\r\n\r\n[EasyMock](https://www.easy-mock.com/)\r\n\r\n[Apizza](http://apizza.cc/account)\r\n\r\n# **全剧终**\r\n"}]