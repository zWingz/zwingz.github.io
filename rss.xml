<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[zWing]]></title><description><![CDATA[Just a blog.]]></description><link>http://zwingz.github.io</link><image><url>http://zwingz.github.io/favicon.ico</url><title>zWing</title><link>http://zwingz.github.io</link></image><generator>RSS for Node</generator><lastBuildDate>Thu, 24 Jan 2019 02:33:20 GMT</lastBuildDate><atom:link href="http://zwingz.github.io/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 24 Jan 2019 02:33:20 GMT</pubDate><webMaster><![CDATA[zWingz]]></webMaster><item><title><![CDATA[使用jest+enzyme测试react组件]]></title><description><![CDATA[
            <h2>
              <a href="#前言" id="前言" class="heading"></a>前言
            </h2>
          <p>最近第一次给一个项目写一个完整的测试流程, 也算是我第一次写完整的测试.
于是记一下整个测试流程
<a href="https://github.com/zWingz/react-image">项目地址</a>
目前项目使用的测试框架是主流的<code>jest</code>+<code>enzyme</code></p>

            <h2>
              <a href="#依赖" id="依赖" class="heading"></a>依赖
            </h2>
          
            <h3>
              <a href="#必要依赖" id="必要依赖" class="heading"></a>必要依赖
            </h3>
          <ul>
<li>Jest</li>
<li>enzyme</li>
<li>enzyme-adapter-react-16</li>
</ul>

            <h3>
              <a href="#按需" id="按需" class="heading"></a>按需
            </h3>
          <ul>
<li>如果使用<code>babel</code>，则需要<code>babel-jest</code></li>
<li>如果使用<code>typescript</code>， 则需要<code>ts-jest</code></li>
</ul>

            <h2>
              <a href="#Jest 配置" id="Jest 配置" class="heading"></a>Jest 配置
            </h2>
          <p>起初项目使用<code>babel</code>进行编译，后面统一转成了<code>ts</code></p>

      <div class="hljs json">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-string">"jest"</span>: {
    <span class="hljs-string">"moduleNameMapper"</span>: {
      <span class="hljs-string">"\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|scss)$"</span>:<span class="hljs-string">"&lt;rootDir&gt;/test/utils.ts"</span>
    },
    <span class="hljs-string">"moduleFileExtensions"</span>: [
      <span class="hljs-string">"ts"</span>,
      <span class="hljs-string">"tsx"</span>,
      <span class="hljs-string">"js"</span>
    ],
    <span class="hljs-string">"setupTestFrameworkScriptFile"</span>: <span class="hljs-string">"&lt;rootDir&gt;/test/setup.ts"</span>,
    <span class="hljs-string">"collectCoverageFrom"</span>: [
      <span class="hljs-string">"src/**/*.{ts,tsx}"</span>
    ],
    <span class="hljs-string">"coverageDirectory"</span>: <span class="hljs-string">"./coverage/"</span>,
    <span class="hljs-string">"collectCoverage"</span>: true,
    <span class="hljs-string">"transform"</span>: {
      <span class="hljs-string">"^.+\\.(ts|tsx)$"</span>: <span class="hljs-string">"ts-jest"</span>
    },
    <span class="hljs-string">"testMatch"</span>: [
      <span class="hljs-string">"**/__test__/*.(ts|tsx)"</span>
    ]
  }</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>如果使用<code>babel</code>的话, 只要将<code>ts</code>转成<code>js</code>, <code>ts-jest</code>转成<code>babel-jest</code>即可。</p>

            <h4>
              <a href="#moduleNameMapper" id="moduleNameMapper" class="heading"></a>moduleNameMapper
            </h4>
          <p>用来<code>mock</code>一些额外<code>module</code>, 比如<code>sass</code>, <code>jpg</code>等等.</p>

      <div class="hljs typescript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-comment">// /test/utils.ts</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = <span class="hljs-string">'test-file-stub'</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h4>
              <a href="#setupTestFrameworkScriptFile" id="setupTestFrameworkScriptFile" class="heading"></a>setupTestFrameworkScriptFile
            </h4>
          <blockquote>
<p>The path to a module that runs some code to configure or set up the testing framework before each test. </p>
</blockquote>
<p>可以用来初始化<code>test</code>配置, 在这里需要使用<code>enzyme-adapter</code></p>

      <div class="hljs typescript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-comment">// /test/setup.ts</span>
<span class="hljs-keyword">import</span> { configure } <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactSixteenAdapter <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme-adapter-react-16'</span>

configure({ <span class="hljs-attr">adapter</span>: <span class="hljs-keyword">new</span> ReactSixteenAdapter() })
</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h4>
              <a href="#collectCoverageFrom" id="collectCoverageFrom" class="heading"></a>collectCoverageFrom
            </h4>
          <p>需要测试覆盖率的文件</p>

            <h4>
              <a href="#coverageDirectory" id="coverageDirectory" class="heading"></a>coverageDirectory
            </h4>
          <p>覆盖率输出目录</p>

            <h4>
              <a href="#transform" id="transform" class="heading"></a>transform
            </h4>
          <blockquote>
<p>A map from regular expressions to paths to transformers. A transformer is a module that provides a synchronous function for transforming source files</p>
</blockquote>
<p>跟<code>webpack-loader</code>类似</p>

            <h3>
              <a href="#testMatch" id="testMatch" class="heading"></a>testMatch
            </h3>
          <blockquote>
<p>The glob patterns Jest uses to detect test files.</p>
</blockquote>
<p>测试文件匹配规则, 如果跟官方不同, 则修改此值.</p>

            <h2>
              <a href="#Enzyme 使用" id="Enzyme 使用" class="heading"></a>Enzyme 使用
            </h2>
          <p><a href="https://airbnb.io/enzyme/">官方文档</a></p>

            <h3>
              <a href="#简单介绍" id="简单介绍" class="heading"></a>简单介绍
            </h3>
          <p>其实<code>enzyme</code>上手挺简单的, 它有三个<code>API</code></p>
<p>包括<code>shallow</code>、<code>mount</code>和<code>render</code>, 其中<code>shallow</code>和<code>mount</code>是常用的</p>
<p>他们区别是</p>
<ul>
<li><code>shallow</code>: 只会渲染顶级组件, 而子组件不会渲染, 渲染结果是一颗<code>react</code>树, 效率最高</li>
<li><code>mount</code>: 会渲染整个组件, 包括子组件, 如果需要深入组件内部测试, 则需要使用<code>mount</code></li>
<li><code>render</code>: 直接选择普通的<code>html</code>结构.</li>
</ul>
<p><code>shallow</code>和<code>mount</code>得到结果是一个<code>ReactWrapper</code>对象, 可以进行多种操作, 包括<code>find()</code>、<code>prop()</code>、<code>instance()</code>等。</p>

            <h3>
              <a href="#基本使用" id="基本使用" class="heading"></a>基本使用
            </h3>
          
      <div class="hljs typescript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { shallow, mount } <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme'</span>
<span class="hljs-keyword">import</span> MyComponent <span class="hljs-keyword">from</span> <span class="hljs-string">'../MyComponent'</span>
<span class="hljs-keyword">import</span> ChildComponent <span class="hljs-keyword">from</span> <span class="hljs-string">'../ChildComponent'</span>

describt(<span class="hljs-string">'测试xxxxx'</span>, () =&gt; {
    it(<span class="hljs-string">'组件state以及渲染情况'</span>, () =&gt; {
        const <span class="hljs-keyword">wrapper</span> = shallow(&lt;MyComponent /&gt;)
        expect(<span class="hljs-keyword">wrapper</span>.state().msg).toEqual(<span class="hljs-string">'test msg'</span>)
        expect(<span class="hljs-keyword">wrapper</span>.find(<span class="hljs-string">'#childId'</span>)).toHaveLength(<span class="hljs-number">1</span>) // 测试是否包含某个`element`
        expect(<span class="hljs-keyword">wrapper</span>.find(ChildComponent)).toHaveLength(<span class="hljs-number">1</span>) // 测试是否包含某个子组件
    })
    it(<span class="hljs-string">'触发事件'</span>, () =&gt; {
        const click = jest.fn()
        const <span class="hljs-keyword">wrapper</span> = shallow(&lt;MyComponent onClick={click}/&gt;)
        // 触发#triggerClickElement的click事件
        <span class="hljs-keyword">wrapper</span>.find(<span class="hljs-string">'#triggerClickElement'</span>).simulate(<span class="hljs-string">'click'</span>)
        // 判断click事件是否被触发
        expect(click).toBeCalledTimes(<span class="hljs-number">1</span>)
    })
    // 测试函数调用
    // 默认该函数声明方式通过<span class="hljs-keyword">class</span>.<span class="hljs-keyword">method</span>声明
    // <span class="hljs-keyword">class</span> MyComponent{
    //   someMethod() {} 
    // }
    it(<span class="hljs-string">'测试函数调用'</span>, () =&gt; {
        const spy = jest.spyOn(MyComponent.prototype, <span class="hljs-string">'someMethod'</span>)
        const <span class="hljs-keyword">wrapper</span> = shallow(&lt;MyComponent /&gt;)
        // 暂且认为组件挂载时会调用`someMethod`
        // 在此测试是否正确调用
        expect(spy).toBeCalledTimes(<span class="hljs-number">1</span>)
    })
    // 但是由于react需要绑定this
    // 所以一般会这样声明
    // <span class="hljs-keyword">class</span> MyComponent {
    //   someMethod = () =&gt; {}    
    // }
    // 这时候通过babel或者typescript编译后
    // 会变成类似
    // <span class="hljs-keyword">class</span> MyComponent{
    //   constructor() {
    //     this.someMethod = () =&gt; {}     
    //   }    
    // }
    // 这时候someMethod不属于MyComponent.prototype
    // 所以要改变测试方式
    it(<span class="hljs-string">'测试函数调用'</span>, () =&gt; {
        const <span class="hljs-keyword">wrapper</span> = shallow(&lt;MyComponent /&gt;)
        const ins = <span class="hljs-keyword">wrapper</span>.instance()
        const spy = jest.spyOn(ins, <span class="hljs-string">'someMethod'</span>)
        <span class="hljs-keyword">wrapper</span>.<span class="hljs-keyword">update</span>()
          ins.forceUpdate()
        expect(spy).toBeCalledTimes(<span class="hljs-number">1</span>)
    })
    it(<span class="hljs-string">'触发特定事件, 并传递参数'</span>, () =&gt; {
        // 如果要触发特定事件, 比如mousemove, keyup等等
        // 可以通过构造自定义事件, 并且使用dispatchEvent来触发
        const <span class="hljs-keyword">wrapper</span> = shallow(&lt;MyComponent /&gt;)
        const element = <span class="hljs-keyword">wrapper</span>.find(<span class="hljs-string">'.some-element'</span>)
        const event = <span class="hljs-built_in">new</span> MouseEvent(<span class="hljs-string">'mousemove'</span>, {
            clientX: <span class="hljs-number">100</span>,
            clientY: <span class="hljs-number">100</span>
        })
        element.getDOMNode().dispatchEvent(event)
        expect(<span class="hljs-keyword">wrapper</span>.state.x).toEqueal(<span class="hljs-number">100</span>)
    })
})</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>其实<code>enzyme</code>常用的api大概就是几个, 按照本项目中用到的, </p>
<ul>
<li>state</li>
<li>find</li>
<li>prop</li>
<li>simulate</li>
</ul>

            <h2>
              <a href="#进行测试" id="进行测试" class="heading"></a>进行测试
            </h2>
          <p>编写完<code>test case</code>后, 只要调用<code>jest</code>即可进行测试, 同时会输出覆盖率
如果带上<code>--watch</code>则可以监听文件改动并进行测试</p>

            <h2>
              <a href="#上传测试覆盖率" id="上传测试覆盖率" class="heading"></a>上传测试覆盖率
            </h2>
          <p>目前使用<code>Codecov</code>来管理测试覆盖率
如果在本地上传, 则需要带上<code>token</code>, 如果通过<code>travisCi</code>, 则不需要, 直接调用<code>codecov</code>即可。</p>

            <h2>
              <a href="#完结" id="完结" class="heading"></a>完结
            </h2>
          <p>至此， 整套<code>jest</code>+<code>enzyme</code>测试流程已经跑完.
目前看来没有用高更深的测试功能, 比如说<code>jsdom</code>, <code>enzyme.render</code>等</p>
]]></description><link>http://zwingz.github.io/posts/383783892.html</link><guid isPermaLink="false">383783892</guid><category><![CDATA[front-end]]></category><category><![CDATA[react]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Fri, 23 Nov 2018 11:07:18 GMT</pubDate></item><item><title><![CDATA[多package下babel编译问题]]></title><description><![CDATA[
            <h2>
              <a href="#项目背景" id="项目背景" class="heading"></a>项目背景
            </h2>
          <p>之前一直使用<code>typescript</code> + <code>babel</code> 编译项目</p>
<p><code>typescript</code>作用只是单纯用来做强类型检查, <code>babel</code>则真正用来编译代码.</p>

      <div class="hljs json">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
</pre>
              </td>
              <td class="code"><pre>  {
     <span class="hljs-attr">"target"</span>: <span class="hljs-string">"exnext"</span>
  }</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>偶然一次机会, 发现编译后的部分代码并没有编译<code>object-rest-spread</code>
而这部分代码全都在一个子目录下</p>
<p>由于我的项目使用了<code>git-submodules</code>来管理组件, 所以该组件目录下带有<code>package.json</code>文件</p>
<p>恰好这部分文件只经过了<code>typescript</code>的编译, 而没有经过<code>babel</code></p>
<p>其他<code>Page</code>都正确的被<code>babel</code>编译, 不存在问题.</p>
<p>于是想起是否子目录下的文件不被<code>babel</code>编译, 看了下官方文档, 的确有相关的描述.</p>

            <h2>
              <a href="#问题原因" id="问题原因" class="heading"></a>问题原因
            </h2>
          <p>当项目目录中含有多个<code>package.json</code>时候, 原有的<code>.babelrc</code>已经不再适用</p>
<p><img src="https://user-images.githubusercontent.com/13031838/48480504-a09f9300-e845-11e8-9edc-3f42bb145c2f.png" alt="image">.</p>
<p>这时候经过<code>webpack</code>编译
只有<code>src</code>下的文件会被正确编译, <code>sub</code>下的文件不会被<code>babel</code>编译</p>
<p>此时<code>webpack</code>会报错</p>
<p><img src="https://user-images.githubusercontent.com/13031838/48480915-d4c78380-e846-11e8-80e5-b4bc1c518474.png" alt="image"></p>
<p>原因就是这部分文件没有被<code>babel</code>正确编译</p>

            <h2>
              <a href="#上述问题解决办法" id="上述问题解决办法" class="heading"></a>上述问题解决办法
            </h2>
          <p>官方有<a href="https://babeljs.io/docs/en/config-files#project-wide-configuration">详细说明</a></p>
<p>将<code>.babelrc</code>改成<code>babel.config.js</code>, 此时<code>sub</code>下的文件可以被正确编译</p>
<p><img src="https://user-images.githubusercontent.com/13031838/48481024-15270180-e847-11e8-909b-3af7c5a7b209.png" alt="image"></p>
<p>当然, 使用<code>babel.config.js</code>还可以灵活的配置各个<code>package</code>中<code>babel</code>编译规则.
具体的还是请看官方文档</p>
]]></description><link>http://zwingz.github.io/posts/380665113.html</link><guid isPermaLink="false">380665113</guid><category><![CDATA[babel]]></category><category><![CDATA[front-end]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Wed, 14 Nov 2018 11:56:24 GMT</pubDate></item><item><title><![CDATA[使用Fabric+docker部署前端项目]]></title><description><![CDATA[
            <h2>
              <a href="#部署过程" id="部署过程" class="heading"></a>部署过程
            </h2>
          <ul>
<li>合并<code>develop</code>到<code>master</code></li>
<li><code>push</code>代码</li>
<li>远程服务器<code>pull</code>代码</li>
<li>npm install(如果需要)</li>
<li>npm run test (如果需要)</li>
<li>npm run build</li>
</ul>

            <h2>
              <a href="#Docker配置, 使用docker+node完成编译" id="Docker配置, 使用docker+node完成编译" class="heading"></a>Docker配置, 使用docker+node完成编译
            </h2>
          <p>使用docker来部署, 则线上不需要有<code>node</code>环境.</p>

            <h3>
              <a href="#使用docker安装依赖" id="使用docker安装依赖" class="heading"></a>使用docker安装依赖
            </h3>
          <ul>
<li>将本地目录映射到<code>docker</code>中</li>
<li>在<code>docker</code>中跑<code>npm</code>命令</li>
</ul>

      <div class="hljs docker">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-meta"># docker-compose.yml</span>
<span class="hljs-symbol">version:</span> <span class="hljs-string">'3'</span>
<span class="hljs-symbol">services:</span>
<span class="hljs-symbol">  depoly:</span>
<span class="hljs-symbol">    container_name:</span> project-container
<span class="hljs-symbol">    image:</span> node:carbon
<span class="hljs-symbol">    working_dir:</span> /project
<span class="hljs-symbol">    volumes:</span>
        - .:/project</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h2>
              <a href="#Shell脚本, 更好的执行docker" id="Shell脚本, 更好的执行docker" class="heading"></a>Shell脚本, 更好的执行docker
            </h2>
          
      <div class="hljs bash">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-comment">#!/bin/bash</span>

<span class="hljs-comment"># 判断最近一次提交是否修改过package-lock, 以及node_modules是否为空</span>
<span class="hljs-comment"># 如果是, 则重新执行npm install</span>
package=$(git diff --name-only HEAD~ HEAD | grep <span class="hljs-string">"package-lock.json"</span>)

<span class="hljs-keyword">if</span> [ ! -d <span class="hljs-string">"./node_modules"</span> -o -n <span class="hljs-string">"$package"</span> ]; then
  echo -e <span class="hljs-string">"\n\033[41;37m Install dependence:\033[0m\n "</span>
  <span class="hljs-comment"># 跑docker命令</span>
  docker-compose run --rm depoly npm install
  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">"$?"</span> == <span class="hljs-number">1</span> ]]; then
    echo -e <span class="hljs-string">"\t\033[31m Error in npm install, pleace check your package.json\n\033[0m"</span>
    <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>
  fi
fi;

<span class="hljs-comment"># 执行编译</span>
echo -e <span class="hljs-string">"\n\n\033[41;37m Build... :\033[0m\n "</span>

<span class="hljs-comment"># 跑docker命令</span>
docker-compose run --rm depoly npm run build
<span class="hljs-keyword">if</span> [[ <span class="hljs-string">"$?"</span> == <span class="hljs-number">1</span> ]]; then
  echo -e <span class="hljs-string">"\t\033[31m Error in npm run build \n\033[0m"</span>
  <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">else</span>
  echo -e <span class="hljs-string">"\033[32mBuild Success \033[0m\n"</span>
fi

<span class="hljs-keyword">exit</span> $?</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h2>
              <a href="#Fabric使用, 更快的完成部署" id="Fabric使用, 更快的完成部署" class="heading"></a>Fabric使用, 更快的完成部署
            </h2>
          
            <h3>
              <a href="#fabric基本介绍" id="fabric基本介绍" class="heading"></a>fabric基本介绍
            </h3>
          <p><code>fabric</code>是一个<code>python</code>库, 可以通过<code>ssh</code>在远程服务器执行命令.</p>
<p>它有两个<code>1.0</code>和<code>2.0</code>版本, 其中<code>1.0</code>只支持<code>py2</code>, <code>2.0</code>版本可以支持<code>py2</code>和<code>py3</code>, 而且两个版本的<code>api</code>区别很大, 具体请参考官方文档.</p>
<p>以下所使用的是<code>fabric2.0</code>, 附上<a href="http://docs.fabfile.org/en/2.2/">fabric2.x文档</a></p>

            <h3>
              <a href="#用途" id="用途" class="heading"></a>用途
            </h3>
          <p>可以利用它来<code>pull</code>代码, 并执行代码编译</p>
<p>同时, 线上一般只拉<code>master</code>分支, 所以<code>fabric</code>也能帮助我们在本地合并到<code>master</code>分支后<code>push</code>到<code>git</code>上</p>

            <h3>
              <a href="#配置文件" id="配置文件" class="heading"></a>配置文件
            </h3>
          
      <div class="hljs python">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-keyword">from</span> fabric <span class="hljs-keyword">import</span> Connection
<span class="hljs-keyword">from</span> invoke <span class="hljs-keyword">import</span> task

c = Connection(host=<span class="hljs-string">'server_name'</span>)

<span class="hljs-comment"># 制定task</span>
<span class="hljs-comment"># 可以通过fab depoly 调用</span>
<span class="hljs-meta">@task</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">depoly</span><span class="hljs-params">(d)</span>:</span>
    c.local(<span class="hljs-string">'git checkout master'</span>) <span class="hljs-comment"># 切换到master</span>
    c.local(<span class="hljs-string">'git rebase develop'</span>) <span class="hljs-comment"># 合并develop分支</span>
    c.local(<span class="hljs-string">'git push origin master'</span>) <span class="hljs-comment"># push到master</span>
    <span class="hljs-keyword">with</span> c.cd(<span class="hljs-string">'/home/ubuntu/path/your_project'</span>):
        c.run(<span class="hljs-string">'git pull'</span>, pty=<span class="hljs-keyword">True</span>) <span class="hljs-comment"># 远程拉取代码</span>
        c.run(<span class="hljs-string">'./depoly.sh'</span>) <span class="hljs-comment"># 远程执行build</span>
    c.local(<span class="hljs-string">'git checkout develop'</span>) <span class="hljs-comment"># 本地切换回develop</span>
</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>执行<code>fab depoly</code>就可以完成一系列部署</p>

            <h2>
              <a href="#结语" id="结语" class="heading"></a>结语
            </h2>
          <p>上述过程其实完全可以由各种<code>CI</code>完成</p>
<p>但是对于私有<code>gitlab</code>, 同时又没有部署<code>gitlab-runner</code>或者不想接入第三方的话</p>
<p><code>fabric</code>是个不错的选择</p>
]]></description><link>http://zwingz.github.io/posts/346031510.html</link><guid isPermaLink="false">346031510</guid><category><![CDATA[depoly]]></category><category><![CDATA[front-end]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Tue, 31 Jul 2018 04:32:38 GMT</pubDate></item><item><title><![CDATA[记一下从Vue转向React的感想]]></title><description><![CDATA[
            <h1>
              <a href="#关于React, 想说几点" id="关于React, 想说几点" class="heading"></a>关于React, 想说几点
            </h1>
          <p>没有干货, 只有感想.
没有源码分析, 只有需求实现.</p>

            <h2>
              <a href="#React跟Vue对比" id="React跟Vue对比" class="heading"></a>React跟Vue对比
            </h2>
          <p>之前写过一篇<a href="https://zwing.site/posts/275254986.html">vue后台系统开发实践</a></p>
<p>那时候主要写<code>vue</code>, 有时间也会关注下<code>React</code>相关内容, 但没有实际开发经验.</p>
<p>最近终于从<code>vue</code>转向了<code>React</code></p>
<p>虽说两者都是<code>MVVM</code>框架, 都是数据驱动型, 但是两者区别还真的很明显.</p>
<p>曾经看过一段话, 大概是这么一个意思</p>
<p><code>vue</code>就是帮你封装了所有东西, 比如数据监听、指令、模板渲染等等</p>
<p>写起来就像是一门新的语言一样,你只要按照他的语法, 你就能很轻易的写出一套系统. </p>
<p>而<code>React</code>只提供了最基础的东西, 比如<code>vnode</code>, dom渲染等, 其余得都要靠自己去组合实现. 写起来就跟写原生<code>JavaScript</code>没什么区别. 可以玩出很多花样.</p>
<p>我是很赞同这个说法</p>
<p>在刚开始写<code>React</code>时候, 时不时都会带上<code>vue</code>的思想去写</p>
<p>耳边偶尔会响起一句话 &#39;怎么React这么麻烦, 我用vue一下子就能完成的东西, 在这里要写半天&#39;</p>
<p>例子? <code>Form</code>表单的双向绑定就是一个例子.</p>

            <h3>
              <a href="#初探React" id="初探React" class="heading"></a>初探React
            </h3>
          <p>刚开始写, 由于不太熟练, 就选择了<code>Antd</code>作为UI框架.</p>
<p>但其实我是不太喜欢使用第三方库的</p>
<p>在刚开始写<code>vue</code>时候, 也是选择<code>ElementUI</code>, 后面熟练之后也逐步抛弃, 改用自己实现的组件</p>
<p>除了几个特别麻烦的, 比如 <code>DataPicker</code> . 我还是选择使用第三方. </p>
<p>我也写过一个<a href="https://zwing.site/posts/295960409.html">固定表格组件</a>, 个人感觉挺良好. 666</p>
<p>那么对于<code>React</code>,  我也选择了同样的入手方式, 先从第三方库用起, 后续逐步替代.</p>
<p>当然, <code>Antd</code> 用起来也是很麻烦, 花了几天勉强搭起了一个简单功能的后台. </p>
<p>当时的想法就是, 这么几个页面, 用<code>vue</code>一天就搞定, 这个<code>react</code>花了我几天.</p>
<p>可能当时也是太年轻了.</p>
<p>后来开发第二个系统, 就开始结合上文所说的<code>vue后台实践</code> 所提到的几个要点去重新写系统</p>

            <h2>
              <a href="#React的router选择" id="React的router选择" class="heading"></a>React的router选择
            </h2>
          <p>react的路由选择目前有两种, 一种是官方的<code>react-router</code>, 另一个是刚出不久的<code>reach-router</code>.</p>
<p>而<code>react-router</code>也是从<code>v3</code>升级到了<code>v4</code>,  这次升级可以说是颠覆了传统的声明式路由</p>
<p>改成了路由组件化, 而不是传统的配置形式。</p>
<p>对于, <code>reach-router</code>可以说是麻雀虽小五脏俱全， 可以满足基本的路由功能,, <code>API</code>和路由组件使用起来也是比较简单的。</p>
<p>刚搭建项目时候，我从<code>v3</code>和<code>v4</code>中做过选择， 最后决定使用<code>v4</code>, 因为我个人喜欢用新不用旧。</p>
<p>在开发过程中，可能由于自己对<code>React</code>还不够熟悉， 在使用<code>Router</code>上也遇到不少问题。</p>
<p>比如最简单的路由跳转</p>
<p><code>v3</code>只需要直接调用<code>api</code>即可完成跳转</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-comment">/* react-router v3*/</span>
<span class="hljs-keyword">import</span> { browserHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router'</span>; 
browserHistory.<span class="hljs-keyword">push</span>(<span class="hljs-string">'/some/path'</span>);</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p><code>v4</code>需要引入高阶组件后才能从<code>props</code>中调用api.</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-comment">/* react-router v3*/</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">React</span> from <span class="hljs-symbol">'reac</span>t'
<span class="hljs-keyword">import</span> { withRouter } from <span class="hljs-symbol">'react</span>-router'
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-comment">// ...</span>
    push() {
        <span class="hljs-keyword">this</span>.props.history.push('/some/path')
    }
       <span class="hljs-comment">// ...</span>
}
export <span class="hljs-keyword">default</span> withRouter(<span class="hljs-type">Component</span>)</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>但是<code>v4</code>也有优点, 就是路由配置很灵活, 在需要用到的地方引入<code>Route</code>即可。</p>
<p>但是中途用着不爽，我就直接换成了<code>reach-router</code>。</p>
<p>这会<code>reach-router</code>用起来可爽了, 简单直接。</p>
<p>可是由于还不足够的成熟, 用了一段时间后，我又很无耻的改回了<code>react-router</code></p>
<p>不过我个人还是很欣赏<code>reach-router</code>, 希望后续能真正的发展起来。</p>

            <h2>
              <a href="#React+mobx结合" id="React+mobx结合" class="heading"></a>React+mobx结合
            </h2>
          <p>一般看到<code>React</code>, 一般也会伴随着<code>Redux</code>。</p>
<p>而我从<code>vue</code>和<code>vuex</code>那套过来的，不是很喜欢<code>Redux</code>那套复杂的规则和写法。</p>
<p>当然，也有很多成熟的解决方案，比如<code>dva</code>, <code>rematch</code>等, 轮子可不少啊。</p>
<p>但是我个人更偏向于使用<code>mobx</code>，或者跟<code>vuex</code>脱不了干系吧。</p>
<p>使用多<code>store</code>组合，或许能让组件更加的灵活。而且使用简单，不需要复杂的流程。</p>

            <h2>
              <a href="#React在项目中使用" id="React在项目中使用" class="heading"></a>React在项目中使用
            </h2>
          <p>主要是根据以往的<a href="https://zwing.site/posts/275254986.html">vue开发实践</a>，将其搬到<code>react</code>中来。</p>
<ul>
<li>用户登录态管理</li>
<li>router的钩子</li>
<li>列表页的数据加载，数据展示流程控制</li>
<li>列表页查询参数与url查询参数双向绑定</li>
<li>部分组件的实现</li>
</ul>
<p>...后续再补</p>
]]></description><link>http://zwingz.github.io/posts/339905815.html</link><guid isPermaLink="false">339905815</guid><category><![CDATA[front-end]]></category><category><![CDATA[js]]></category><category><![CDATA[react]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Tue, 10 Jul 2018 15:56:23 GMT</pubDate></item><item><title><![CDATA[Promise/A+规范以及实现]]></title><description><![CDATA[
            <h1>
              <a href="#Promise 实现原理" id="Promise 实现原理" class="heading"></a>Promise 实现原理
            </h1>
          <p><a href="https://github.com/zWingz/Promise">源码</a></p>

            <h2>
              <a href="#Promise基本用法" id="Promise基本用法" class="heading"></a>Promise基本用法
            </h2>
          
      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
</pre>
              </td>
              <td class="code"><pre>new Promise(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(resolve, reject)</span> {</span>
    resolve()
}).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val)</span> {</span>
    <span class="hljs-keyword">return</span> val
}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> {</span>
    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">error</span>)
}).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> {</span>
    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">error</span>)
})</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>Promise对象基本方法是<code>then</code>, 而<code>catch</code>是<code>then</code>的一个变形, 相当于<code>then(undefined, onReject)</code></p>

            <h2>
              <a href="#实现过程" id="实现过程" class="heading"></a>实现过程
            </h2>
          <p>根据Promise用法, 我们初步想到需要实现的方法是</p>
<ul>
<li>构造函数</li>
<li>resolve函数</li>
<li>reject函数</li>
<li>then函数</li>
</ul>
<p>此时Promise原型应为</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">'PENDING'</span>
<span class="hljs-keyword">const</span> RESOLVED = <span class="hljs-string">'RESOLVED'</span>
<span class="hljs-keyword">const</span> REJECT = <span class="hljs-string">'REJECT'</span>

<span class="hljs-keyword">class</span> <span class="hljs-built_in">Promise</span> {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">func</span>) {}
    resolve(){}
    reject(){}
    then(onReslove, onReject){}
}</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h3>
              <a href="#根据<code>Promise/A+规范</code>(以下简称规范)中所说的" id="根据<code>Promise/A+规范</code>(以下简称规范)中所说的" class="heading"></a>根据<code>Promise/A+规范</code>(以下简称规范)中所说的
            </h3>
          <ul>
<li>Promise有三个状态 <code>PENDING</code>, <code>RESOLVED</code>, <code>REJECTED</code></li>
<li>状态只会从<code>PENDING</code>转换到<code>RESOLVED</code>或者<code>REJECTED</code>其中一个, 并且之后不会再改变</li>
<li>当Promise处于执行态时, 会有一个终值, 并且该值不会再改变</li>
<li>当Promise处于拒绝态时, 会有一个据因, 并且该据因不会再改变</li>
<li>当Promise由PENDING转换为RESOLVED时, 会触发<code>onResolve</code>回调, 并且只执行一次</li>
<li>当Promise由PENDING转换为REJECTED时, 会触发<code>onReject</code>回调, 并且只执行一次</li>
<li>Promise状态的转换时机在于开发者何时调用promise的resolve或者reject函数</li>
</ul>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>{
    <span class="hljs-keyword">constructor</span>(func) {
        <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span> <span class="hljs-comment">// 终值或者据因</span>
        <span class="hljs-keyword">this</span>.status = PENDING <span class="hljs-comment">// 状态</span>
        <span class="hljs-keyword">this</span>.onResolveCallBack = [] <span class="hljs-comment">// resolved 回调</span>
        <span class="hljs-keyword">this</span>.onRejectCallBack = [] <span class="hljs-comment">// rejected 回调</span>
        <span class="hljs-keyword">try</span> {
            func(<span class="hljs-keyword">this</span>.resolve.bind(<span class="hljs-keyword">this</span>), <span class="hljs-keyword">this</span>.reject.bind(<span class="hljs-keyword">this</span>))
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-keyword">this</span>.reject(e)
        }
    }
    resolve(<span class="hljs-keyword">val</span>){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === PENDING) {
            <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">val</span> <span class="hljs-comment">// 设置终值</span>
            <span class="hljs-keyword">this</span>.status = RESOLVED <span class="hljs-comment">// 设置状态</span>
            <span class="hljs-keyword">this</span>.onResolveCallBack.forEach(each =&gt; {
                each(<span class="hljs-keyword">val</span>) <span class="hljs-comment">// 执行回调</span>
            })
        }
    }
    reject(reason){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === PENDING) {
            <span class="hljs-keyword">this</span>.value = reason <span class="hljs-comment">// 设置据因</span>
            <span class="hljs-keyword">this</span>.status = REJECT <span class="hljs-comment">// 设置状态</span>
            <span class="hljs-keyword">this</span>.onRejectCallBack.forEach(each =&gt; {
                each(reason) <span class="hljs-comment">// 执行回调</span>
            })
        }
    }
    then(onReslove, onReject){}
}</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>这里可能有人会说Promise应该是一个异步的过程, 在上面代码中并没有看到任何的异步. 比如说: setTimeout。</p>
<p>解答：</p>
<p>其实当创建一个Promise实例的时候，整个过程是同步的。</p>
<p>也就是说</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-keyword">const</span> ins = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
    res(<span class="hljs-number">10</span>)
})
<span class="hljs-built_in">console</span>.log(ins)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after ins'</span>)

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// Promise {&lt;resolved&gt;: 10}</span>
<span class="hljs-comment">// after ins</span>
</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>当你执行完这一句， ins的状态会马上变成<code>RESOLVED</code>. 说明在构造方法中并没有执行异步操作。如果真的需要异步的话，则需要主动在调用<code>res</code>前，加上<code>setTimeout</code>来触发异步。</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-keyword">const</span> ins = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        res(<span class="hljs-number">10</span>)
    })
})
<span class="hljs-built_in">console</span>.log(ins)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after ins'</span>)

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// Promise {&lt;pending&gt;}</span>
<span class="hljs-comment">// after ins</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h3>
              <a href="#还有一个<code>then</code>方法没有完成. 先看下规范怎么说" id="还有一个<code>then</code>方法没有完成. 先看下规范怎么说" class="heading"></a>还有一个<code>then</code>方法没有完成. 先看下规范怎么说
            </h3>
          <ul>
<li>一个promise必须提供一个<code>then</code>方法以访问当前值, 终止和据因</li>
<li>then接受两个参数<code>then(onResolve, onReject)</code></li>
<li>onResolve和onReject都是可选, 如果不是函数则被忽略</li>
<li>onResolve方法在promise执行结束后被调用, 其第一个参数为promise的终值, 被调用次数不超过一次</li>
<li>onReject方法在promise被拒绝后被调用, 其第一个参数为promise的据因, 同样被调用次数不超过一次</li>
<li>onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用 </li>
<li>如果onResolve和onReject返回一个值x, 则执行 <strong>Promise解决过程</strong></li>
<li>then方法必须返回一个<code>promise</code>对象</li>
</ul>
<p>简单说就是</p>
<ul>
<li>如果promise处于pending, 则将then回调放入promise的回调列表中</li>
<li>如果promise处于resolved, 则实行then方法中的onResolve</li>
<li>如果promise处于rejected, 则执行then方法中的onReject</li>
<li>then方法要确保onResolve和onReject异步执行</li>
<li>onResolve和onReject返回的值都将用来解决下一个promise(后面再讲解)</li>
<li>返回新的promise(注意: 一定是新的promise)</li>
</ul>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-keyword">class</span> <span class="hljs-constructor">Promise()</span> {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">then</span>(onResolve, onReject){
        const self = this
        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">nextResolve</span>, <span class="hljs-params">nextReject</span>)</span> {
            <span class="hljs-keyword">if</span>(self.status<span class="hljs-operator"> === </span>PENDING) {
                <span class="hljs-comment">// 加入到任务队列</span>
                self.onResolveCallback.push(onResolve)
                self.onRejectCallback.push(onReject)
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(self.status<span class="hljs-operator"> === </span>RESOLVED) {
                <span class="hljs-comment">// 异步执行</span>
                set<span class="hljs-constructor">Timeout(<span class="hljs-params">onResolve</span>, 0, <span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 异步执行</span>
                set<span class="hljs-constructor">Timeout(<span class="hljs-params">onReject</span>, 0, <span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>
            }
        })
    }
}</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>此时Promise已经可以完成异步操作.
但是Promise还有一个关键特点是可以链式调用. 目前是还没有实现链式调用这一步.
具体代码看<a href="https://github.com/zWingz/Promise/blob/master/promise2.js">promise2.js</a></p>

            <h3>
              <a href="#接下来继续看下规范怎么说" id="接下来继续看下规范怎么说" class="heading"></a>接下来继续看下规范怎么说
            </h3>
          <p>Promise 解决过程</p>
<ul>
<li>blablabla 这里比较长</li>
</ul>
<p><strong>简单说就是</strong></p>
<p><code>x</code>为<code>then</code>方法中<code>onResolve</code>或者<code>onReject</code>中返回的值, <code>promise2</code>为<code>then</code>方法返回的新<code>promise</code>.</p>
<p><code>promise</code>的解决过程是一个抽象步骤. 需要输入一个<code>promise</code>和一个<strong>值</strong>. 表示为<code>[[Resolve]](promise, x)</code></p>
<ul>
<li>如果<code>x</code>和<code>promise2</code>相等, 则以<code>TypeError</code>为据因拒绝执行promise2</li>
<li>如果<code>x</code>为<code>Promise</code>实例, 则让<code>promise2</code>接受x的状态</li>
<li>如果<code>x</code>为<code>thenable</code>对象, 则调用其<code>then</code>方法</li>
<li>如果都不满足, 则用<code>x</code>为参数执行<code>promise2</code></li>
</ul>
<p>继续修改then方法, 以及添加<code>resolvePromise</code>来执行<code>Promise</code>解决过程</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
<span>75</span>
<span>76</span>
<span>77</span>
<span>78</span>
<span>79</span>
<span>80</span>
<span>81</span>
<span>82</span>
<span>83</span>
<span>84</span>
<span>85</span>
<span>86</span>
<span>87</span>
<span>88</span>
<span>89</span>
<span>90</span>
<span>91</span>
<span>92</span>
<span>93</span>
<span>94</span>
<span>95</span>
<span>96</span>
<span>97</span>
<span>98</span>
<span>99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
<span>115</span>
<span>116</span>
<span>117</span>
<span>118</span>
<span>119</span>
<span>120</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-keyword">function</span> <span class="hljs-constructor">_isFunction(<span class="hljs-params">val</span>)</span> {
  return typeof <span class="hljs-keyword">val</span><span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>'
}
<span class="hljs-keyword">function</span> <span class="hljs-constructor">_isThenable(<span class="hljs-params">x</span>)</span> {
  return <span class="hljs-constructor">_isFunction(<span class="hljs-params">x</span>)</span><span class="hljs-operator"> || </span>(typeof x<span class="hljs-operator"> === </span>'object'<span class="hljs-operator"> &amp;&amp; </span>x !== null)
}

<span class="hljs-comment">/**
 * Promise 解决过程
 * 如果是thenable对象, 则触发该对象的then方法
 * 如果是一个值, 则直接调用resolve解析这个值
 * @param {Promise}} promise
 * @param {Object} x
 * @param {Function} resolve
 * @param {Function} reject
 */</span>
<span class="hljs-keyword">function</span> resolve<span class="hljs-constructor">Promise(<span class="hljs-params">promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> {
  <span class="hljs-comment">// 要求每次返回新的promise</span>
  <span class="hljs-comment">// 如果返回是当前的promise, 则抛出typeError</span>
  <span class="hljs-keyword">if</span> (x<span class="hljs-operator"> === </span>promise) {
    reject(<span class="hljs-keyword">new</span> <span class="hljs-constructor">TypeError('Chaining <span class="hljs-params">cycle</span> <span class="hljs-params">detected</span> <span class="hljs-params">for</span> <span class="hljs-params">promise</span>')</span>)
  }
  <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>
  <span class="hljs-comment">// 判断是否thenable对象</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-constructor">_isThenable(<span class="hljs-params">x</span>)</span>) {
    <span class="hljs-keyword">try</span> {
      const { <span class="hljs-keyword">then</span> } = x
      <span class="hljs-keyword">if</span> (<span class="hljs-constructor">_isFunction(<span class="hljs-params">then</span>)</span>) {
        <span class="hljs-keyword">then</span>.call(
          x,
         <span class="hljs-function"> <span class="hljs-params">val</span> =&gt;</span> {
            <span class="hljs-keyword">if</span> (!called) {
              called = <span class="hljs-literal">true</span>
              <span class="hljs-comment">// 如果不断的返回thenable</span>
              <span class="hljs-comment">// 则需要不断地递归</span>
              <span class="hljs-comment">// 但是实际上不应该不断的返回thenable</span>
              resolve<span class="hljs-constructor">Promise(<span class="hljs-params">promise</span>, <span class="hljs-params">val</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>
            }
          },
         <span class="hljs-function"> <span class="hljs-params">reason</span> =&gt;</span> {
            <span class="hljs-keyword">if</span> (!called) {
              called = <span class="hljs-literal">true</span>
              reject(reason)
            }
          }
        )
      } <span class="hljs-keyword">else</span> {
        resolve(x)
      }
    } catch (e) {
      <span class="hljs-keyword">if</span> (called) {
        return
      }
      called = <span class="hljs-literal">true</span>
      reject(e)
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//  非thenable, 则以该值来执行resolve</span>
    resolve(x)
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-constructor">Promise()</span> {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">/**
   * then方法
   * @param {Function} [onFulfilled] 前then的resolve函数, 当promise为RESOLVE时,处理当前结果
   * @param {Function} onRejected 当前then的reject函数, 当promise被REJECT时调用
   * @returns {Promise}
   * @memberof Promise
   */</span>
  <span class="hljs-keyword">then</span>(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled<span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>' ? onFulfilled :<span class="hljs-function"> <span class="hljs-params">val</span> =&gt;</span> <span class="hljs-keyword">val</span>
    onRejected =
      typeof onRejected<span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>'
        ? onRejected
        :<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> {
            throw err
          }
    const self = this
    <span class="hljs-comment">// 如果有then方法调用, 则将hasThenHandle设为true</span>
    <span class="hljs-comment">// console.log(this);</span>
    this.hasThenHandle = <span class="hljs-literal">true</span>
    <span class="hljs-comment">/**
     * 返回一个新的promise, 用于链式调用
     */</span>
    const ret = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> {
      <span class="hljs-comment">// 用try..catch包裹执行方法</span>
      const tryCatchWrapper = <span class="hljs-keyword">function</span>(fnc) {
        return <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> {
          <span class="hljs-keyword">try</span> {
            fnc<span class="hljs-literal">()</span>
          } catch (e) {
            reject(e)
          }
        }
      }
      <span class="hljs-comment">// 封装resolve方法回调</span>
      const doResolve = <span class="hljs-keyword">try</span><span class="hljs-constructor">CatchWrapper(<span class="hljs-params">function</span>()</span> {
        resolve<span class="hljs-constructor">Promise(<span class="hljs-params">ret</span>, <span class="hljs-params">onFulfilled</span>(<span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>, resolve, reject)
      })
      <span class="hljs-comment">// 封装reject方法回调</span>
      <span class="hljs-comment">// 如果当前then没有相应的reject回调</span>
      const doReject = <span class="hljs-keyword">try</span><span class="hljs-constructor">CatchWrapper(<span class="hljs-params">function</span>()</span> {
        resolve<span class="hljs-constructor">Promise(<span class="hljs-params">ret</span>, <span class="hljs-params">onRejected</span>(<span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>, resolve, reject)
      })
      <span class="hljs-keyword">if</span> (self.status<span class="hljs-operator"> === </span>PENDING) {
        <span class="hljs-comment">// 如果当前promise还未执行完毕, 则设置回调</span>
        self.onResolveCallback.push(doResolve)
        self.onRejectCallback.push(doReject)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status<span class="hljs-operator"> === </span>RESOLVED) {
        <span class="hljs-comment">// 如果为RESOLVE, 则异步执行resolve</span>
        set<span class="hljs-constructor">Timeout(<span class="hljs-params">doResolve</span>, 0)</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 如果为REJECT, 则异步执行reject</span>
        set<span class="hljs-constructor">Timeout(<span class="hljs-params">doReject</span>, 0)</span>
      }
    })
    return ret
  }
}</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>至此一个<code>Promise</code>可以说基本完成了.(完整代码请看<a href="https://github.com/zWingz/Promise/blob/master/index.js">index.js</a>)</p>

            <h3>
              <a href="#规范外的一些东西" id="规范外的一些东西" class="heading"></a>规范外的一些东西
            </h3>
          <p>其实规范中定义的是<code>Promise</code>的构建和执行过程.</p>
<p>而我们日常用到的却不至于规范中所提到的.</p>
<p>比如</p>
<ul>
<li>catch</li>
<li>finally</li>
<li>Promise.resolve</li>
<li>Promise.reject</li>
<li>all (未实现)</li>
<li>race (未实现)</li>
</ul>
<p>那接下来就说下关于这部分的实现</p>

            <h4>
              <a href="#catch" id="catch" class="heading"></a>catch
            </h4>
          <p>上面有提到. catch其实是<code>then(undefined, reject)</code> 的简写. 所以这里比较简单</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span></span>() {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">catch</span>(reject) {
        <span class="hljs-comment">// 相当于新加入一个then方法</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(undefined, reject)
    }
}</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h4>
              <a href="#finally (ES2018引入标准)" id="finally (ES2018引入标准)" class="heading"></a>finally (ES2018引入标准)
            </h4>
          <p>finally函数作用我想大家都应该知道, 就是无论当前promise状态是如何. 都一定会执行回调.</p>
<p>finally方法中, 不接收任何参数, 所以并不能知道前面的Promise的状态.</p>
<p>同时, 他不会对promise产生影响.总是返回原来的值 所以在<code>finally</code>中的操作,应该是与状态无关, 不依赖于promise的执行结果</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-keyword">class</span> <span class="hljs-built_in">Promise</span>() {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">finally</span>(fnc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> {
            fnc()
            <span class="hljs-keyword">return</span> val
        }, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
            fnc()
            <span class="hljs-keyword">throw</span> err
        })
    }
}</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h4>
              <a href="#Promise.resolve和Promise.reject (这里是从ES6入门中看到的定义)" id="Promise.resolve和Promise.reject (这里是从ES6入门中看到的定义)" class="heading"></a>Promise.resolve和Promise.reject (这里是从ES6入门中看到的定义)
            </h4>
          
      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-comment">// 调用形式</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve(arg)
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(arg)</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <ul>
<li><p>Promise.resolve</p>
<p>  根据arg的不同, 会执行不同的操作</p>

      <div class="hljs">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
</pre>
              </td>
              <td class="code"><pre> - arg为Promise实例, 则原封不动的返回这个实例
 - arg为thenable对象, 则会将arg转成promise, 并且立即执行&#x60;arg.then&#x60;方法(并不代表同步, 而是本轮事件循环结束时执行)
 - arg不满足上述情况, 则返回一个新的Promise实例, 状态为resolved, 终值为arg</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>  因此<code>Promise.resolve</code>是一个更方便的创建<code>Promise</code>实例的方法.</p>
</li>
<li><p>Promise.reject</p>
<p>  这里就不会区分arg, 而是原封不动的把arg作为据因, 执行后续方法的调用.</p>
</li>
</ul>
<p>实现代码</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span>() </span>{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">/**
     * Promise.resolve
     * 将参数转成Promise对象
     * @static
     * @param {any} val
     * @returns {MPromise}
     * @memberof MPromise
     */</span>
    <span class="hljs-keyword">static</span> resolve(x) {
        <span class="hljs-comment">// 如果为MPromise实例</span>
        <span class="hljs-comment">// 则返回该实例</span>
        <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {
            <span class="hljs-keyword">return</span> val
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_isThenable(x)) {
            <span class="hljs-comment">// 如果为具有then方法的对象</span>
            <span class="hljs-comment">// 则转为MPromise对象, 并且执行thenable</span>
            <span class="hljs-comment">/**
             * @example
             * MPromise.resolve({
             *      then(res) {
             *          console.log('do promise')
             *          res(10)
             *      }
             *  })
             */</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
                <span class="hljs-comment">// 执行异步</span>
                setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    val.then(res, rej)
                }, <span class="hljs-number">0</span>)
            })
        }
        <span class="hljs-comment">// 如果val为一个原始值,或者不具有then方法的对象</span>
        <span class="hljs-comment">// 则返回一个新的MPromise对象,状态为resolved</span>
        <span class="hljs-comment">/**
         * @example
         * MPromise.resolve()
         */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>{res(x)})
    }
    <span class="hljs-comment">/**
     * reject方法参数会原封不动的作为据因而变成后续方法的参数
     * 且初始状态为REJECT
     * 不存在判别thenable
     * @static
     * @param {any} reason 
     * @returns 
     * @memberof MPromise
     */</span>
    <span class="hljs-keyword">static</span> reject(reason) {
        <span class="hljs-comment">/**
         * @example
         * MPromise.reject('some error')
         */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{rej(reason)})
    }
}</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h3>
              <a href="#开发过程中遇到其他问题" id="开发过程中遇到其他问题" class="heading"></a>开发过程中遇到其他问题
            </h3>
          
            <h4>
              <a href="#node中的<code>unhandledRejection</code>和浏览器中的<code>Uncaught (in promise)</code> 提示" id="node中的<code>unhandledRejection</code>和浏览器中的<code>Uncaught (in promise)</code> 提示" class="heading"></a>node中的<code>unhandledRejection</code>和浏览器中的<code>Uncaught (in promise)</code> 提示
            </h4>
          <p>在Promise中产生的所有错误都会被Promise吞掉. 当没有相应的错误处理函数时候, node和浏览器分别有不同的表现.</p>
<p>但是这并不是一个新的错误, 因为不能用<code>try{} catch(){}</code> 捕获.</p>
<p>所以在浏览器端, 是一个<code>console.error</code>的错误提示, 在<code>node</code>中, 这个算是一个事件. 具体可以通过<code>process.on</code>来监听</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
</pre>
              </td>
              <td class="code"><pre>process.on(<span class="hljs-string">'unhandledRejection'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, p)</span> </span>{
  <span class="hljs-keyword">throw</span> err;
});</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>在编写代码中, 一开始卡在这一步挺久.</p>
<p>由于无法知道promise实例后续是否有相应的错误处理函数.</p>
<p>简单的判断<code>onReject === undefined</code> 是不行的.</p>
<p>形如:</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(<span class="hljs-number">10</span>)
<span class="hljs-comment">// 或者</span>
<span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">res</span>, <span class="hljs-params">rej</span>)</span> {
    rej(<span class="hljs-number">10</span>)
})</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>这类是同步执行的, <code>onReject === undefined</code> 恒为<code>true</code>.</p>
<p>我的做法是给promise实例添加一个<code>hasThenHandle</code>的属性, 在<code>then</code>方法中将其设为<code>true</code></p>
<p>在<code>reject</code>方法中使用<code>setTimeout</code>异步判断该值是否为<code>true</code>, 如果不是则通过<code>console.error</code>抛出提示.</p>
<p>其实在原生Promise中, 抛出的<code>unhandledRejection</code> 也是属于异步的.</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">10</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after Promise.reject'</span>)
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
    rej(<span class="hljs-number">10</span>)
})
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after new Promise'</span>)

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// after Promise.reject</span>
<span class="hljs-comment">// after new Promise</span>
<span class="hljs-comment">// Uncaught (in promise) 10</span>
<span class="hljs-comment">// Uncaught (in promise) 10</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>于是这个问题也能得到很好地解决.</p>
<p>至此完整代码已经结束, 具体看<code>index.js</code>.</p>

            <h2>
              <a href="#存在的问题" id="存在的问题" class="heading"></a>存在的问题
            </h2>
          <ul>
<li>由于用的是setTimeout模拟, 所以优先级不能保证高于setTimeout<ul>
<li>浏览器中可以用MessageChannel(macrotask)</li>
<li>node中可以用setImmediate(优先级在某些情况下比setTimeout高一些)</li>
<li>setTimeout和setImmediate在无IO操作下,两者执行顺序不确定,但是在IO操作下,setImmediate比setTimeout优先级高. 且setImmediate只在IE下有效</li>
</ul>
</li>
</ul>

            <h2>
              <a href="#参考" id="参考" class="heading"></a>参考
            </h2>
          <p><a href="http://www.ituring.com.cn/article/66566">【翻译】Promises/A+规范</a></p>
<p><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-prototype-finally">ECMAScript 6入门</a></p>
]]></description><link>http://zwingz.github.io/posts/316337025.html</link><guid isPermaLink="false">316337025</guid><category><![CDATA[front-end]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Fri, 20 Apr 2018 16:40:56 GMT</pubDate></item><item><title><![CDATA[初次制作戚风蛋糕（6寸）]]></title><description><![CDATA[
            <h2>
              <a href="#材料" id="材料" class="heading"></a>材料
            </h2>
          <ul>
<li>低筋面粉 45g</li>
<li>鸡蛋 3个</li>
<li>色拉油(植物油/玉米油) 20g</li>
<li>牛奶25g (没有牛奶.所以用了奶粉+水冲兑)</li>
<li>砂糖 40g(蛋白30g 蛋黄10g)</li>
<li>打蛋盆和有同样大的盆子</li>
<li>6寸模具（我的模具是8寸）</li>
</ul>

            <h2>
              <a href="#步骤" id="步骤" class="heading"></a>步骤
            </h2>
          <ul>
<li>用电子秤准确称取上次材料.。糖要分开秤,因为用途不一样。</li>
<li>是蛋清分离器将蛋白和蛋黄分开。每次分离时候在小碗里面分离，分离完了才将蛋白倒入打蛋盆中，以免污染了打蛋盆中的蛋白。将蛋黄放入另一个盆子中。</li>
<li>加入10g砂糖到打蛋盆中，使用电动打蛋器低速搅动。待出现大量泡泡时候，倒入10g糖，开高速档进行搅动，当蛋清出现纹路后，加入最后10g砂糖，继续搅动。直到打蛋器提起后蛋白不会掉落，此时蛋白已经算打发完成。</li>
<li>用手动打蛋器搅拌蛋黄，搅拌完后，倒入10g砂糖、25g牛奶、20g植物油。继续搅拌。</li>
<li>用面粉筛将低筋面粉塞入蛋黄液中。</li>
<li>使用刮刀将面粉和蛋黄液混合，此处不能用打蛋器。刮刀混合时候从下往上翻，不能想打鸡蛋一样顺时针转动。要像炒菜一样。</li>
<li>混合搅拌至面粉糊没有颗粒。</li>
<li>烤箱150°预热10分钟。</li>
<li>取1/3打发好的蛋白，混入面糊当中，继续用刮刀将两者搅拌均匀。</li>
<li>将面糊全部倒入到打蛋盆中，与剩余的蛋白继续搅拌均匀，直到没有颗粒。</li>
<li>将搅拌好的面糊倒入蛋糕模中。</li>
<li>烤箱150°烤30-40分钟。</li>
<li>完成后取出。</li>
<li>摔模：将模具举高离台面5-8cm，摔下。</li>
<li>然后将模具倒扣在烤网上面，待蛋糕冷却后脱模。</li>
<li>此时戚风蛋糕制作完成。</li>
</ul>

            <h2>
              <a href="#失败点与总结" id="失败点与总结" class="heading"></a>失败点与总结
            </h2>
          <ul>
<li>烤的中途打开了烤箱门，可能导致蛋糕回缩了。 因为一开始时候蛋糕还是逐渐增高，后面不知道为什么缩回去了，有可能是因为我打开了烤箱门。</li>
<li>第三个鸡蛋蛋清分离失败了，然后就直接把整个鸡蛋放入蛋黄液中，也不清楚是否有影响。</li>
<li>没有用牛奶而是用奶粉+水，可能有影响。 </li>
</ul>

            <h2>
              <a href="#图片" id="图片" class="heading"></a>图片
            </h2>
          <p><img src="https://zwing.site/imgur/92583692.jpg" alt=""></p>
<p><img src="https://zwing.site/imgur/31921272.jpg" alt=""></p>
<p><img src="https://zwing.site/imgur/61126157.jpg" alt=""></p>
<p><img src="https://zwing.site/imgur/44394098.jpg" alt=""></p>

            <h2>
              <a href="#最后" id="最后" class="heading"></a>最后
            </h2>
          <p>这次戚风蛋糕第一次尝试，还是挺不错的，评个80分吧。</p>
<p>本来是打算弄芝士蛋糕，奈何没有奶油奶酪，只能做原味戚风蛋糕了。
下次可以买奶油奶酪试试做芝士蛋糕。</p>
<p>周末做了下蛋包饭，差点就做成了蛋炒饭。</p>
<p>原因还是材料太多了，炒起来鸡蛋都保不住。</p>
<p>不过吃起来还是挺好吃，可能下次要注意下材料分量，鸡蛋能包起来就更好吃了。</p>
]]></description><link>http://zwingz.github.io/posts/310330786.html</link><guid isPermaLink="false">310330786</guid><category><![CDATA[杂事]]></category><category><![CDATA[烘焙]]></category><category><![CDATA[生活]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Sun, 01 Apr 2018 15:13:17 GMT</pubDate></item><item><title><![CDATA[记：再一次制作蛋挞。]]></title><description><![CDATA[
            <h2>
              <a href="#材料" id="材料" class="heading"></a>材料
            </h2>
          <ul>
<li>蛋黄3个 (蛋清分离，只要蛋黄)</li>
<li>糖霜 10g （太少了，下次可以试着20g）</li>
<li>牛奶250ml</li>
<li>低筋粉 15g （有点多，下次试着10g）</li>
<li>蛋挞皮9个 （刚好的）</li>
</ul>

            <h2>
              <a href="#过程" id="过程" class="heading"></a>过程
            </h2>
          <ul>
<li>用蛋清分离器，将鸡蛋逐个进行蛋清分离。将蛋黄放入打蛋盆中，蛋清可以另外存放，可以作为双皮奶原料。</li>
<li>由于没有牛奶，于是用了4勺奶粉代替。</li>
<li>电子秤称取10g糖霜。此次蛋挞不够甜，下次可以尝试放20g，或者15g砂糖也可以。</li>
<li>将糖霜倒入奶粉中，并用热水冲兑，搅拌，静置到常温。</li>
<li>用电子秤称取15g低筋粉（此次感觉过多，下次只称取10g），放入小碗中存放。</li>
<li>用打蛋器（手动）将蛋黄打散，并逐步加入混入糖霜的牛奶，分三次倒入，一边倒一边搅拌。</li>
<li>用面粉筛分三次筛入低筋面粉，并且一边筛入一边搅拌，尽量让蛋液和面粉混合。</li>
<li>筛入面粉后，此时蛋液有较多的泡沫。</li>
<li>使用过滤筛，过滤掉过多的泡沫。此次我一共过滤了三遍。</li>
<li>烤箱220度预热10分钟。</li>
<li>取出烤盆，铺上油纸，放入9个蛋挞皮。</li>
<li>倒入蛋挞液，9成满。</li>
<li>烤箱预热完毕，则放入蛋挞烤即可。</li>
<li>220度烤25分钟即可完成。</li>
</ul>

            <h2>
              <a href="#上图" id="上图" class="heading"></a>上图
            </h2>
          
            <h3>
              <a href="#倒入蛋挞液后" id="倒入蛋挞液后" class="heading"></a>倒入蛋挞液后
            </h3>
          <p><img src="https://zwing.site/imgur/45790429.jpg" alt=""></p>

            <h3>
              <a href="#放入烤箱" id="放入烤箱" class="heading"></a>放入烤箱
            </h3>
          <p><img src="https://zwing.site/imgur/75661678.jpg" alt=""></p>

            <h3>
              <a href="#正在烤的蛋挞" id="正在烤的蛋挞" class="heading"></a>正在烤的蛋挞
            </h3>
          <p><img src="https://zwing.site/imgur/33388698.jpg" alt=""></p>

            <h3>
              <a href="#成品" id="成品" class="heading"></a>成品
            </h3>
          <p><img src="https://zwing.site/imgur/38696134.jpg" alt=""></p>

            <h2>
              <a href="#结语" id="结语" class="heading"></a>结语
            </h2>
          <ul>
<li>不够甜，需要加多点糖。</li>
<li>面粉太多了，有点沉底。</li>
</ul>
]]></description><link>http://zwingz.github.io/posts/308242286.html</link><guid isPermaLink="false">308242286</guid><category><![CDATA[杂事]]></category><category><![CDATA[烘焙]]></category><category><![CDATA[生活]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Sat, 24 Mar 2018 09:13:45 GMT</pubDate></item><item><title><![CDATA[开发环境搭建]]></title><description><![CDATA[
            <h1>
              <a href="#mac开发环境" id="mac开发环境" class="heading"></a>mac开发环境
            </h1>
          
            <h2>
              <a href="#安装 brew" id="安装 brew" class="heading"></a>安装 brew
            </h2>
          
      <div class="hljs bash">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/ruby -e "$(curl -fsSL https:/</span><span class="hljs-regexp">/raw.githubusercontent.com/</span>Homebrew<span class="hljs-regexp">/install/m</span>aster<span class="hljs-regexp">/install)"</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h2>
              <a href="#终端环境" id="终端环境" class="heading"></a>终端环境
            </h2>
          <ul>
<li><p><a href="https://www.iterm2.com/">iterm2</a></p>
</li>
<li><p><a href="http://ohmyz.sh/">oh-my-zsh</a></p>
<p>安装</p>

      <div class="hljs bash">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
</pre>
              </td>
              <td class="code"><pre>sh -c <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>添加插件</p>

      <div class="hljs bash">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
</pre>
              </td>
              <td class="code"><pre>vim ~<span class="hljs-string">/.zshrc</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
      <div class="hljs bash">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
</pre>
              </td>
              <td class="code"><pre>plugins=(
  <span class="hljs-name">git</span>
  z
)</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>​</p>
</li>
</ul>

            <h2>
              <a href="#node 环境搭建" id="node 环境搭建" class="heading"></a>node 环境搭建
            </h2>
          <ul>
<li><p>安装 nvm</p>
<p>```shell
curl -o- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh">https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh</a> | bash</p>

            <h1>
              <a href="#or" id="or" class="heading"></a>or
            </h1>
          <p>wget -qO- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh">https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh</a> | bash</p>
</li>
</ul>

            <h1>
              <a href="#then" id="then" class="heading"></a>then
            </h1>
          
            <h1>
              <a href="#vim ~/.bash_profile or ~/.zshrc or ~/.profile or ~/.bashrc" id="vim ~/.bash_profile or ~/.zshrc or ~/.profile or ~/.bashrc" class="heading"></a>vim ~/.bash_profile or ~/.zshrc or ~/.profile or ~/.bashrc
            </h1>
          
            <h1>
              <a href="#insert" id="insert" class="heading"></a>insert
            </h1>
          <p>  export NVM_DIR=&quot;$HOME/.nvm&quot;
  [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</p>

            <h1>
              <a href="#last" id="last" class="heading"></a>last
            </h1>
          <p>  source ~/.your_rcprofile</p>

      <div class="hljs">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
</pre>
              </td>
              <td class="code"><pre>
  ​

  使用方法

  &#x60;&#x60;&#x60;shell
  # 本地node版本
  nvm ls


  # node所有版本
  nvm ls-remote


  # 安装最新node(稳定版,即偶数版)
  nvm install --lts


  # 安装指定版本node
  nvm install v8.9.4


  # 切换到指定版本&#x2F;别名node
  nvm use v8.9.4


  # 给node版本起别名
  nvm alias default v8.9.4</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <ul>
<li><p>安装 node</p>
<p><code>nvm install v8.9.4</code></p>
</li>
<li><p>npm 换源</p>

      <div class="hljs bash">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-meta"># npm 源</span>
npm config <span class="hljs-keyword">set</span> registry https:<span class="hljs-comment">//registry.npm.taobao.org</span>
<span class="hljs-meta"># sass 源</span>
npm config <span class="hljs-keyword">set</span> sass_binary_site https:<span class="hljs-comment">//npm.taobao.org/mirrors/node-sass/</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>​</p>
</li>
</ul>

            <h2>
              <a href="#git 配置" id="git 配置" class="heading"></a>git 配置
            </h2>
          <ul>
<li><p>安装</p>

      <div class="hljs">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
</pre>
              </td>
              <td class="code"><pre>brew install git</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    </li>
<li><p>配置 ssh-key</p>

      <div class="hljs bash">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
</pre>
              </td>
              <td class="code"><pre>git config --global user<span class="hljs-selector-class">.name</span> <span class="hljs-string">''</span>
git config --global user<span class="hljs-selector-class">.email</span> <span class="hljs-string">''</span>

ssh-keygen -t res -C <span class="hljs-string">'email'</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>​</p>
</li>
<li><p>配置 hosts</p>
<p>```bash
cd ~/.ssh
vim config</p>

            <h1>
              <a href="#写入" id="写入" class="heading"></a>写入
            </h1>
          <p>Host github.com
HostName github.com
User git
IdentityFile ~/.ssh/id_rsa_github</p>
<p>Host gitlab.com
HostName gitlab.com
User git
IdentityFile ~/.ssh/id_rsa_gitlab</p>
</li>
</ul>

            <h1>
              <a href="#注入密码,下次不需要再输密码(除非重启)" id="注入密码,下次不需要再输密码(除非重启)" class="heading"></a>注入密码,下次不需要再输密码(除非重启)
            </h1>
          <p>  ssh-add -k ~/.ssh/id_rsa_gitlab
  ```</p>
<p>  ​</p>

          <h2>
            <a href="https://code.visualstudio.com/" id="undefined" class="heading"></a>vscode
          </h2>
        <ul>
<li>安装插件 <code>Setting Sync</code></li>
<li>设置 gist <code>&quot;sync.gist&quot;: &quot;8162a18bd9632ab95c50704e92e1a57c&quot;</code></li>
<li>同步 Setting</li>
<li>主要插件<code>eslint</code> <code>vetur</code> <code>document this</code> <code>javascript code snippets</code> <code>project manager</code></li>
</ul>

            <h2>
              <a href="#开发环境搭建完毕" id="开发环境搭建完毕" class="heading"></a>开发环境搭建完毕
            </h2>
          ]]></description><link>http://zwingz.github.io/posts/303526921.html</link><guid isPermaLink="false">303526921</guid><category><![CDATA[front-end]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Thu, 08 Mar 2018 15:45:19 GMT</pubDate></item><item><title><![CDATA[vue组件-固定表格]]></title><description><![CDATA[
            <h1>
              <a href="#固定表格" id="固定表格" class="heading"></a>固定表格
            </h1>
          <p>后台管理系统,多多少少会有列表页.</p>
<p>而列表页又正是由表格形成.</p>
<p>但是原生的表头并不能固定头部以及两侧.</p>
<p>一旦数据多了,查看起来就不方便了.</p>
<p>于是乎就出现很多固定表头/两侧的表格组件</p>

            <h2>
              <a href="#实现原理" id="实现原理" class="heading"></a>实现原理
            </h2>
          
            <h3>
              <a href="#绝对定位" id="绝对定位" class="heading"></a>绝对定位
            </h3>
          <ul>
<li><p>实现方式
这种应该是最普遍也是最简单的方式.</p>
<p>就是将一个表格分成多个表格.</p>
<p>包括表头/左侧/右侧/表体, 共四个表格</p>
<p>然后通过 css 方式将表头以及两侧固定</p>
<p>之后通过 scroll 事件的监听,同步表头以及两侧的 scroll 值,就可以达到固定的效果</p>
</li>
<li><p>优点
实现起来简单,而且无缝滚动</p>
</li>
<li><p>缺点
表格都是使用 table-layout:fixed; 使得每个单元格宽度固定.</p>
<p>如果不使用 fixed 的话.则需要一个 <col> 管理每一列的宽度.</p>
<p>这样不能达到宽度自适应的情况</p>
<p>滚动必须是局部滚动.而不是跟随全局.</p>
</li>
<li><p>例子
elementUI 的表格就是这样实现的.
<img src="https://zwing.site/imgur/39962386.jpg" alt="">
同一个表格的表头,表体分别复制了3次.用来形成表头和两侧的固定.</p>
<p>使用绝对定位固定两侧.</p>
<p>通过管理 scroll 的值管理表头以及两侧滚动.</p>
<p>这样就会导致 dom 数量的增加.</p>
</li>
</ul>

            <h2>
              <a href="#css 方法 - position: sticky" id="css 方法 - position: sticky" class="heading"></a>css 方法 - position: sticky
            </h2>
          <p>此方法原生支持固定表头.</p>
<p>但是目前<a href="https://caniuse.com/#feat=css-sticky">兼容性</a>不客观
<img src="https://zwing.site/imgur/67634294.jpg" alt=""></p>

            <h2>
              <a href="#本文实现" id="本文实现" class="heading"></a>本文实现
            </h2>
          <ul>
<li><a href="http://zwing.site/vue-fixed-table/release/demo.html">DEMO</a>(原谅我没弄样式)</li>
</ul>

            <h3>
              <a href="#背景" id="背景" class="heading"></a>背景
            </h3>
          <p>当固定表头的需求提出来时,我也是曾经想过直接使用 elementUI 的表格.</p>
<p>但是发现使用 elementUI 的表格插件需要改动不少代码.而且感觉不够灵活.</p>
<p>于是就自己去实现</p>

            <h3>
              <a href="#第一版" id="第一版" class="heading"></a>第一版
            </h3>
          <p>由于考虑到不想使用 fixed 布局以及组个单元格去管理宽度.</p>
<p>而且不想使用局部滚动</p>
<p>所以一开始就决定使用 监听全局滚动+transition 方式.让表格头跟随滚动走</p>
<p>也就是说.当表头贴近浏览器上端的时候才固定.</p>
<p>而不是局部滚动式的固定.</p>
<p>这样 thead 和 tbody 就是一体,不存在宽度不一致问题</p>

            <h3>
              <a href="#兼容性问题" id="兼容性问题" class="heading"></a>兼容性问题
            </h3>
          <p>一旦thead产生了 transform. 表格的 border-collapse 会失效.表格头的边框会消失.</p>
<p>为了解决这个问题.我使用阴影来替代 border.</p>
<p>但是在 safari 上.transform 部分不会显示出阴影..暂无解</p>
<p>对于 transition 问题.</p>
<p>在 chrome 下不存在闪烁卡顿现象, 而在 Firefox 和 safari 则存在闪烁和卡顿现象.</p>
<p>由于是内部系统, 使用 chrome 居多.所以 firefox 和 safari 下只做了兼容性处理.</p>

            <h3>
              <a href="#第二版" id="第二版" class="heading"></a>第二版
            </h3>
          <p>在第一版完成后, 基本实现了固定表格头功能. 而且在 chrome 下表现顺畅.</p>
<p>于是着手实现固定两侧.这里实现原理一样.所以很容易实现
<img src="https://zwing.site/imgur/60520413.jpg" alt=""></p>
<p>这种虽然右侧是固定在浏览器右侧.</p>
<p>但是整体页面还是被撑开的.</p>
<p>那么对于表格上下的其他组件,他们依旧是被浏览器隐藏.需要横向滚动才能看到.</p>
<p>于是我继续开始第三版改造</p>

            <h3>
              <a href="#第三版" id="第三版" class="heading"></a>第三版
            </h3>
          <p>这一版主要就是为了页面的其他组件不被表格的宽高影响.也就是说不管表格多高多宽.</p>
<p>都可以在不滚动的前提下看到.</p>
<p>那么就是将表格变成局部滚动了.</p>
<p><img src="https://zwing.site/imgur/99932867.jpg" alt=""></p>
<p>其实就是一个自适应的内滚动容器.</p>
<p>前提是页面高度宽度都是100%</p>
<p>也就是说要有环境让容器产生滚动</p>
<p>监听此容器的滚动来控制表格头和两侧的固定.</p>
<p>但是收到反馈说这种表格看起来很狭小.不够大气</p>
<p><img src="https://zwing.site/imgur/42701513.jpg" alt=""></p>
<p>没办法,只能继续进行思考改进</p>

            <h3>
              <a href="#### 思考改进" id="### 思考改进" class="heading"></a>### 思考改进
            </h3>
          <p>在开始之前我的想法是</p>
<p>结合第二第三版.</p>
<p>将垂直滚动交给页面.横向滚动自管理.</p>
<p>什么意思呢?</p>
<p>就是页面高度可以被撑开. 但是宽度不能被撑开.</p>
<p>也就是说全局只有 y 轴滚动.没有 x 轴滚动.</p>
<p>其实第三版是可以实现的.</p>
<p>页面只需限制宽度为100%.高度不做限制,就可以轻松的达到要求.</p>
<p><img src="https://zwing.site/imgur/27128653.jpg" alt=""></p>
<p>注意这里的高度其实没有做限制的.也就是说容器滚动条被隐藏了.</p>
<p>那如果要横向滚动怎么办.</p>
<p>很简单啊.按着 shift 再滚动就是横向滚动了.</p>
<p><img src="https://zwing.site/imgur/42701513.jpg" alt=""></p>
<p>这是不科学的.不是每个人都知道.</p>
<p>那样是不是可以有一条虚拟的横向滚动条, 来管理表格的横向滚动呢.</p>
<p>于是就有第四版</p>

            <h3>
              <a href="#第四版" id="第四版" class="heading"></a>第四版
            </h3>
          <p>就是就是额外添加一个虚拟滚动条的组件.</p>
<p>当容器底部被浏览器隐藏时候.则平移这个滚动条至屏幕底部</p>
<ul>
<li>原生滚动条被隐藏时候,显示虚拟滚动条
<img src="https://zwing.site/imgur/24267221.jpg" alt=""></li>
<li>原生滚动条显示时候,隐藏虚拟滚动条
<img src="https://zwing.site/imgur/61056576.jpg" alt=""></li>
</ul>
<p>这样, 既能使得页面不被撑开. 同时高度也不需要限定在100%.</p>
<p>刚好能满足需求.</p>

            <h3>
              <a href="#实现方法" id="实现方法" class="heading"></a>实现方法
            </h3>
          <p>实现方法其实就是使用 transform 以及监听滚动来实现固定咯.</p>
<p>但是在使用上,则需要有一定的规则.</p>
<p><img src="https://zwing.site/imgur/81508433.jpg" alt=""></p>
<p>也就是说</p>
<p>在使用的时候.要通过 slot 分别配置 head,left,right 的内容.</p>
<p>简单说就是把表格拆分成左/中/右</p>
<p>那么 thead 和 tbody 就能保持列宽度.</p>
<p>关键处理:</p>
<ul>
<li>通过 slot配置左/中/右以及表格头/表格体 </li>
</ul>
<ul>
<li>hover 样式需要通过 mouseOver 和 mouseleave 去管理</li>
<li>通过监听表格和窗口的 resize 事件,以及使用 MutationObserver 来监听表格子节点的变化来重新获取表格宽度.(因为双侧固定需要依赖左中右的宽度)</li>
<li>通过监听全局滚动, 固定表格头</li>
<li>通过监听父容器的横向滚动, 固定两侧</li>
</ul>

            <h3>
              <a href="#不足之处" id="不足之处" class="heading"></a>不足之处
            </h3>
          <ul>
<li><p>兼容性不太好, 在 chrome 表现良好(至少高版本的流畅), firefox 和 safari 则有卡顿现象,目前做法是在滚动时候,使用 opcity 将固定部分隐藏.滚动结束后显示</p>
</li>
<li><p>table 宽度变更时候. 右侧会有闪烁. 因为右侧固定算是很依赖表格宽度以及自身宽度.所以宽度变化对右侧影响很大. 暂未解决</p>
</li>
<li><p>需要有 css 支持. 让容易有一个可滚动的环境.</p>
</li>
<li><p>使用时候会把正常的 table 拆分成几部分. </p>
<p><img src="https://zwing.site/imgur/67633591.jpg" alt=""></p>
</li>
</ul>

            <h3>
              <a href="#AlignCell 是什么 ?" id="AlignCell 是什么 ?" class="heading"></a>AlignCell 是什么 ?
            </h3>
          <p>其实就是 th 或者 td.</p>
<p>封装起来就是因为设计师想要达到表格每一列整体居中的前提下,左或者右对齐.</p>
<p>当然, 当数据量多的时候,每个单元格基本都是刚满足宽度. 直接左对齐是没问题的.</p>
<p>但是当数据不多.每个单元格宽度都是充足时候,这时候直接使用左对齐是不行的</p>
<p>那么,我也只好封装一层了. 这里就不介绍了</p>

            <h2>
              <a href="#结语" id="结语" class="heading"></a>结语
            </h2>
          <p>虽然瑕疵比较多.但是开发整个组件过程,我个人是收获不少的.</p>
<p>由于是内部系统.也没怎么考虑兼容性.能在 chrome 顺利跑就问题不大了.</p>
<p>后续会继续优化</p>

            <h2>
              <a href="#放假了, 过年了" id="放假了, 过年了" class="heading"></a>放假了, 过年了
            </h2>
          <p>祝大家新年快乐 !</p>
]]></description><link>http://zwingz.github.io/posts/295960409.html</link><guid isPermaLink="false">295960409</guid><category><![CDATA[front-end]]></category><category><![CDATA[vue]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Fri, 09 Feb 2018 18:10:56 GMT</pubDate></item><item><title><![CDATA[使用vuexStore.registerModule构建命令式组件]]></title><description><![CDATA[
            <h2>
              <a href="#命令式组件" id="命令式组件" class="heading"></a>命令式组件
            </h2>
          <p>例如Notification, MessageBox, Alert, ConfirmBox 等等</p>
<p>这类组件都是通过命令式来调用.</p>
<p>例如<code>elementUi</code>中<code>this.$message</code>或者<code>Message</code>来调用.</p>
<p>对于我们来说,<code>this.$message</code>这种调用方法莫过于是最方便.因为不需要处处引入<code>Message</code>或者在<code>webpack</code>中配置插件使得<code>Message</code>暴露于全局</p>
<p>那么我就从<code>this.$message</code>这类讲起</p>

            <h2>
              <a href="#组件编写" id="组件编写" class="heading"></a>组件编写
            </h2>
          <p>其实也只是编写一个Comp组件, 这里不多说.</p>

            <h2>
              <a href="#接入方式" id="接入方式" class="heading"></a>接入方式
            </h2>
          
            <h3>
              <a href="#第一种接入方式" id="第一种接入方式" class="heading"></a>第一种接入方式
            </h3>
          <p>将<code>Vue</code>组件挂载到一个<code>dom</code>上,也就是将组件实例化.</p>
<p>然后将组件实例挂载命名空间中或者<code>Vue.prototype</code>中,</p>
<p>这样相当于直接操作组件实例的<code>methods</code>来改变组件的状态.</p>
<p><code>ElementUI</code>使用的是这种方式.</p>
<p>无入侵式</p>

            <h3>
              <a href="#第二种接入方式" id="第二种接入方式" class="heading"></a>第二种接入方式
            </h3>
          <p>这方式前提必须要使用Vuex, 因为他是依赖vuex.registerStore实现</p>
<p>关于registerStore请移步到<a href="https://vuex.vuejs.org/en/modules.html">文档</a>中</p>
<p>其实就是动态注册一个storeModule, 用来管理组件的状态.</p>
<p>所有操作都通过细改store的状态来引起组件的改变</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
</pre>
              </td>
              <td class="code"><pre>// 引入组件
<span class="hljs-keyword">import</span> Comp from <span class="hljs-string">'Comp.vue'</span>
<span class="hljs-keyword">function</span> registerModule(store) {
    store.registerModule(<span class="hljs-string">'compNameSpaceState'</span>, {
        namespaced: true,
        state: {},
        getters: {},
        mutations: {},
        actions: {}
    })
}</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>之后可以将通过对象将调用接口暴露出去</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-keyword">let</span> $compApi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// 此处需要使用建投函数,确保this指向</span>
        action: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">'compNameSpaceState/compAction'</span>)
        }
    }
}</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>接下来很简单,就是将$compApi.prototype中.</p>
<p>那么如何保证<code>$compApi</code>中<code>this</code>指向<code>Vue</code>实例呢</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-keyword">let</span> bind = <span class="hljs-literal">false</span>
<span class="hljs-comment">// Vue.use() 会自动调用install方法,此时可以注册组件</span>
Comp.install = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Vue</span>) </span>{
    <span class="hljs-comment">// 代理带vue原形上.可以通过this.$spin调用</span>
    <span class="hljs-built_in">Object</span>.defineProperties(Vue.prototype, {
        <span class="hljs-attr">$compApi</span>: { <span class="hljs-comment">// 挂载到Vue.prototype中的$compApi</span>
            get() {
                <span class="hljs-keyword">if</span>(!bind) {
                    <span class="hljs-comment">// 注册store</span>
                    registerModule(<span class="hljs-keyword">this</span>.$store)
                    <span class="hljs-comment">// 只需要绑定一次即可</span>
                    <span class="hljs-comment">// 绑定后可以将原来的$compApi覆盖掉</span>
                    <span class="hljs-comment">// 调用bind函数确保this指向</span>
                    $compApi = $compApi.bind(<span class="hljs-keyword">this</span>)()
                    bind = <span class="hljs-literal">true</span>
                }
                <span class="hljs-keyword">return</span> $compApi
            }
        }
    })
    <span class="hljs-comment">// 将组件注册为Vue全局组件</span>
    Vue.component(<span class="hljs-string">'Comp'</span>, Comp)
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Comp</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>最后一步则需要在App.vue将Comp挂载上去</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-comment">// 这一步自动调用install, 会全局注册Comp</span>
<span class="hljs-comment">// 但是在第一次调用$compApi时候才会进行registerStore.</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vue</span>.</span></span>use(Comp)</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
      <div class="hljs html">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-comment">&lt;!-- App.vue--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Comp</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>这种方法是入侵式的</p>
<p>但是可以很方便的追踪组件状态, 而且实现起来也很方便.</p>
<p>在自己开发组件的时候可以考虑</p>
]]></description><link>http://zwingz.github.io/posts/294718179.html</link><guid isPermaLink="false">294718179</guid><category><![CDATA[front-end]]></category><category><![CDATA[js]]></category><category><![CDATA[vue]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Tue, 06 Feb 2018 11:04:40 GMT</pubDate></item><item><title><![CDATA[Eventloop中的microtask和macrotask]]></title><description><![CDATA[
            <h1>
              <a href="#EventLoop" id="EventLoop" class="heading"></a>EventLoop
            </h1>
          <p>js是单线程的, 所有异步都需要经过Eventloop(事件循环).这里不介绍eventloop</p>
<p> 主要记录下eventloop中的microtask 和macrotask</p>

            <h2>
              <a href="#microtask" id="microtask" class="heading"></a>microtask
            </h2>
          <ul>
<li>process.nextTick</li>
<li>Promise</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>

            <h2>
              <a href="#macrotask" id="macrotask" class="heading"></a>macrotask
            </h2>
          <ul>
<li>setTimeout</li>
<li>setImmediate</li>
<li>setInterval</li>
<li>UI rendering</li>
<li>网络I/O以及用户I/O</li>
<li>network</li>
</ul>

            <h2>
              <a href="#优先级" id="优先级" class="heading"></a>优先级
            </h2>
          <ul>
<li>microtask &gt; macrotask</li>
<li>process.nextTick &gt; promise (process.nextTick只在node使用)</li>
<li>setTimeout和setImmediate在无IO操作下,两者执行顺序不确定,但是在IO操作下,setImmediate比setTimeout优先级高. 且setImmediate只在IE下有效</li>
</ul>

            <h2>
              <a href="#应用" id="应用" class="heading"></a>应用
            </h2>
          <p>Vue.nextTick源码中,分别使用了microtask和macrotask</p>
<p>在Vue2.4版本之前,默认都是使用microtask.优先判断是否支持promise,如果不支持则退回到MutationObserver,如果再不支持则回退到setTimeout</p>
<p>但在后续更新中,Vue已经修改nextTick实现方式.默认使用microtask, 同时也提供方法强制使用macrotask,例如由v-on绑定的事件处理.</p>
<p>原因就是因为microtask优先级太高.甚至高于事件冒泡. 而macrotask则会引起一些问题.</p>
<p>详情请看<a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L20:4">Vue.nextTick源码</a></p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-comment">// Here we have async deferring wrappers using both micro and macro tasks.</span>
<span class="hljs-comment">// In &lt; 2.4 we used micro tasks everywhere, but there are some scenarios where</span>
<span class="hljs-comment">// micro tasks have too high a priority and fires in between supposedly</span>
<span class="hljs-comment">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span>
<span class="hljs-comment">// event (#6566). However, using macro tasks everywhere also has subtle problems</span>
<span class="hljs-comment">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span>
<span class="hljs-comment">// Here we use micro task by default, but expose a way to force macro task when</span>
<span class="hljs-comment">// needed (e.g. in event handlers attached by v-on).</span>
<span class="hljs-keyword">let</span> microTimerFunc
<span class="hljs-keyword">let</span> macroTimerFunc
<span class="hljs-keyword">let</span> useMacroTask = <span class="hljs-literal">false</span>

<span class="hljs-comment">// Determine (macro) Task defer implementation.</span>
<span class="hljs-comment">// Technically setImmediate should be the ideal choice, but it's only available</span>
<span class="hljs-comment">// in IE. The only polyfill that consistently queues the callback after all DOM</span>
<span class="hljs-comment">// events triggered in the same loop is by using MessageChannel.</span>
<span class="hljs-comment">/* istanbul ignore if */</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(setImmediate)) {
  macroTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setImmediate(flushCallbacks)
  }
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> MessageChannel !== <span class="hljs-string">'undefined'</span> &amp;&amp; (
  isNative(MessageChannel) ||
  <span class="hljs-comment">// PhantomJS</span>
  MessageChannel.toString() === <span class="hljs-string">'[object MessageChannelConstructor]'</span>
)) {
  <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> MessageChannel()
  <span class="hljs-keyword">const</span> port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    port.postMessage(<span class="hljs-number">1</span>)
  }
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">/* istanbul ignore next */</span>
  macroTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setTimeout(flushCallbacks, <span class="hljs-number">0</span>)
  }
}

<span class="hljs-comment">// Determine MicroTask defer implementation.</span>
<span class="hljs-comment">/* istanbul ignore next, $flow-disable-line */</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(<span class="hljs-built_in">Promise</span>)) {
  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve()
  microTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    p.then(flushCallbacks)
    <span class="hljs-comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span>
    <span class="hljs-comment">// it can get stuck in a weird state where callbacks are pushed into the</span>
    <span class="hljs-comment">// microtask queue but the queue isn't being flushed, until the browser</span>
    <span class="hljs-comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span>
    <span class="hljs-comment">// "force" the microtask queue to be flushed by adding an empty timer.</span>
    <span class="hljs-keyword">if</span> (isIOS) setTimeout(noop)
  }
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// fallback to macro</span>
  microTimerFunc = macroTimerFunc
}</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    ]]></description><link>http://zwingz.github.io/posts/294602245.html</link><guid isPermaLink="false">294602245</guid><category><![CDATA[front-end]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Tue, 06 Feb 2018 01:35:11 GMT</pubDate></item><item><title><![CDATA[多个git 配置ssh key]]></title><description><![CDATA[
            <h2>
              <a href="#安装" id="安装" class="heading"></a>安装
            </h2>
          
      <div class="hljs bash">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
</pre>
              </td>
              <td class="code"><pre>brew install git
<span class="hljs-meta"># or</span>
<span class="hljs-meta"># apt-get install git</span>

<span class="hljs-meta">## 配置ssh-key</span>

git config --global user.name <span class="hljs-string">''</span>
git config --global user.email <span class="hljs-string">''</span>

ssh-keygen -t res -C <span class="hljs-string">'email'</span>
<span class="hljs-meta"># 然后就是自定义</span>
<span class="hljs-meta"># 要不要密码随便你</span>
<span class="hljs-meta"># 反正下面都会进行ssh-add</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>上github或者gitlab, 进入setting,找到ssh-key, 点击new SSH Key 把id_rsa.pub内容粘贴进去就ok了</p>
<p><img src="https://user-images.githubusercontent.com/13031838/35666461-2aaa5d40-0765-11e8-9e62-1ae17cb933a2.png" alt="image"></p>

            <h2>
              <a href="#检查" id="检查" class="heading"></a>检查
            </h2>
          <p><code>ssh git@github.com</code></p>
<p><img src="https://user-images.githubusercontent.com/13031838/35666525-620a3544-0765-11e8-8590-1018bdabae20.png" alt="image"></p>

            <h2>
              <a href="#配置hosts" id="配置hosts" class="heading"></a>配置hosts
            </h2>
          
      <div class="hljs bash">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
</pre>
              </td>
              <td class="code"><pre>cd ~/.ssh
vim<span class="hljs-built_in"> config
</span>
Host github.com
HostName github.com<span class="hljs-built_in">
User </span>git
IdentityFile ~/.ssh/id_rsa_github

Host gitlab.com
HostName gitlab.com<span class="hljs-built_in">
User </span>git
IdentityFile ~/.ssh/id_rsa_gitlab


<span class="hljs-comment"># 注入密码,下次不需要再输密码(除非重启)</span>
ssh-<span class="hljs-builtin-name">add</span> -k ~/.ssh/id_rsa_gitlab</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h3>
              <a href="#简单快捷完成git配置了" id="简单快捷完成git配置了" class="heading"></a>简单快捷完成git配置了
            </h3>
          ]]></description><link>http://zwingz.github.io/posts/293431355.html</link><guid isPermaLink="false">293431355</guid><category><![CDATA[front-end]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Thu, 01 Feb 2018 07:37:09 GMT</pubDate></item><item><title><![CDATA[记一次webpack优化 --- 从babelrc和UglifyPlugin下手]]></title><description><![CDATA[
            <h2>
              <a href="#优化前" id="优化前" class="heading"></a>优化前
            </h2>
          <p>先来看优化前打包速度
大的第三方库大概有vue+axios+vueRouter+vuex+elementUI(datepicker, message两个插件)+jquery
打包总体积为2648k, 一共14个chunk(使用了异步路由)
<img src="https://user-images.githubusercontent.com/13031838/35665400-19f380fc-0761-11e8-944b-85a5117364c2.png" alt="image"></p>
<p>在我本地打包一次需要31s</p>
<p><img src="https://user-images.githubusercontent.com/13031838/35664714-26a6075a-075e-11e8-8df9-1cde8b4f1878.png" alt="image"></p>
<p>而在服务器打包时候则要70s以上, 这里就不贴图了. </p>

            <h2>
              <a href="#优化后" id="优化后" class="heading"></a>优化后
            </h2>
          <p>优化后时间
打包总体积上升为2700k, 上升了50k</p>
<p><img src="https://user-images.githubusercontent.com/13031838/35665453-3ce893ea-0761-11e8-8d79-2c8b3555acb5.png" alt="image"></p>
<p>本地打包18s</p>
<p><img src="https://user-images.githubusercontent.com/13031838/35664879-c88ec336-075e-11e8-88c0-a61590c97cad.png" alt="image"></p>
<p>服务器打包时间40s</p>
<p><img src="https://user-images.githubusercontent.com/13031838/35664898-d966d888-075e-11e8-8e6b-70b4043afe8b.png" alt="image"></p>
<p><strong>提升很明显有没有</strong></p>

            <h2>
              <a href="#修改了哪些地方 ?" id="修改了哪些地方 ?" class="heading"></a>修改了哪些地方 ?
            </h2>
          
            <h3>
              <a href="#UglifePlugin" id="UglifePlugin" class="heading"></a>UglifePlugin
            </h3>
          <p>主要修改地方还是在UglifyPlugin配置中
由于我是用的并不是webpack自带的,而是独立的<a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin">uglifyjs-webpack-plugin</a></p>
<p>其实官方使用的也是这个插件. 只不过官方使用的暂且不是最新版,而webpack4.0-beta已经使用此插件最新版本</p>
<p>用法很简单</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-variable">const</span> <span class="hljs-variable">UglifyJsPlugin</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">'uglifyjs-webpack-plugin'</span>)</span>

<span class="hljs-variable">module</span>.exports = {
  <span class="hljs-variable">plugins</span>: [
    <span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">UglifyJsPlugin</span>()</span>
  ]
}</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>如果使用默认配置,那么打包速度并不会有提升.</p>
<p>而且uglifyplugin在打包过程中其实也会进行一些压缩优化,比如内敛静态变量等等.</p>
<p>那么我们可以从这里面入手,去除一切不必要的压缩优化.可以提升压缩速度.</p>
<p>同时.我们需要开启parallel和cache选项,对压缩进行缓存和多线程执行</p>
<p>具体配置规则请参考官方文档<a href="https://github.com/mishoo/UglifyJS2/tree/harmony#minify-options">UglifyOptions</a></p>
<p>我的最终配置如下</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
<span>75</span>
<span>76</span>
<span>77</span>
<span>78</span>
<span>79</span>
<span>80</span>
<span>81</span>
<span>82</span>
<span>83</span>
<span>84</span>
<span>85</span>
<span>86</span>
<span>87</span>
<span>88</span>
<span>89</span>
<span>90</span>
<span>91</span>
<span>92</span>
<span>93</span>
<span>94</span>
<span>95</span>
<span>96</span>
<span>97</span>
<span>98</span>
<span>99</span>
<span>100</span>
<span>101</span>
</pre>
              </td>
              <td class="code"><pre>    <span class="hljs-string">new</span> <span class="hljs-string">UglifyEsPlugin({</span>
<span class="hljs-attr">            parallel:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
<span class="hljs-attr">            cache:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
<span class="hljs-attr">            sourceMap:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
<span class="hljs-attr">            uglifyOptions:</span> <span class="hljs-string">{</span>
<span class="hljs-attr">                ecma:</span> <span class="hljs-number">8</span><span class="hljs-string">,</span>
                <span class="hljs-string">//</span> <span class="hljs-string">详细规则</span>
                <span class="hljs-string">//</span> <span class="hljs-attr">https://github.com/mishoo/UglifyJS2/tree/harmony#minify-options</span>
<span class="hljs-attr">                compress:</span> <span class="hljs-string">{</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">在UglifyJs删除没有用到的代码时不输出警告</span>
<span class="hljs-attr">                    warnings:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">删除所有的</span> <span class="hljs-string">`console`</span> <span class="hljs-string">语句</span>
<span class="hljs-attr">                    drop_console:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">将()=&gt;{return</span> <span class="hljs-string">x}</span> <span class="hljs-string">转成</span> <span class="hljs-string">()=&gt;x</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.eslint有做检查</span>
<span class="hljs-attr">                    arrows:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">转换类似!!a</span> <span class="hljs-string">?</span> <span class="hljs-string">b</span> <span class="hljs-string">:</span> <span class="hljs-string">c</span> <span class="hljs-string">→</span> <span class="hljs-string">a</span> <span class="hljs-string">?</span> <span class="hljs-string">b</span> <span class="hljs-string">:</span> <span class="hljs-string">c</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.eslint做检查</span>
<span class="hljs-attr">                    booleans:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">转换由计算得来的属性名</span> <span class="hljs-string">{["computed"]:</span> <span class="hljs-number">1</span><span class="hljs-string">}</span> <span class="hljs-string">is</span> <span class="hljs-string">converted</span> <span class="hljs-string">to</span> <span class="hljs-string">{computed:</span> <span class="hljs-number">1</span><span class="hljs-string">}.</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭,eslint做检查</span>
<span class="hljs-attr">                    computed_props:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">自动转换判断</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">e.g.</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> <span class="hljs-type">!b</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-type">!c</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-type">!d</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-type">!e</span> <span class="hljs-string">→</span> <span class="hljs-string">a=!(b||c||d||e)</span> <span class="hljs-string">etc.</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭,请自行做规范</span>
<span class="hljs-attr">                    comparisons:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">去掉死代码</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.eslint做检查</span>
<span class="hljs-attr">                    dead_code:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭debugger</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">eslint做检查</span>
<span class="hljs-attr">                    drop_debugger:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">自动进行静态算术计算</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">开启</span>
<span class="hljs-attr">                    evaluate:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">函数声明提升</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">默认就是关闭,不需要开启</span>
<span class="hljs-attr">                    hoist_funs:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">For</span> <span class="hljs-attr">example:</span> <span class="hljs-string">var</span> <span class="hljs-string">o={p:1,</span> <span class="hljs-attr">q:2};</span> <span class="hljs-string">f(o.p,</span> <span class="hljs-string">o.q);</span> <span class="hljs-string">is</span> <span class="hljs-string">converted</span> <span class="hljs-string">to</span> <span class="hljs-string">f(1,</span> <span class="hljs-number">2</span><span class="hljs-string">);</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">不需要咯</span>
<span class="hljs-attr">                    hoist_props:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">变量提升</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">不需要咯</span>
<span class="hljs-attr">                    hoist_vars:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span>  <span class="hljs-string">optimizations</span> <span class="hljs-string">for</span> <span class="hljs-string">if/return</span> <span class="hljs-string">and</span> <span class="hljs-string">if/continue</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">不需要,</span> <span class="hljs-string">eslint做检查</span>
<span class="hljs-attr">                    if_return:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">/**</span>
                     <span class="hljs-string">*</span> <span class="hljs-string">无法用言语表达,自行理解</span>
                     <span class="hljs-string">*</span> <span class="hljs-string">inline</span> <span class="hljs-string">(default:</span> <span class="hljs-literal">true</span><span class="hljs-string">)</span> <span class="hljs-bullet">--</span> <span class="hljs-string">inline</span> <span class="hljs-string">calls</span> <span class="hljs-string">to</span> <span class="hljs-string">function</span> <span class="hljs-string">with</span> <span class="hljs-string">simple/return</span> <span class="hljs-attr">statement:</span>
                        <span class="hljs-literal">false</span> <span class="hljs-bullet">--</span> <span class="hljs-string">same</span> <span class="hljs-string">as</span> <span class="hljs-number">0</span>
                        <span class="hljs-number">0</span> <span class="hljs-bullet">--</span> <span class="hljs-string">disabled</span> <span class="hljs-string">inlining</span>
                        <span class="hljs-number">1</span> <span class="hljs-bullet">--</span> <span class="hljs-string">inline</span> <span class="hljs-string">simple</span> <span class="hljs-string">functions</span>
                        <span class="hljs-number">2</span> <span class="hljs-bullet">--</span> <span class="hljs-string">inline</span> <span class="hljs-string">functions</span> <span class="hljs-string">with</span> <span class="hljs-string">arguments</span>
                        <span class="hljs-number">3</span> <span class="hljs-bullet">--</span> <span class="hljs-string">inline</span> <span class="hljs-string">functions</span> <span class="hljs-string">with</span> <span class="hljs-string">arguments</span> <span class="hljs-string">and</span> <span class="hljs-string">variables</span>
                        <span class="hljs-literal">true</span> <span class="hljs-bullet">--</span> <span class="hljs-string">same</span> <span class="hljs-string">as</span> <span class="hljs-number">3</span>
                     <span class="hljs-string">*/</span>
<span class="hljs-attr">                    inline:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">join</span> <span class="hljs-string">consecutive</span> <span class="hljs-string">var</span> <span class="hljs-string">statements</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">就是将变量声明合并到一个var中</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭,</span> <span class="hljs-string">eslin做检查</span>
<span class="hljs-attr">                    join_vars:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">自动去除无用的function参数</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.</span> <span class="hljs-string">eslint做检查</span>
<span class="hljs-attr">                    keep_fargs:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span>  <span class="hljs-string">Pass</span> <span class="hljs-literal">true</span> <span class="hljs-string">to</span> <span class="hljs-string">prevent</span> <span class="hljs-string">Infinity</span> <span class="hljs-string">from</span> <span class="hljs-string">being</span> <span class="hljs-string">compressed</span> <span class="hljs-string">into</span> <span class="hljs-number">1</span><span class="hljs-string">/0</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">禁止将infinity转成1/0</span>
<span class="hljs-attr">                    keep_infinity:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">optimizations</span> <span class="hljs-string">for</span> <span class="hljs-string">do,</span> <span class="hljs-string">while</span> <span class="hljs-string">and</span> <span class="hljs-string">for</span> <span class="hljs-string">loops</span> <span class="hljs-string">when</span> <span class="hljs-string">we</span> <span class="hljs-string">can</span> <span class="hljs-string">statically</span> <span class="hljs-string">determine</span> <span class="hljs-string">the</span> <span class="hljs-string">condition.</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">优化循环</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">此处关闭,应该由开发者自行优化</span>
<span class="hljs-attr">                    loops:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">negate</span> <span class="hljs-string">"Immediately-Called Function Expressions"</span> <span class="hljs-string">where</span> <span class="hljs-string">the</span> <span class="hljs-string">return</span> <span class="hljs-string">value</span> <span class="hljs-string">is</span> <span class="hljs-string">discarded,</span> <span class="hljs-string">to</span> <span class="hljs-string">avoid</span> <span class="hljs-string">the</span> <span class="hljs-string">parens</span> <span class="hljs-string">that</span> <span class="hljs-string">the</span> <span class="hljs-string">code</span> <span class="hljs-string">generator</span> <span class="hljs-string">would</span> <span class="hljs-string">insert.</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">自行体会</span>
<span class="hljs-attr">                    negate_iife:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span>  <span class="hljs-string">rewrite</span> <span class="hljs-string">property</span> <span class="hljs-string">access</span> <span class="hljs-string">using</span> <span class="hljs-string">the</span> <span class="hljs-string">dot</span> <span class="hljs-string">notation,</span> <span class="hljs-string">for</span> <span class="hljs-string">example</span> <span class="hljs-string">foo["bar"]</span> <span class="hljs-string">→</span> <span class="hljs-string">foo.bar</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.eslint检查</span>
<span class="hljs-attr">                    properties:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">将只用到一次的function,通过inline方式插入</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.开发者自行把控</span>
<span class="hljs-attr">                    reduce_funcs:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">将静态变量直接lnline紧代码里</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">可以开启</span>
<span class="hljs-attr">                    reduce_vars:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">使用逗号运算符连接连续的简单语句</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">自行把控</span>
<span class="hljs-attr">                    sequences:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">/**</span>
                     <span class="hljs-string">*</span>  <span class="hljs-string">Pass</span> <span class="hljs-literal">false</span> <span class="hljs-string">to</span> <span class="hljs-string">disable</span> <span class="hljs-string">potentially</span> <span class="hljs-string">dropping</span> <span class="hljs-string">functions</span> <span class="hljs-string">marked</span> <span class="hljs-string">as</span> <span class="hljs-string">"pure"</span><span class="hljs-string">.</span> 
                     <span class="hljs-string">*</span> <span class="hljs-string">A</span> <span class="hljs-string">function</span> <span class="hljs-string">call</span> <span class="hljs-string">is</span> <span class="hljs-string">marked</span> <span class="hljs-string">as</span> <span class="hljs-string">"pure"</span> <span class="hljs-string">if</span> <span class="hljs-string">a</span> <span class="hljs-string">comment</span> <span class="hljs-string">annotation</span> <span class="hljs-string">\/*@__PURE__*\/</span> <span class="hljs-string">or</span> <span class="hljs-string">\/*#__PURE__*\/</span> <span class="hljs-string">immediately</span> <span class="hljs-string">precedes</span> <span class="hljs-string">the</span> <span class="hljs-string">call.</span> 
                     <span class="hljs-string">*</span> <span class="hljs-string">For</span> <span class="hljs-attr">example:</span> <span class="hljs-string">\/*@__PURE__*\/foo();</span>
                     <span class="hljs-string">*</span> <span class="hljs-string">就是关闭标注纯函数的注释了</span>
                     <span class="hljs-string">*/</span>
<span class="hljs-attr">                    side_effects:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">去掉重复和无法到达的switch分支</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">eslint做检查,</span> <span class="hljs-string">以及开发者把控</span>
<span class="hljs-attr">                    switches:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">Transforms</span> <span class="hljs-string">typeof</span> <span class="hljs-string">foo</span> <span class="hljs-string">==</span> <span class="hljs-string">"undefined"</span> <span class="hljs-string">into</span> <span class="hljs-string">foo</span> <span class="hljs-string">===</span> <span class="hljs-string">void</span> <span class="hljs-number">0</span>
<span class="hljs-attr">                    typeofs:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                <span class="hljs-string">}</span>
            <span class="hljs-string">}</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>其实很多优化点都是可以通过eslint来检查,而不需要在压缩过程检查</p>
<p>再配合自身的开发习惯以及规范,可以去掉很多压缩检查, 压缩效率就能提升</p>
<p>但是带来的负面影响就是压缩体积会有上升/</p>
<p>因为对于第三方库来说,并不会安装项目配置的eslint来跑.自然就达不到要求.</p>
<p>再少了uglifyplugin的压缩优化,体积就会上升.</p>
<p>以我的例子来看,总体积上升了50k. 尚可以接受.</p>
<p>而打包时间足足提升了30s. </p>
<p>但可能也有人说上线打包不必在乎打包时间.</p>
<p>其实这些都看具体业务需求,以及自身的开发规范来配置.</p>
<p>重要的还是在打包速度和打包体积两者中找出一个最合适的平衡点</p>

            <h3>
              <a href="#.babelrc" id=".babelrc" class="heading"></a>.babelrc
            </h3>
          <p>其实babel并不会影响到打包速度.我也只是顺便提下</p>
<p>我的配置如下</p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
</pre>
              </td>
              <td class="code"><pre>{
    <span class="hljs-attr">"plugins"</span>: [
        [
            <span class="hljs-string">"component"</span>,
            [{
                <span class="hljs-attr">"libraryName"</span>: <span class="hljs-string">"element-ui"</span>,
                <span class="hljs-attr">"styleLibraryName"</span>: <span class="hljs-string">"theme-default"</span>
            }]]
    ],
    <span class="hljs-attr">"comments"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"env"</span>: {
        <span class="hljs-attr">"development"</span>: {
            <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"transform-object-rest-spread"</span>, <span class="hljs-string">"syntax-dynamic-import"</span>]
        },
        <span class="hljs-attr">"production"</span>: {
            <span class="hljs-attr">"presets"</span>: [[<span class="hljs-string">"es2015"</span>, {<span class="hljs-attr">"modules"</span>: <span class="hljs-literal">false</span>}], <span class="hljs-string">"stage-2"</span>],
            <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"transform-runtime"</span>]
        },
        <span class="hljs-attr">"test"</span>: {
            <span class="hljs-attr">"presets"</span>: [<span class="hljs-string">"env"</span>, <span class="hljs-string">"stage-2"</span>],
            <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"transform-runtime"</span>, <span class="hljs-string">"istanbul"</span>]
        }
    }
}
</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <p>我把babel配置区分成了三个阶段,开发,生产和测试.</p>
<p>在开发过程不使用preset,直接跑原生代码. </p>
<p>在生产环境则使用es2015的preset</p>
<p>也许这样能提高开发环境的编译速度? 暂时不清楚,因为没感觉.一向很快.</p>
<p>这也看个人喜好了.</p>

            <h2>
              <a href="#ps" id="ps" class="heading"></a>ps
            </h2>
          <p>eslint的作用真的很大很大.</p>
<p>但是在开发阶段使用eslint真的很烦很烦.</p>
<p>所以,我目前的做法就是在开发阶段关闭eslint检查.因为我的vscode有带插件提示</p>
<p>即便检查到有错误,也可以正常编译.</p>
<p>但是在commit的时候添加了一层pre-commit来对修改的文件执行eslint.</p>
<p>这样就确保上传到git的代码是经过eslint检查的</p>
<p>这样既能确保开发不被干扰,也能确保代码能按照规范.</p>
]]></description><link>http://zwingz.github.io/posts/293426099.html</link><guid isPermaLink="false">293426099</guid><category><![CDATA[front-end]]></category><category><![CDATA[webpack]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Thu, 01 Feb 2018 07:13:03 GMT</pubDate></item><item><title><![CDATA[烹饪和烘焙的点滴]]></title><description><![CDATA[<p>突然想写些什么..
那就写下这周做了什么吃的..
除了晚餐之外.
这周做了特别的可能就是<strong>炸薯条</strong>, <strong>火烧云</strong>以及<strong>芒果千层</strong>了.
下面就大概回忆下过程</p>

            <h2>
              <a href="#炸薯条" id="炸薯条" class="heading"></a>炸薯条
            </h2>
          <p>  其实炸薯条本不是本人的意思, 只是女友说突然想吃薯条, 就在买菜的时候买多了一个土豆.
  由于不是本人的意思,过程也只是大概记得.</p>
<ul>
<li>土豆去皮, 切成条</li>
<li>用保鲜袋装好,放冰箱冷冻(其实嘛.我也不知道这一步是不是必须,也可能是那晚我们吃得饱,所以才放冰箱,留到下次弄得)</li>
<li>先把薯条煮一边,放盐, 软了后捞出</li>
<li>倒掉水, 并擦干平底锅</li>
<li>放油,(新买的一瓶油我放了三分一)</li>
<li>油热了之后把薯条放进去炸就ok了..</li>
<li>炸完捞出可以再撒些盐. 然后放置一阵子就能吃了</li>
</ul>
<p>其实一开始全程都是女友在弄.只不过她炸的时候油放的太少了..然后跑过来跟我说像是在炒薯条..
于是乎我就自己上了..其实这也是我第一次炸薯条.
炸完之后油也只能倒掉.感觉很浪费.炸一个土豆用了1/3瓶油..
感觉以后都不会再炸东西了.除非量大. 这里就没图了.很简单的</p>

            <h2>
              <a href="#火烧云" id="火烧云" class="heading"></a>火烧云
            </h2>
          <p>  这个其实我上星期就有做过了.只不过做失败了.
  其实就是面包再加工一下啦, 外表看起来逼格挺高. 吃起来也还ok</p>
<ul>
<li>材料(鸡蛋两个, 吐司(方包)4片, 炼奶, 沙拉酱)</li>
<li>蛋清分离, 用蛋清分离器分离, 将蛋清倒入无水碗中, 然后将蛋黄放另外一个碗(两个鸡蛋的蛋清可以放于同一个碗中, 蛋黄必须放于两个不同的碗, 同时蛋黄一定不能破, 一旦破了混入到了蛋清中,就不容易打发蛋清了, 上周失败就是因为分离的时候蛋黄破了, 导致打发失败)</li>
<li>将蛋清倒入打蛋盆中, 加入一勺糖(根据自己喜好添加), 使用电动打蛋器进行打发, 当出现纹路的时候, 再加入一勺糖, 继续打发, 当感觉打发出现阻力时候, 继续加入一勺糖, 继续打发. 直到达到硬性打发程度, 就是打蛋器提起来, 蛋清不会掉下来, 就像我们平常吃的奶油一样. 整个步骤一定不能有水, 有水就不容易打发了. 砂糖除了调味, 还能促进打发</li>
<li>此时我们有的东西就是打发了的蛋清,以及两个蛋黄</li>
<li>取一片吐司, 涂上一层炼奶, 再涂上一层沙拉酱(也可以是其他,也可以不要,看个人), 再取一片方包, 盖在上面.</li>
<li>用刮刀将打发的蛋清涂到上一步中的吐司上方, 一共取一般的蛋清, 并对其进行造型, 弄成你觉得好看的样子.</li>
<li>在蛋清中间挖个孔, 将蛋黄倒进去, 此时已经完成一个火烧云了.</li>
<li>另一个就根据上述步骤一样就行</li>
<li>烤箱150度预热5分钟</li>
<li>将面包放入烤箱15分钟即可</li>
<li>这时候的蛋黄其实是溏心蛋, 我个人是很喜欢</li>
</ul>
<p>就是由于上周失败了, 并且找到原因, 所以这周就铁了心要把它完成. 当然这里肯定有图了</p>
<ul>
<li><p>这是入烤箱前
<img src="https://zwing.site/imgur/645802.jpg" alt=""></p>
</li>
<li><p>烤完后
<img src="https://zwing.site/imgur/84359394.jpg" alt="">
味道还是不错的, 也挺简单.</p>
</li>
</ul>

            <h2>
              <a href="#芒果千层" id="芒果千层" class="heading"></a>芒果千层
            </h2>
          <p>做这个芒果千层, 耗时3小时, 也是不容易啊
这里先上图, 之后再补充制作过程
<img src="https://zwing.site/imgur/38760413.jpg" alt=""></p>

            <h2>
              <a href="#其他" id="其他" class="heading"></a>其他
            </h2>
          <p>其实烤箱双十一就购入了, 同时也购入了一批烘焙工具,从此入了烘焙的坑,
不入不知道, 一入深似海
这里就顺便贴下图吧.过程就先忽略了</p>
<ul>
<li>鸡蛋布丁
<img src="https://zwing.site/imgur/42554020.jpg" alt=""></li>
</ul>
<ul>
<li>西多士
<img src="https://zwing.site/imgur/69072942.jpg" alt="">
<img src="https://raw.githubusercontent.com/zWingz/imgur/master/52877777.jpg" alt=""></li>
</ul>
<ul>
<li>蛋挞
<img src="https://zwing.site/imgur/59916873.jpg" alt="">
<img src="https://zwing.site/imgur/70796582.jpg" alt="">
<img src="https://zwing.site/imgur/48233877.jpg" alt=""></li>
</ul>
<ul>
<li>风琴土豆
<img src="https://zwing.site/imgur/33495732.jpg" alt=""></li>
</ul>
]]></description><link>http://zwingz.github.io/posts/292217983.html</link><guid isPermaLink="false">292217983</guid><category><![CDATA[烘焙]]></category><category><![CDATA[生活]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Sun, 28 Jan 2018 16:34:04 GMT</pubDate></item><item><title><![CDATA[vue后台系统开发实践]]></title><description><![CDATA[
            <h2>
              <a href="#Vue后台系统开发实践" id="Vue后台系统开发实践" class="heading"></a>Vue后台系统开发实践
            </h2>
          
            <h3>
              <a href="#依赖库" id="依赖库" class="heading"></a>依赖库
            </h3>
          <ul>
<li><a href="mailto:vue@2.4.4">vue@2.4.4</a></li>
<li><a href="mailto:vue-router@3.0.0">vue-router@3.0.0</a></li>
<li><a href="mailto:vuex@3.0.0">vuex@3.0.0</a></li>
<li>axios</li>
<li>element-ui</li>
</ul>

            <h3>
              <a href="#搭建流程" id="搭建流程" class="heading"></a>搭建流程
            </h3>
          <ol>
<li><p><a href="https://github.com/zWingz/vue-webpack-template">webpack-template</a></p>
</li>
<li><p>createApp.js, createRouter.js, store.js, http.js</p>
<ul>
<li>createaApp.js 多页时候用来配置各个页面相同的vue选项,比如配置api,mixin等等</li>
<li>createRouter.js 多页时候用到配置各个页面相同的路由选项,比如配置路由模式,路由钩子等等</li>
<li>store.js 配置全局状态管理.state,action,mutation,getter</li>
<li>http.js 配置异步请求, 例如: baseRoot, 请求钩子interceptors</li>
</ul>
</li>
<li><p>utils.js, ConstValue.js, mixin.js, registerComponent.js</p>
<ul>
<li>utils.js 工具类函数</li>
<li>ConstValue.js 常量,例如: isProduction, httpRoot(后端地址)</li>
<li>mixin.js 混合</li>
<li>registerComponent.js 将经常用到的组件在这里引入并注册为全局组件</li>
</ul>
</li>
<li><p>route.js, app.js</p>
<ul>
<li>route/.js 具体的路由</li>
<li>app.js 每个页面的app启动页</li>
</ul>
</li>
<li><p>page-view&amp;components</p>
<ul>
<li>页面级内容</li>
</ul>
</li>
</ol>

            <h3>
              <a href="#后台大致内容" id="后台大致内容" class="heading"></a>后台大致内容
            </h3>
          <ul>
<li>登录/权限</li>
<li>列表页</li>
<li>详情/审核页</li>
<li>创建/修改页</li>
</ul>

            <h3>
              <a href="#问题分析" id="问题分析" class="heading"></a>问题分析
            </h3>
          <ul>
<li><p>登录/权限</p>
<ul>
<li>登录态的保存.以及用户权限的判断<ol>
<li>后端设置sessionid, 前端只需要在axios配置withCredentials=true.(此方法在Safari行不通,safari默认选项(仅)允许来自我访问的网站, 由于后端地址不是直接访问.所以safari不会带上cookie去请求.部署的时候将前后端都部署到同一个nginx就可以解决)</li>
<li>json web token(jwt)</li>
<li>后端生成token,并由保存在http header.</li>
<li>权限判断一种是导航显示控制,一种是直接通过url进去后的判断</li>
</ol>
</li>
</ul>
</li>
<li><p>列表页</p>
<ul>
<li><p>内容过多.会引起页面滚动.表头以及两侧需固定</p>
<ol>
<li>全局滚动.(表格过大.页面整体会被撑开)</li>
<li>容器内滚动.(表格显得很狭窄)</li>
<li>垂直方向全局滚动, 水平方向是局部滚动. (页面宽度不被撑开, 加虚拟滚动条辅助时候水平滚动不需要拉到最后)</li>
<li><a href="https://zwingz.github.io/vue-fixed-table/release/demo.html">Demo</a></li>
</ol>
</li>
<li><p>有很多的查询条件</p>
<ul>
<li>查询需要被保留,同时url需要被查询条件修改(<code>$router.replace</code>)</li>
</ul>
</li>
<li><p>每一个列表页类似.但又有不同,主要差异在于查询条件以及表格内容</p>
<ul>
<li>使用mixin</li>
<li>设置查询query</li>
<li>根据query以及url获取数据</li>
<li>对数据进行处理,比如: loading态设为false, 初始化多选等. 看具体</li>
</ul>
</li>
<li><p>列表页/详情页切换后列表数据的保存(保留列表页状态)</p>
<ul>
<li>vuex(全局状态管理, 写起来会很多,一个页面一个state,action,mutation,getters)</li>
<li>keepAlive(active/mounted获取数据, active会导致数据次数过多, mounted会导致数据不同步. 此时可以使用trigger,主动触发列表页拉取数据)</li>
</ul>
</li>
</ul>
</li>
<li><p>详情页/审核页</p>
<ul>
<li><p>数据展示形式类似. 形如: label: content;</p>
<ul>
<li>声明式会导致页面重复内容过多</li>
<li>封装Field组件,通过js去配置数据展示</li>
</ul>
</li>
<li><p>布局类似</p>
<ul>
<li>这是无解的,除非真的很像很像.就可以用mixin解决</li>
</ul>
</li>
</ul>
</li>
<li><p>创建/修改页</p>
<ul>
<li><p>数据形式类似. 形如: label: form</p>
<ul>
<li>声明式同样导致重复内容过多</li>
<li>依然使用封装的Field组件,通过js去配置form.</li>
</ul>
</li>
<li><p>数据验证. 简单点就是能否提交</p>
<ul>
<li>要么逐个验证</li>
<li>要么简单粗暴添加一个canSave的computed.保证数据不为空</li>
</ul>
</li>
</ul>
</li>
</ul>

            <h3>
              <a href="#组件" id="组件" class="heading"></a>组件
            </h3>
          <ul>
<li><p>Table(如上所说) <a href="https://zwingz.github.io/vue-fixed-table/release/demo.html">Demo</a></p>
</li>
<li><p>LoadingBar(顶部的进度条,主要是切换路由时候出现,挂在beforeEach和afterEach中调用, 有异步路由时候建议使用)</p>
</li>
<li><p>Message(消息提示)</p>

            <h4>
              <a href="#实现方式" id="实现方式" class="heading"></a>实现方式
            </h4>
          
      <div class="hljs">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
</pre>
              </td>
              <td class="code"><pre>  1. 使用createElement创建dom元素,并且把message组件挂载上去即可,不过需要使用到vue完整版
  2. 将组件挂在到App.vue中,并使用vuex管理其状态. 可以在初次调用message时候才注册store</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    </li>
<li><p>Modal 没什么好说.哪里用到就声明一个Modal.</p>
</li>
<li><p>Confirm(确认式提升,与message一样的实现方式)</p>
</li>
<li><p>AsyncButton(会触发异步操作的按钮,监听异步请求的路由,当请求未结束时button处于loading态.)</p>
</li>
<li><p>AutoCompleteInput(带搜索建议的Input. 可以封装多装搜索框)</p>
</li>
<li><p>Panel (可收缩面包.很简单)</p>
</li>
<li><p>Field (label: content\form; 类型展示组件)</p>
</li>
<li><p>Pagination (分页,很简单)</p>
</li>
<li><p>Tree (树, 使用递归组件即可, 如果要做节点多选, 管理选择状态会比较麻烦.)</p>
</li>
<li><p>Select, Checkbox, Radio, Switch (自定义组件v-model即可,简单)</p>
</li>
<li><p>Spin (请求时间很长的时候, 可以弹出model,并构建一个假的进度条. 上传文件的时候也能用到,当然这时候的进度是真实的.通过onprogress获取)</p>
</li>
<li><p>BackToTop (回到顶部, 加个贝塞尔动画就好了)</p>
</li>
<li><p>Scroller (自定义非原生滚动条, 建议直接用css来设置原生scroll样式.目前应该firefox不支持设置原生滚动条样式)</p>
</li>
<li><p>Img (hover时候出现蒙层.点击时候出现查看器)</p>
</li>
</ul>

            <h3>
              <a href="#建议" id="建议" class="heading"></a>建议
            </h3>
          <ol>
<li><p>如果对组件进行for命令,必须加上:key,这是官方指定.
 但对于原生dom进行for循环时候.其实可以不加:key,或者使用index作为key. 
 一旦设置了key,只有key得值不一样,会直接销毁重建dom. 那么用index作为key的话,则只会更新dom而不会销毁重建</p>
</li>
<li><p>任何通过addEventListeners添加的监听事件,销毁时最好使用removeEventListeners给去掉</p>
</li>
<li><p>如果不需要运行时构建,可以在webpack中指定使用vue.runtime.js, 会剩了几十k体积</p>
</li>
<li><p>sass-loader前再加一层sass-resources-loader可以将一些变量或者方法全局引入,那就不用到处import了.</p>
</li>
</ol>

      <div class="hljs">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
</pre>
              </td>
              <td class="code"><pre>    {
        loader: &#39;sass-resources-loader&#39;,
        options: {
            resources: [path.resolve(__dirname, &#39;..&#x2F;src&#x2F;sass&#x2F;variable.scss&#39;)]
        }
    }</pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    
            <h3>
              <a href="#安利" id="安利" class="heading"></a>安利
            </h3>
          <p><a href="https://fundebug.com/">Fundebug</a></p>
<p><a href="https://www.easy-mock.com/">EasyMock</a></p>
<p><a href="http://apizza.cc/account">Apizza</a></p>

            <h1>
              <a href="#<strong>全剧终</strong>" id="<strong>全剧终</strong>" class="heading"></a><strong>全剧终</strong>
            </h1>
          ]]></description><link>http://zwingz.github.io/posts/275254986.html</link><guid isPermaLink="false">275254986</guid><category><![CDATA[front-end]]></category><category><![CDATA[js]]></category><category><![CDATA[vue]]></category><category><![CDATA[webpack]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Mon, 20 Nov 2017 07:02:07 GMT</pubDate></item></channel></rss>