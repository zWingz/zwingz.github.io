<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[zWing]]></title><description><![CDATA[Just a blog.]]></description><link>http://zwingz.github.io</link><image><url>http://zwingz.github.io/favicon.ico</url><title>zWing</title><link>http://zwingz.github.io</link></image><generator>RSS for Node</generator><lastBuildDate>Sun, 27 Jan 2019 13:43:25 GMT</lastBuildDate><atom:link href="http://zwingz.github.io/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 27 Jan 2019 13:43:25 GMT</pubDate><webMaster><![CDATA[zWingz]]></webMaster><item><title><![CDATA[2018，不普通的一年]]></title><description><![CDATA[<p>2018对我个人来说是很重要的一年</p>
<p>在4月份, 我辞去了一份965的工作</p>
<p>跟着前同事去了一家9:30 - 8:00 大小周的创业公司</p>

    <h2 id="%E8%BF%87%E5%8E%BB%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88" class="heading">
      <a href="#%E8%BF%87%E5%8E%BB%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88" class="heading-anchor"></a>过去，我学到了什么
    </h2>
  <p>记得我是2015年开始入门前端，当时我掌握的只有<code>java</code>那一套<code>MVC</code>。</p>
<p>后来一次偶然机会接到了朋友的一次外包，担任前端开发，虽然项目中途腰斩，但是让我正式走上了前端的道路。</p>
<p>那么2015-2017我有哪些成长？</p>

    <h3 id="2015" class="heading">
      <a href="#2015" class="heading-anchor"></a>2015
    </h3>
  <p>当时我从一本《JavaScript DOM 编程艺术》入门，到入职上一家公司(A)，成为实习生。</p>
<p>这一年，我掌握的只是普通的<code>javascript</code> /<code>html</code>/ <code>css</code></p>
<p>还记得当时第一次做项目就被缓存给坑了</p>
<p>那时候大概只是一个页面仔</p>

    <h3 id="2016" class="heading">
      <a href="#2016" class="heading-anchor"></a>2016
    </h3>
  <p>那时我正拿着<code>jQuery</code> 写代码写的风生水起</p>
<p>但是那时我并不知道<code>gulp</code> 怎么用、不知道<code>browserify</code>这个东西原来可以打包代码。</p>
<p>仿佛就像那位老大爷一样，<code>jQuery</code>一把梭。</p>
<p>到了年底，有机会接触新项目，我毅然选择了<code>vue@1.x</code>。</p>
<p>自从写<code>vue</code>，才知道了什么叫<code>spa</code>，仿佛打开了新的大门。</p>

    <h3 id="2017" class="heading">
      <a href="#2017" class="heading-anchor"></a>2017
    </h3>
  <p>2017可以说全年都在写<code>vue</code>了</p>
<p>从用<code>ElementUI</code>到自己的一套<code>UI</code>框架，也能说熟练的使用<code>vue</code></p>
<p>但是我不敢说精通，现在回想起，也觉得当时写的都是小儿科东西。</p>
<p>这套不怎么样<code>UI</code>中，在当时也是能让我引以为傲。</p>
<p>毕竟当时写出了自我感觉良好的一个<a href="https://github.com/zWingz/vue-fixed-table">Table</a>组件。</p>
<p>不过现在看起来的确不怎么样，毕竟<code>github</code>上面大神太多了。</p>
<p>15年到17年这段时期，我觉得我就像是从一个门外汉逐步走到了门前，并且跨步走了进去。</p>
<p>当初选择<code>vue</code>真的是一个很重要的决定。</p>
<p>写过一篇<code>vue</code><a href="https://zwing.site/posts/275254986.html">总结</a>，虽说不是什么干货，但对我日后开发还是有一定帮助。</p>
<p>如果没有这样做，我可能会一直都跟<code>jquery</code>和<code>django</code>打交道。(是的，有段时间我还专门写后端代码。)</p>

    <h2 id="2018%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88" class="heading">
      <a href="#2018%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88" class="heading-anchor"></a>2018，我学到了什么
    </h2>
  <p>2018年后回来，同时随着手头上那个关键的项目逐步完成，我就提了辞职。</p>
<p>还记得后一个月，leader还让我们组执行<code>996</code>，弄得很忙的样子给领导看。</p>
<p>现在看起来还真的有点可笑。</p>
<p>刚到新公司，技术只有两个，我负责前端，我领导负责后端以及运维。</p>
<p>我可以为所欲为，因为我来的目的就是像搞些新的东西。</p>

    <h3 id="%E5%B0%8F%E7%A8%8B%E5%BA%8F" class="heading">
      <a href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F" class="heading-anchor"></a>小程序
    </h3>
  <p>的确，刚到的任务便是写小程序，一个崭新的东西。</p>
<p>这东西不难，上手简单。</p>
<p>后面<a href="https://github.com/Meituan-Dianping/mpvue">mpvue</a>出来了，我也去尝了下鲜，直到现在还在维护，但是如果再给我选，我会选择原生。</p>
<p>虽然原生有点啰嗦，但其实配一个<code>gulp</code>构建流程，开发起来还是挺顺手的，而且不会有莫名的坑，可知道<code>mpvue</code>目前还有几个<code>issues</code> 始终还未得到解决。</p>
<p>到后面更多的小程序框架出来了</p>
<p>比如：</p>
<ul>
<li><a href="https://github.com/NervJS/taro">taro</a></li>
<li><a href="https://github.com/RubyLouvre/nanachi">nanachi</a></li>
<li><a href="https://github.com/didi/mpx">mpx</a></li>
<li><a href="https://github.com/Tencent/omi">omi</a></li>
<li><a href="https://tencent.github.io/wepy/">wepy</a></li>
<li>....</li>
</ul>
<p>等等，真的很多。</p>
<p>但目前我看好的是<code>taro</code>，也许以后有机会，我会选择使用。</p>

    <h3 id="react" class="heading">
      <a href="#react" class="heading-anchor"></a>React
    </h3>
  <p>不错，今年我进入了<code>React</code>阵营。</p>
<p>刚开始写的时候，其实我也很烦，</p>
<p>总是觉得明明在<code>vue</code>上很简单的东西，到了<code>react</code>怎么就这么绕。</p>
<p>就比如<code>v-model</code>，在<code>react</code>上面先要写一个<code>state</code>，然后写一个<code>onChange</code>。</p>
<p>写了几个项目，逐步上手后，发自内心的一句：真香~。</p>
<p>的确，写<code>react</code>就像在写原生<code>javascript</code>。</p>
<p>在开发期间，逐步使用自己的组件替换掉<code>antd</code>（的确是一个优秀的<code>UI</code>框架），</p>
<p>许多组件也是参考<code>antd</code>源码，自己推敲出来的。</p>
<p>当然，我也把自己的几个自我感觉良好的放在了<code>github</code>上面</p>
<ul>
<li><a href="https://github.com/zWingz/react-table">react-table</a>: 一个表格组件，可固定表头以及两侧</li>
<li><a href="https://github.com/zWingz/react-image">react-image</a>：一个图片浏览器</li>
<li><a href="https://github.com/zWingz/react-form-wrapper">react-form-wrapper</a>：一个<code>Form</code>表单封装</li>
</ul>
<p>其实在开发着三个库的时候，我学到的更多是怎么去发布和管理一个开源库</p>
<ul>
<li><a href="https://github.com/pedronauck/docz">docz</a>: 为我的组件编写稳定</li>
<li><a href="https://jestjs.io/">jest</a>: 编写测试，写了一篇<a href="https://zwing.site/posts/383783892.html">小文</a></li>
<li><a href="https://rollupjs.org/">rollup</a>: 打包组件</li>
</ul>

    <h3 id="typescript" class="heading">
      <a href="#typescript" class="heading-anchor"></a>Typescript
    </h3>
  <p>对于<code>ts</code>，一开始我跟朋友闲聊我都是说<code>ts</code>很啰嗦，每次都要写一堆类型。</p>
<p>后面等我自己用了后，又从内心发出一句：真香~。</p>
<p>后面我把手上的项目全部用<code>ts</code>重构了一遍。</p>
<p>他真的太好用了。</p>

    <h3 id="%E6%8A%80%E6%9C%AF%E6%A0%88%E5%A4%96%E4%B8%9C%E8%A5%BF" class="heading">
      <a href="#%E6%8A%80%E6%9C%AF%E6%A0%88%E5%A4%96%E4%B8%9C%E8%A5%BF" class="heading-anchor"></a>技术栈外东西
    </h3>
  <p>技术栈外的东西，便是写了些工具库，插件等等。</p>
<p>可以用来掌握日常工作中用不到的技能。</p>

    <h4 id="acyort" class="heading">
      <a href="#acyort" class="heading-anchor"></a>Acyort
    </h4>
  <p><a href="https://acyort.com/">acyort</a>是一位前同事开发的基于<code>githus issues</code>的博客系统，本博客也是用它来搭建。</p>
<p>最近发布了<code>acyort@3.x</code>，属于一个<code>breaking</code>，旧的构建流程已经不适用。</p>
<p>新的版本是基于插件以及构建流程来完成建站，不单单限于<code>github issues</code>，可以说更强大了。</p>
<p>于是我便在旧版的基础上，为新版本编写插件。</p>
<p><a href="https://github.com/zWingz/acyort-donob-plugins">acyort-donob-plugins</a></p>
<ul>
<li><p>Acyort-plugin-fetch-issues: 用于拉取<code>issues</code>插件，提供数据来源</p>
</li>
<li><p>Acyort-donob-renderer: 一个预处理以及渲染插件，用于处理数据</p>
</li>
<li><p>Acyort-plugin-rss: rss 插件，生成<code>rss</code>。</p>
</li>
<li><p>Acyort-templates-donob-plus: 主题目标，在原有基础上加了些东西。</p>
</li>
<li><p>Acyort-plugin-gh-pages: 用于发布到<code>gh-pages</code>插件。</p>
</li>
<li><p>Acyort-plugin-remark: 即将开发，使用<a href="https://github.com/remarkjs/remark">remark</a>来提供<code>markdown</code>支持</p>
</li>
</ul>
<p>开发这一系列插件，对我个人来说也是有不少提升。</p>
<p>其实在很早之前我便想找机会写下<code>node</code>，因此这次便是一次很好的练手机会。</p>
<p>练手之余还能为自己的博客做贡献，还是挺满足的~。</p>
<p>这个项目也刚好能用上<a href="https://github.com/lerna/lerna">lerna</a>，也是一个很了不起的工具。</p>

    <h4 id="picgo" class="heading">
      <a href="#picgo" class="heading-anchor"></a>Picgo
    </h4>
  <p><a href="https://github.com/Molunerfinn/PicGo">picgo</a>是一个用来管理图床的<code>electron</code> 应用。</p>
<p>内置提供多个<code>Uploader</code>，比如: <code>github</code>, <code>sm.sm</code>, <code>七牛</code>等。</p>
<p>早些时间，七牛云关掉了测试域名，可以说导致不少人的图库都挂掉了，我也不例外。</p>
<p>刚好发现<code>picgo</code>，但他仅支持上传，不支持同步删除等管理。</p>
<p>于是便写了<a href="https://github.com/zWingz/picgo-plugin-github-plus">picgo-plugin-github-plus</a>，用来提供图片的删除以及在线同步等。</p>
<p>这能让我写博客更加方便。</p>

    <h4 id="docker" class="heading">
      <a href="#docker" class="heading-anchor"></a>Docker
    </h4>
  <p>不错，就是<code>docker</code>，这是一个很了不起的工具。</p>
<p>至于为什么我会接触到，单纯是因为刚开始时候业务不多，我便跟着 Leader 搞搞<code>docker</code>的东西。</p>
<p>写过一篇<a href="https://zwing.site/posts/346031510.html">小文</a>，使用<code>docker</code>+<code>fabric</code>来部署项目。</p>
<p>其实是可以直接用<code>CI</code>部署。</p>

    <h4 id="more" class="heading">
      <a href="#more" class="heading-anchor"></a>More...
    </h4>
  <p>其实在开发一个库过程中，免不了遇到些自己想不清楚的东西。</p>
<p>这时候我会选择参考一些已有的库，看他们的源码。</p>
<p>并不需要完整的阅读一遍，有时候我更多的是看他们用了哪些依赖，用来做了些什么。</p>
<p>这能让我知道茫茫轮子中，有多少可以为我所用，哪些轮子可以解决哪些问题。</p>
<p>日后当我遇到了问题，可以从容的知道有哪些方法解决。</p>
<p>当遇到一些新奇而且代码简单的库，不妨深入阅读，这也是提升自己水平的一个好方法。</p>
<p>比如:</p>
<ul>
<li>除了<code>eslint</code>外，其实<a href="https://github.com/xojs/xo">xo</a>这个库可以更高效的为我们完成语法检测。</li>
<li>除了<code>jest</code>,<code>mocha</code>,<code>karma</code>外, <a href="https://github.com/avajs/ava">ava</a>这个测试框架也是不错的选择。</li>
<li>除了自己搭<code>webpack</code>，其实<a href="https://github.com/egoist/poi">poi</a>和<a href="https://github.com/egoist/bili">bili</a>能更快为我们完成打包。</li>
<li><a href="https://saojs.org/">SAO.js</a>可以有效制作自己熟悉的开发项目模板, <a href="https://github.com/zWingz/sao-rc-ts-scaffold">sao-rc-rs-scaffold</a>这是我的组件项目模板。</li>
<li><a href="https://github.com/webpro/release-it">rrelease-it</a>, <a href="https://github.com/intuit/auto">auto</a>,<a href="https://github.com/sindresorhus/np">np</a>这些可以有效地为我们管理项目版本</li>
<li><a href="https://github.com/commitizen/cz-cli">cz-cli</a>可以为我们规范我们的<code>git commit message</code>, 同时配合<a href="https://github.com/commitizen/cz-conventional-changelog">cz-conventional-changelog</a>也能更好的为我们生成<code>changelog</code></li>
<li>...</li>
</ul>
<p>有时候业务都是三点一线，来来去去都是那些东西，不妨多去了解下业务外的东西，也许收获更多。</p>

    <h3 id="%E6%8A%80%E6%9C%AF%E5%A4%96%E7%9A%84" class="heading">
      <a href="#%E6%8A%80%E6%9C%AF%E5%A4%96%E7%9A%84" class="heading-anchor"></a>技术外的
    </h3>
  <p>一年365天，也不可能说每天都在码字，总会一些让自己记忆深刻的事情。</p>

    <h4 id="%E9%A9%BE%E7%85%A7" class="heading">
      <a href="#%E9%A9%BE%E7%85%A7" class="heading-anchor"></a>驾照
    </h4>
  <p>今年年初拿了驾照，甚是开心。</p>

    <h4 id="switch" class="heading">
      <a href="#switch" class="heading-anchor"></a>Switch
    </h4>
  <p>今年入手了一台<code>Switch</code>，玩过了2017年度游戏<code>塞尔达传说</code>。这的确是一个很棒的游戏，以至于现在跟别人说起来也是津津有味。</p>

    <h4 id="%E7%8C%9B%E7%A6%BD1060%E6%98%BE%E5%8D%A1" class="heading">
      <a href="#%E7%8C%9B%E7%A6%BD1060%E6%98%BE%E5%8D%A1" class="heading-anchor"></a>猛禽1060显卡
    </h4>
  <p>2017年618配了台电脑，但是当时遇到了矿潮，显卡价格被炒高，一直空着显卡，知道今年2月份才在咸鱼入了一张<code>ROG1060</code>信仰显卡。是真的贵，不过不贵就不叫<strong>信仰</strong>了。</p>

    <h4 id="%E7%83%98%E7%84%99" class="heading">
      <a href="#%E7%83%98%E7%84%99" class="heading-anchor"></a>烘焙
    </h4>
  <p>17年双11买了台烤箱，算是入了烘焙的门。</p>
<p>其实烘焙这个活，不好干，费时费心。</p>
<p>制作一个钟，烘烤一个钟，享受五分钟。</p>
<p>但是出炉那一刻真是满满的成就感。</p>
<p>嗯，2018做了<a href="https://zwing.site/posts/310330786.html">戚风蛋糕</a>，做了<a href="https://zwing.site/posts/308242286.html">蛋挞</a>，做了芒果班戟，更多的是做吐司，饼干等。</p>
<p>希望2019能做更多想做的东西。</p>

    <h4 id="%E7%94%B5%E8%A7%86%E5%89%A7" class="heading">
      <a href="#%E7%94%B5%E8%A7%86%E5%89%A7" class="heading-anchor"></a>电视剧
    </h4>
  <p>平常只看港剧的我，在2018竟然追了延禧攻略，不过看起来还是挺爽。</p>
<p>今年1月份看了琅琊榜，发现更好看，现在二刷中。</p>

    <h4 id="%E5%8A%A8%E7%94%BB" class="heading">
      <a href="#%E5%8A%A8%E7%94%BB" class="heading-anchor"></a>动画
    </h4>
  <p>2018看了进击的巨人和东京搜查官，中规中矩，还行。</p>

    <h3 id="%E6%80%BB%E7%BB%93" class="heading">
      <a href="#%E6%80%BB%E7%BB%93" class="heading-anchor"></a>总结
    </h3>
  <p>总的来说，这一年我算是进了一大步。</p>

    <h2 id="2019%E6%88%91%E8%A6%81%E6%80%8E%E4%B9%88%E8%BF%87" class="heading">
      <a href="#2019%E6%88%91%E8%A6%81%E6%80%8E%E4%B9%88%E8%BF%87" class="heading-anchor"></a>2019，我要怎么过
    </h2>
  
    <h3 id="%E5%B7%A5%E4%BD%9C" class="heading">
      <a href="#%E5%B7%A5%E4%BD%9C" class="heading-anchor"></a>工作
    </h3>
  <p>如无意外，今年是准备再跳一次，只是有点舍不得领导。</p>
<p>虽然他不搞前端，但是在其他方面，的确教会我很多东西。</p>
<p>谈技术，谈生活。</p>
<p>好像有什么不懂得跟他说，他都会能回答上些什么。</p>

    <h3 id="%E6%8A%80%E6%9C%AF" class="heading">
      <a href="#%E6%8A%80%E6%9C%AF" class="heading-anchor"></a>技术
    </h3>
  <p>技术方面，今年希望更致力于开源项目，接触更多方面的东西。</p>
<p>比如:</p>
<ul>
<li>electron</li>
<li>node</li>
<li>Native</li>
<li>Server</li>
</ul>
<p>今年听说<code>vue</code>会发布<code>3.0</code>版本，我是很期待这一版本，希望它能更好。</p>

    <h3 id="%E7%94%9F%E6%B4%BB" class="heading">
      <a href="#%E7%94%9F%E6%B4%BB" class="heading-anchor"></a>生活
    </h3>
  <ul>
<li><p>重拾跑步吧，当年可是一周会跑好几趟，现在年纪大了，更加应该多些运动。</p>
</li>
<li><p>在烘焙路上跟进一步。</p>
</li>
<li><p>继续在保证技术深度情况下扩展自己的技术广度，从前端到后端，从执行到思考，从做技术到做管理。</p>
</li>
</ul>
<p>希望2019也是不普通的一年</p>
]]></description><link>http://zwingz.github.io/posts/403552116.html</link><guid isPermaLink="false">403552116</guid><category><![CDATA[生活]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Sun, 27 Jan 2019 13:40:58 GMT</pubDate></item><item><title><![CDATA[使用jest+enzyme测试react组件]]></title><description><![CDATA[
    <h2 id="%E5%89%8D%E8%A8%80" class="heading">
      <a href="#%E5%89%8D%E8%A8%80" class="heading-anchor"></a>前言
    </h2>
  <p>最近第一次给一个项目写一个完整的测试流程, 也算是我第一次写完整的测试.
于是记一下整个测试流程
<a href="https://github.com/zWingz/react-image">项目地址</a>
目前项目使用的测试框架是主流的<code>jest</code>+<code>enzyme</code></p>

    <h2 id="%E4%BE%9D%E8%B5%96" class="heading">
      <a href="#%E4%BE%9D%E8%B5%96" class="heading-anchor"></a>依赖
    </h2>
  
    <h3 id="%E5%BF%85%E8%A6%81%E4%BE%9D%E8%B5%96" class="heading">
      <a href="#%E5%BF%85%E8%A6%81%E4%BE%9D%E8%B5%96" class="heading-anchor"></a>必要依赖
    </h3>
  <ul>
<li>Jest</li>
<li>enzyme</li>
<li>enzyme-adapter-react-16</li>
</ul>

    <h3 id="%E6%8C%89%E9%9C%80" class="heading">
      <a href="#%E6%8C%89%E9%9C%80" class="heading-anchor"></a>按需
    </h3>
  <ul>
<li>如果使用<code>babel</code>，则需要<code>babel-jest</code></li>
<li>如果使用<code>typescript</code>， 则需要<code>ts-jest</code></li>
</ul>

    <h2 id="jest-%E9%85%8D%E7%BD%AE" class="heading">
      <a href="#jest-%E9%85%8D%E7%BD%AE" class="heading-anchor"></a>Jest 配置
    </h2>
  <p>起初项目使用<code>babel</code>进行编译，后面统一转成了<code>ts</code></p>

      <div class="hljs json code">
        <pre><span class="hljs-string">"jest"</span>: {
    <span class="hljs-string">"moduleNameMapper"</span>: {
      <span class="hljs-string">"\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|scss)$"</span>:<span class="hljs-string">"&lt;rootDir&gt;/test/utils.ts"</span>
    },
    <span class="hljs-string">"moduleFileExtensions"</span>: [
      <span class="hljs-string">"ts"</span>,
      <span class="hljs-string">"tsx"</span>,
      <span class="hljs-string">"js"</span>
    ],
    <span class="hljs-string">"setupTestFrameworkScriptFile"</span>: <span class="hljs-string">"&lt;rootDir&gt;/test/setup.ts"</span>,
    <span class="hljs-string">"collectCoverageFrom"</span>: [
      <span class="hljs-string">"src/**/*.{ts,tsx}"</span>
    ],
    <span class="hljs-string">"coverageDirectory"</span>: <span class="hljs-string">"./coverage/"</span>,
    <span class="hljs-string">"collectCoverage"</span>: true,
    <span class="hljs-string">"transform"</span>: {
      <span class="hljs-string">"^.+\\.(ts|tsx)$"</span>: <span class="hljs-string">"ts-jest"</span>
    },
    <span class="hljs-string">"testMatch"</span>: [
      <span class="hljs-string">"**/__test__/*.(ts|tsx)"</span>
    ]
  }</pre>
      </div>
    <p>如果使用<code>babel</code>的话, 只要将<code>ts</code>转成<code>js</code>, <code>ts-jest</code>转成<code>babel-jest</code>即可。</p>

    <h3 id="modulenamemapper" class="heading">
      <a href="#modulenamemapper" class="heading-anchor"></a>moduleNameMapper
    </h3>
  <p>用来<code>mock</code>一些额外<code>module</code>, 比如<code>sass</code>, <code>jpg</code>等等.</p>

      <div class="hljs typescript code">
        <pre><span class="hljs-comment">// /test/utils.ts</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = <span class="hljs-string">'test-file-stub'</span></pre>
      </div>
    
    <h3 id="setuptestframeworkscriptfile" class="heading">
      <a href="#setuptestframeworkscriptfile" class="heading-anchor"></a>setupTestFrameworkScriptFile
    </h3>
  <blockquote>
<p>The path to a module that runs some code to configure or set up the testing framework before each test. </p>
</blockquote>
<p>可以用来初始化<code>test</code>配置, 在这里需要使用<code>enzyme-adapter</code></p>

      <div class="hljs typescript code">
        <pre><span class="hljs-comment">// /test/setup.ts</span>
<span class="hljs-keyword">import</span> { configure } <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactSixteenAdapter <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme-adapter-react-16'</span>

configure({ <span class="hljs-attr">adapter</span>: <span class="hljs-keyword">new</span> ReactSixteenAdapter() })
</pre>
      </div>
    
    <h3 id="collectcoveragefrom" class="heading">
      <a href="#collectcoveragefrom" class="heading-anchor"></a>collectCoverageFrom
    </h3>
  <p>需要测试覆盖率的文件</p>

    <h3 id="coveragedirectory" class="heading">
      <a href="#coveragedirectory" class="heading-anchor"></a>coverageDirectory
    </h3>
  <p>覆盖率输出目录</p>

    <h3 id="transform" class="heading">
      <a href="#transform" class="heading-anchor"></a>transform
    </h3>
  <blockquote>
<p>A map from regular expressions to paths to transformers. A transformer is a module that provides a synchronous function for transforming source files</p>
</blockquote>
<p>跟<code>webpack-loader</code>类似</p>

    <h3 id="testmatch" class="heading">
      <a href="#testmatch" class="heading-anchor"></a>testMatch
    </h3>
  <blockquote>
<p>The glob patterns Jest uses to detect test files.</p>
</blockquote>
<p>测试文件匹配规则, 如果跟官方不同, 则修改此值.</p>

    <h2 id="enzyme-%E4%BD%BF%E7%94%A8" class="heading">
      <a href="#enzyme-%E4%BD%BF%E7%94%A8" class="heading-anchor"></a>Enzyme 使用
    </h2>
  <p><a href="https://airbnb.io/enzyme/">官方文档</a></p>

    <h3 id="%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" class="heading">
      <a href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" class="heading-anchor"></a>简单介绍
    </h3>
  <p>其实<code>enzyme</code>上手挺简单的, 它有三个<code>API</code></p>
<p>包括<code>shallow</code>、<code>mount</code>和<code>render</code>, 其中<code>shallow</code>和<code>mount</code>是常用的</p>
<p>他们区别是</p>
<ul>
<li><code>shallow</code>: 只会渲染顶级组件, 而子组件不会渲染, 渲染结果是一颗<code>react</code>树, 效率最高</li>
<li><code>mount</code>: 会渲染整个组件, 包括子组件, 如果需要深入组件内部测试, 则需要使用<code>mount</code></li>
<li><code>render</code>: 直接选择普通的<code>html</code>结构.</li>
</ul>
<p><code>shallow</code>和<code>mount</code>得到结果是一个<code>ReactWrapper</code>对象, 可以进行多种操作, 包括<code>find()</code>、<code>prop()</code>、<code>instance()</code>等。</p>

    <h3 id="%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" class="heading">
      <a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" class="heading-anchor"></a>基本使用
    </h3>
  
      <div class="hljs typescript code">
        <pre><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { shallow, mount } <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme'</span>
<span class="hljs-keyword">import</span> MyComponent <span class="hljs-keyword">from</span> <span class="hljs-string">'../MyComponent'</span>
<span class="hljs-keyword">import</span> ChildComponent <span class="hljs-keyword">from</span> <span class="hljs-string">'../ChildComponent'</span>

describt(<span class="hljs-string">'测试xxxxx'</span>, () =&gt; {
    it(<span class="hljs-string">'组件state以及渲染情况'</span>, () =&gt; {
        const <span class="hljs-keyword">wrapper</span> = shallow(&lt;MyComponent /&gt;)
        expect(<span class="hljs-keyword">wrapper</span>.state().msg).toEqual(<span class="hljs-string">'test msg'</span>)
        expect(<span class="hljs-keyword">wrapper</span>.find(<span class="hljs-string">'#childId'</span>)).toHaveLength(<span class="hljs-number">1</span>) // 测试是否包含某个`element`
        expect(<span class="hljs-keyword">wrapper</span>.find(ChildComponent)).toHaveLength(<span class="hljs-number">1</span>) // 测试是否包含某个子组件
    })
    it(<span class="hljs-string">'触发事件'</span>, () =&gt; {
        const click = jest.fn()
        const <span class="hljs-keyword">wrapper</span> = shallow(&lt;MyComponent onClick={click}/&gt;)
        // 触发#triggerClickElement的click事件
        <span class="hljs-keyword">wrapper</span>.find(<span class="hljs-string">'#triggerClickElement'</span>).simulate(<span class="hljs-string">'click'</span>)
        // 判断click事件是否被触发
        expect(click).toBeCalledTimes(<span class="hljs-number">1</span>)
    })
    // 测试函数调用
    // 默认该函数声明方式通过<span class="hljs-keyword">class</span>.<span class="hljs-keyword">method</span>声明
    // <span class="hljs-keyword">class</span> MyComponent{
    //   someMethod() {} 
    // }
    it(<span class="hljs-string">'测试函数调用'</span>, () =&gt; {
        const spy = jest.spyOn(MyComponent.prototype, <span class="hljs-string">'someMethod'</span>)
        const <span class="hljs-keyword">wrapper</span> = shallow(&lt;MyComponent /&gt;)
        // 暂且认为组件挂载时会调用`someMethod`
        // 在此测试是否正确调用
        expect(spy).toBeCalledTimes(<span class="hljs-number">1</span>)
    })
    // 但是由于react需要绑定this
    // 所以一般会这样声明
    // <span class="hljs-keyword">class</span> MyComponent {
    //   someMethod = () =&gt; {}    
    // }
    // 这时候通过babel或者typescript编译后
    // 会变成类似
    // <span class="hljs-keyword">class</span> MyComponent{
    //   constructor() {
    //     this.someMethod = () =&gt; {}     
    //   }    
    // }
    // 这时候someMethod不属于MyComponent.prototype
    // 所以要改变测试方式
    it(<span class="hljs-string">'测试函数调用'</span>, () =&gt; {
        const <span class="hljs-keyword">wrapper</span> = shallow(&lt;MyComponent /&gt;)
        const ins = <span class="hljs-keyword">wrapper</span>.instance()
        const spy = jest.spyOn(ins, <span class="hljs-string">'someMethod'</span>)
        <span class="hljs-keyword">wrapper</span>.<span class="hljs-keyword">update</span>()
          ins.forceUpdate()
        expect(spy).toBeCalledTimes(<span class="hljs-number">1</span>)
    })
    it(<span class="hljs-string">'触发特定事件, 并传递参数'</span>, () =&gt; {
        // 如果要触发特定事件, 比如mousemove, keyup等等
        // 可以通过构造自定义事件, 并且使用dispatchEvent来触发
        const <span class="hljs-keyword">wrapper</span> = shallow(&lt;MyComponent /&gt;)
        const element = <span class="hljs-keyword">wrapper</span>.find(<span class="hljs-string">'.some-element'</span>)
        const event = <span class="hljs-built_in">new</span> MouseEvent(<span class="hljs-string">'mousemove'</span>, {
            clientX: <span class="hljs-number">100</span>,
            clientY: <span class="hljs-number">100</span>
        })
        element.getDOMNode().dispatchEvent(event)
        expect(<span class="hljs-keyword">wrapper</span>.state.x).toEqueal(<span class="hljs-number">100</span>)
    })
})</pre>
      </div>
    <p>其实<code>enzyme</code>常用的api大概就是几个, 按照本项目中用到的, </p>
<ul>
<li>state</li>
<li>find</li>
<li>prop</li>
<li>simulate</li>
</ul>

    <h2 id="%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95" class="heading">
      <a href="#%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95" class="heading-anchor"></a>进行测试
    </h2>
  <p>编写完<code>test case</code>后, 只要调用<code>jest</code>即可进行测试, 同时会输出覆盖率
如果带上<code>--watch</code>则可以监听文件改动并进行测试</p>

    <h2 id="%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87" class="heading">
      <a href="#%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87" class="heading-anchor"></a>上传测试覆盖率
    </h2>
  <p>目前使用<code>Codecov</code>来管理测试覆盖率
如果在本地上传, 则需要带上<code>token</code>, 如果通过<code>travisCi</code>, 则不需要, 直接调用<code>codecov</code>即可。</p>

    <h2 id="%E5%AE%8C%E7%BB%93" class="heading">
      <a href="#%E5%AE%8C%E7%BB%93" class="heading-anchor"></a>完结
    </h2>
  <p>至此， 整套<code>jest</code>+<code>enzyme</code>测试流程已经跑完.
目前看来没有用高更深的测试功能, 比如说<code>jsdom</code>, <code>enzyme.render</code>等</p>
]]></description><link>http://zwingz.github.io/posts/383783892.html</link><guid isPermaLink="false">383783892</guid><category><![CDATA[front-end]]></category><category><![CDATA[react]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Fri, 23 Nov 2018 11:07:18 GMT</pubDate></item><item><title><![CDATA[多package下babel编译问题]]></title><description><![CDATA[
    <h2 id="%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF" class="heading">
      <a href="#%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF" class="heading-anchor"></a>项目背景
    </h2>
  <p>之前一直使用<code>typescript</code> + <code>babel</code> 编译项目</p>
<p><code>typescript</code>作用只是单纯用来做强类型检查, <code>babel</code>则真正用来编译代码.</p>

      <div class="hljs json code">
        <pre>  {
     <span class="hljs-attr">"target"</span>: <span class="hljs-string">"exnext"</span>
  }</pre>
      </div>
    <p>偶然一次机会, 发现编译后的部分代码并没有编译<code>object-rest-spread</code>
而这部分代码全都在一个子目录下</p>
<p>由于我的项目使用了<code>git-submodules</code>来管理组件, 所以该组件目录下带有<code>package.json</code>文件</p>
<p>恰好这部分文件只经过了<code>typescript</code>的编译, 而没有经过<code>babel</code></p>
<p>其他<code>Page</code>都正确的被<code>babel</code>编译, 不存在问题.</p>
<p>于是想起是否子目录下的文件不被<code>babel</code>编译, 看了下官方文档, 的确有相关的描述.</p>

    <h2 id="%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0" class="heading">
      <a href="#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0" class="heading-anchor"></a>问题原因
    </h2>
  <p>当项目目录中含有多个<code>package.json</code>时候, 原有的<code>.babelrc</code>已经不再适用</p>
<p><img src="https://user-images.githubusercontent.com/13031838/48480504-a09f9300-e845-11e8-9edc-3f42bb145c2f.png" alt="image">.</p>
<p>这时候经过<code>webpack</code>编译
只有<code>src</code>下的文件会被正确编译, <code>sub</code>下的文件不会被<code>babel</code>编译</p>
<p>此时<code>webpack</code>会报错</p>
<p><img src="https://user-images.githubusercontent.com/13031838/48480915-d4c78380-e846-11e8-80e5-b4bc1c518474.png" alt="image"></p>
<p>原因就是这部分文件没有被<code>babel</code>正确编译</p>

    <h2 id="%E4%B8%8A%E8%BF%B0%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" class="heading">
      <a href="#%E4%B8%8A%E8%BF%B0%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" class="heading-anchor"></a>上述问题解决办法
    </h2>
  <p>官方有<a href="https://babeljs.io/docs/en/config-files#project-wide-configuration">详细说明</a></p>
<p>将<code>.babelrc</code>改成<code>babel.config.js</code>, 此时<code>sub</code>下的文件可以被正确编译</p>
<p><img src="https://user-images.githubusercontent.com/13031838/48481024-15270180-e847-11e8-909b-3af7c5a7b209.png" alt="image"></p>
<p>当然, 使用<code>babel.config.js</code>还可以灵活的配置各个<code>package</code>中<code>babel</code>编译规则.
具体的还是请看官方文档</p>
]]></description><link>http://zwingz.github.io/posts/380665113.html</link><guid isPermaLink="false">380665113</guid><category><![CDATA[babel]]></category><category><![CDATA[front-end]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Wed, 14 Nov 2018 11:56:24 GMT</pubDate></item><item><title><![CDATA[使用Fabric+docker部署前端项目]]></title><description><![CDATA[
    <h2 id="%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B" class="heading">
      <a href="#%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B" class="heading-anchor"></a>部署过程
    </h2>
  <ul>
<li>合并<code>develop</code>到<code>master</code></li>
<li><code>push</code>代码</li>
<li>远程服务器<code>pull</code>代码</li>
<li>npm install(如果需要)</li>
<li>npm run test (如果需要)</li>
<li>npm run build</li>
</ul>

    <h2 id="docker%E9%85%8D%E7%BD%AE-%E4%BD%BF%E7%94%A8dockernode%E5%AE%8C%E6%88%90%E7%BC%96%E8%AF%91" class="heading">
      <a href="#docker%E9%85%8D%E7%BD%AE-%E4%BD%BF%E7%94%A8dockernode%E5%AE%8C%E6%88%90%E7%BC%96%E8%AF%91" class="heading-anchor"></a>Docker配置, 使用docker+node完成编译
    </h2>
  <p>使用docker来部署, 则线上不需要有<code>node</code>环境.</p>

    <h3 id="%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96" class="heading">
      <a href="#%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96" class="heading-anchor"></a>使用docker安装依赖
    </h3>
  <ul>
<li>将本地目录映射到<code>docker</code>中</li>
<li>在<code>docker</code>中跑<code>npm</code>命令</li>
</ul>

      <div class="hljs docker code">
        <pre><span class="hljs-meta"># docker-compose.yml</span>
<span class="hljs-symbol">version:</span> <span class="hljs-string">'3'</span>
<span class="hljs-symbol">services:</span>
<span class="hljs-symbol">  depoly:</span>
<span class="hljs-symbol">    container_name:</span> project-container
<span class="hljs-symbol">    image:</span> node:carbon
<span class="hljs-symbol">    working_dir:</span> /project
<span class="hljs-symbol">    volumes:</span>
        - .:/project</pre>
      </div>
    
    <h2 id="shell%E8%84%9A%E6%9C%AC-%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%89%A7%E8%A1%8Cdocker" class="heading">
      <a href="#shell%E8%84%9A%E6%9C%AC-%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%89%A7%E8%A1%8Cdocker" class="heading-anchor"></a>Shell脚本, 更好的执行docker
    </h2>
  
      <div class="hljs bash code">
        <pre><span class="hljs-comment">#!/bin/bash</span>

<span class="hljs-comment"># 判断最近一次提交是否修改过package-lock, 以及node_modules是否为空</span>
<span class="hljs-comment"># 如果是, 则重新执行npm install</span>
package=$(git diff --name-only HEAD~ HEAD | grep <span class="hljs-string">"package-lock.json"</span>)

<span class="hljs-keyword">if</span> [ ! -d <span class="hljs-string">"./node_modules"</span> -o -n <span class="hljs-string">"$package"</span> ]; then
  echo -e <span class="hljs-string">"\n\033[41;37m Install dependence:\033[0m\n "</span>
  <span class="hljs-comment"># 跑docker命令</span>
  docker-compose run --rm depoly npm install
  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">"$?"</span> == <span class="hljs-number">1</span> ]]; then
    echo -e <span class="hljs-string">"\t\033[31m Error in npm install, pleace check your package.json\n\033[0m"</span>
    <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>
  fi
fi;

<span class="hljs-comment"># 执行编译</span>
echo -e <span class="hljs-string">"\n\n\033[41;37m Build... :\033[0m\n "</span>

<span class="hljs-comment"># 跑docker命令</span>
docker-compose run --rm depoly npm run build
<span class="hljs-keyword">if</span> [[ <span class="hljs-string">"$?"</span> == <span class="hljs-number">1</span> ]]; then
  echo -e <span class="hljs-string">"\t\033[31m Error in npm run build \n\033[0m"</span>
  <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">else</span>
  echo -e <span class="hljs-string">"\033[32mBuild Success \033[0m\n"</span>
fi

<span class="hljs-keyword">exit</span> $?</pre>
      </div>
    
    <h2 id="fabric%E4%BD%BF%E7%94%A8-%E6%9B%B4%E5%BF%AB%E7%9A%84%E5%AE%8C%E6%88%90%E9%83%A8%E7%BD%B2" class="heading">
      <a href="#fabric%E4%BD%BF%E7%94%A8-%E6%9B%B4%E5%BF%AB%E7%9A%84%E5%AE%8C%E6%88%90%E9%83%A8%E7%BD%B2" class="heading-anchor"></a>Fabric使用, 更快的完成部署
    </h2>
  
    <h3 id="fabric%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D" class="heading">
      <a href="#fabric%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D" class="heading-anchor"></a>fabric基本介绍
    </h3>
  <p><code>fabric</code>是一个<code>python</code>库, 可以通过<code>ssh</code>在远程服务器执行命令.</p>
<p>它有两个<code>1.0</code>和<code>2.0</code>版本, 其中<code>1.0</code>只支持<code>py2</code>, <code>2.0</code>版本可以支持<code>py2</code>和<code>py3</code>, 而且两个版本的<code>api</code>区别很大, 具体请参考官方文档.</p>
<p>以下所使用的是<code>fabric2.0</code>, 附上<a href="http://docs.fabfile.org/en/2.2/">fabric2.x文档</a></p>

    <h3 id="%E7%94%A8%E9%80%94" class="heading">
      <a href="#%E7%94%A8%E9%80%94" class="heading-anchor"></a>用途
    </h3>
  <p>可以利用它来<code>pull</code>代码, 并执行代码编译</p>
<p>同时, 线上一般只拉<code>master</code>分支, 所以<code>fabric</code>也能帮助我们在本地合并到<code>master</code>分支后<code>push</code>到<code>git</code>上</p>

    <h3 id="%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="heading">
      <a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="heading-anchor"></a>配置文件
    </h3>
  
      <div class="hljs python code">
        <pre><span class="hljs-keyword">from</span> fabric <span class="hljs-keyword">import</span> Connection
<span class="hljs-keyword">from</span> invoke <span class="hljs-keyword">import</span> task

c = Connection(host=<span class="hljs-string">'server_name'</span>)

<span class="hljs-comment"># 制定task</span>
<span class="hljs-comment"># 可以通过fab depoly 调用</span>
<span class="hljs-meta">@task</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">depoly</span><span class="hljs-params">(d)</span>:</span>
    c.local(<span class="hljs-string">'git checkout master'</span>) <span class="hljs-comment"># 切换到master</span>
    c.local(<span class="hljs-string">'git rebase develop'</span>) <span class="hljs-comment"># 合并develop分支</span>
    c.local(<span class="hljs-string">'git push origin master'</span>) <span class="hljs-comment"># push到master</span>
    <span class="hljs-keyword">with</span> c.cd(<span class="hljs-string">'/home/ubuntu/path/your_project'</span>):
        c.run(<span class="hljs-string">'git pull'</span>, pty=<span class="hljs-keyword">True</span>) <span class="hljs-comment"># 远程拉取代码</span>
        c.run(<span class="hljs-string">'./depoly.sh'</span>) <span class="hljs-comment"># 远程执行build</span>
    c.local(<span class="hljs-string">'git checkout develop'</span>) <span class="hljs-comment"># 本地切换回develop</span>
</pre>
      </div>
    <p>执行<code>fab depoly</code>就可以完成一系列部署</p>

    <h2 id="%E7%BB%93%E8%AF%AD" class="heading">
      <a href="#%E7%BB%93%E8%AF%AD" class="heading-anchor"></a>结语
    </h2>
  <p>上述过程其实完全可以由各种<code>CI</code>完成</p>
<p>但是对于私有<code>gitlab</code>, 同时又没有部署<code>gitlab-runner</code>或者不想接入第三方的话</p>
<p><code>fabric</code>是个不错的选择</p>
]]></description><link>http://zwingz.github.io/posts/346031510.html</link><guid isPermaLink="false">346031510</guid><category><![CDATA[depoly]]></category><category><![CDATA[front-end]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Tue, 31 Jul 2018 04:32:38 GMT</pubDate></item><item><title><![CDATA[记一下从Vue转向React的感想]]></title><description><![CDATA[
    <h1 id="%E5%85%B3%E4%BA%8Ereact-%E6%83%B3%E8%AF%B4%E5%87%A0%E7%82%B9" class="heading">
      <a href="#%E5%85%B3%E4%BA%8Ereact-%E6%83%B3%E8%AF%B4%E5%87%A0%E7%82%B9" class="heading-anchor"></a>关于React, 想说几点
    </h1>
  <p>没有干货, 只有感想.
没有源码分析, 只有需求实现.</p>

    <h2 id="react%E8%B7%9Fvue%E5%AF%B9%E6%AF%94" class="heading">
      <a href="#react%E8%B7%9Fvue%E5%AF%B9%E6%AF%94" class="heading-anchor"></a>React跟Vue对比
    </h2>
  <p>之前写过一篇<a href="https://zwing.site/posts/275254986.html">vue后台系统开发实践</a></p>
<p>那时候主要写<code>vue</code>, 有时间也会关注下<code>React</code>相关内容, 但没有实际开发经验.</p>
<p>最近终于从<code>vue</code>转向了<code>React</code></p>
<p>虽说两者都是<code>MVVM</code>框架, 都是数据驱动型, 但是两者区别还真的很明显.</p>
<p>曾经看过一段话, 大概是这么一个意思</p>
<p><code>vue</code>就是帮你封装了所有东西, 比如数据监听、指令、模板渲染等等</p>
<p>写起来就像是一门新的语言一样,你只要按照他的语法, 你就能很轻易的写出一套系统. </p>
<p>而<code>React</code>只提供了最基础的东西, 比如<code>vnode</code>, dom渲染等, 其余得都要靠自己去组合实现. 写起来就跟写原生<code>JavaScript</code>没什么区别. 可以玩出很多花样.</p>
<p>我是很赞同这个说法</p>
<p>在刚开始写<code>React</code>时候, 时不时都会带上<code>vue</code>的思想去写</p>
<p>耳边偶尔会响起一句话 &#39;怎么React这么麻烦, 我用vue一下子就能完成的东西, 在这里要写半天&#39;</p>
<p>例子? <code>Form</code>表单的双向绑定就是一个例子.</p>

    <h3 id="%E5%88%9D%E6%8E%A2react" class="heading">
      <a href="#%E5%88%9D%E6%8E%A2react" class="heading-anchor"></a>初探React
    </h3>
  <p>刚开始写, 由于不太熟练, 就选择了<code>Antd</code>作为UI框架.</p>
<p>但其实我是不太喜欢使用第三方库的</p>
<p>在刚开始写<code>vue</code>时候, 也是选择<code>ElementUI</code>, 后面熟练之后也逐步抛弃, 改用自己实现的组件</p>
<p>除了几个特别麻烦的, 比如 <code>DataPicker</code> . 我还是选择使用第三方. </p>
<p>我也写过一个<a href="https://zwing.site/posts/295960409.html">固定表格组件</a>, 个人感觉挺良好. 666</p>
<p>那么对于<code>React</code>,  我也选择了同样的入手方式, 先从第三方库用起, 后续逐步替代.</p>
<p>当然, <code>Antd</code> 用起来也是很麻烦, 花了几天勉强搭起了一个简单功能的后台. </p>
<p>当时的想法就是, 这么几个页面, 用<code>vue</code>一天就搞定, 这个<code>react</code>花了我几天.</p>
<p>可能当时也是太年轻了.</p>
<p>后来开发第二个系统, 就开始结合上文所说的<code>vue后台实践</code> 所提到的几个要点去重新写系统</p>

    <h2 id="react%E7%9A%84router%E9%80%89%E6%8B%A9" class="heading">
      <a href="#react%E7%9A%84router%E9%80%89%E6%8B%A9" class="heading-anchor"></a>React的router选择
    </h2>
  <p>react的路由选择目前有两种, 一种是官方的<code>react-router</code>, 另一个是刚出不久的<code>reach-router</code>.</p>
<p>而<code>react-router</code>也是从<code>v3</code>升级到了<code>v4</code>,  这次升级可以说是颠覆了传统的声明式路由</p>
<p>改成了路由组件化, 而不是传统的配置形式。</p>
<p>对于, <code>reach-router</code>可以说是麻雀虽小五脏俱全， 可以满足基本的路由功能,, <code>API</code>和路由组件使用起来也是比较简单的。</p>
<p>刚搭建项目时候，我从<code>v3</code>和<code>v4</code>中做过选择， 最后决定使用<code>v4</code>, 因为我个人喜欢用新不用旧。</p>
<p>在开发过程中，可能由于自己对<code>React</code>还不够熟悉， 在使用<code>Router</code>上也遇到不少问题。</p>
<p>比如最简单的路由跳转</p>
<p><code>v3</code>只需要直接调用<code>api</code>即可完成跳转</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-comment">/* react-router v3*/</span>
<span class="hljs-keyword">import</span> { browserHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router'</span>; 
browserHistory.<span class="hljs-keyword">push</span>(<span class="hljs-string">'/some/path'</span>);</pre>
      </div>
    <p><code>v4</code>需要引入高阶组件后才能从<code>props</code>中调用api.</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-comment">/* react-router v3*/</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">React</span> from <span class="hljs-symbol">'reac</span>t'
<span class="hljs-keyword">import</span> { withRouter } from <span class="hljs-symbol">'react</span>-router'
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-comment">// ...</span>
    push() {
        <span class="hljs-keyword">this</span>.props.history.push('/some/path')
    }
       <span class="hljs-comment">// ...</span>
}
export <span class="hljs-keyword">default</span> withRouter(<span class="hljs-type">Component</span>)</pre>
      </div>
    <p>但是<code>v4</code>也有优点, 就是路由配置很灵活, 在需要用到的地方引入<code>Route</code>即可。</p>
<p>但是中途用着不爽，我就直接换成了<code>reach-router</code>。</p>
<p>这会<code>reach-router</code>用起来可爽了, 简单直接。</p>
<p>可是由于还不足够的成熟, 用了一段时间后，我又很无耻的改回了<code>react-router</code></p>
<p>不过我个人还是很欣赏<code>reach-router</code>, 希望后续能真正的发展起来。</p>

    <h2 id="reactmobx%E7%BB%93%E5%90%88" class="heading">
      <a href="#reactmobx%E7%BB%93%E5%90%88" class="heading-anchor"></a>React+mobx结合
    </h2>
  <p>一般看到<code>React</code>, 一般也会伴随着<code>Redux</code>。</p>
<p>而我从<code>vue</code>和<code>vuex</code>那套过来的，不是很喜欢<code>Redux</code>那套复杂的规则和写法。</p>
<p>当然，也有很多成熟的解决方案，比如<code>dva</code>, <code>rematch</code>等, 轮子可不少啊。</p>
<p>但是我个人更偏向于使用<code>mobx</code>，或者跟<code>vuex</code>脱不了干系吧。</p>
<p>使用多<code>store</code>组合，或许能让组件更加的灵活。而且使用简单，不需要复杂的流程。</p>

    <h2 id="react%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8" class="heading">
      <a href="#react%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8" class="heading-anchor"></a>React在项目中使用
    </h2>
  <p>主要是根据以往的<a href="https://zwing.site/posts/275254986.html">vue开发实践</a>，将其搬到<code>react</code>中来。</p>
<ul>
<li>用户登录态管理</li>
<li>router的钩子</li>
<li>列表页的数据加载，数据展示流程控制</li>
<li>列表页查询参数与url查询参数双向绑定</li>
<li>部分组件的实现</li>
</ul>
<p>...后续再补</p>
]]></description><link>http://zwingz.github.io/posts/339905815.html</link><guid isPermaLink="false">339905815</guid><category><![CDATA[front-end]]></category><category><![CDATA[js]]></category><category><![CDATA[react]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Tue, 10 Jul 2018 15:56:23 GMT</pubDate></item><item><title><![CDATA[Promise/A+规范以及实现]]></title><description><![CDATA[
    <h1 id="promise-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" class="heading">
      <a href="#promise-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" class="heading-anchor"></a>Promise 实现原理
    </h1>
  <p><a href="https://github.com/zWingz/Promise">源码</a></p>

    <h2 id="promise%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" class="heading">
      <a href="#promise%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" class="heading-anchor"></a>Promise基本用法
    </h2>
  
      <div class="hljs javascript code">
        <pre>new Promise(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(resolve, reject)</span> {</span>
    resolve()
}).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val)</span> {</span>
    <span class="hljs-keyword">return</span> val
}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> {</span>
    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">error</span>)
}).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> {</span>
    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">error</span>)
})</pre>
      </div>
    <p>Promise对象基本方法是<code>then</code>, 而<code>catch</code>是<code>then</code>的一个变形, 相当于<code>then(undefined, onReject)</code></p>

    <h2 id="%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B" class="heading">
      <a href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B" class="heading-anchor"></a>实现过程
    </h2>
  <p>根据Promise用法, 我们初步想到需要实现的方法是</p>
<ul>
<li>构造函数</li>
<li>resolve函数</li>
<li>reject函数</li>
<li>then函数</li>
</ul>
<p>此时Promise原型应为</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">'PENDING'</span>
<span class="hljs-keyword">const</span> RESOLVED = <span class="hljs-string">'RESOLVED'</span>
<span class="hljs-keyword">const</span> REJECT = <span class="hljs-string">'REJECT'</span>

<span class="hljs-keyword">class</span> <span class="hljs-built_in">Promise</span> {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">func</span>) {}
    resolve(){}
    reject(){}
    then(onReslove, onReject){}
}</pre>
      </div>
    
    <h3 id="%E6%A0%B9%E6%8D%AEpromisea%E8%A7%84%E8%8C%83%E4%BB%A5%E4%B8%8B%E7%AE%80%E7%A7%B0%E8%A7%84%E8%8C%83%E4%B8%AD%E6%89%80%E8%AF%B4%E7%9A%84" class="heading">
      <a href="#%E6%A0%B9%E6%8D%AEpromisea%E8%A7%84%E8%8C%83%E4%BB%A5%E4%B8%8B%E7%AE%80%E7%A7%B0%E8%A7%84%E8%8C%83%E4%B8%AD%E6%89%80%E8%AF%B4%E7%9A%84" class="heading-anchor"></a>根据<code>Promise/A+规范</code>(以下简称规范)中所说的
    </h3>
  <ul>
<li>Promise有三个状态 <code>PENDING</code>, <code>RESOLVED</code>, <code>REJECTED</code></li>
<li>状态只会从<code>PENDING</code>转换到<code>RESOLVED</code>或者<code>REJECTED</code>其中一个, 并且之后不会再改变</li>
<li>当Promise处于执行态时, 会有一个终值, 并且该值不会再改变</li>
<li>当Promise处于拒绝态时, 会有一个据因, 并且该据因不会再改变</li>
<li>当Promise由PENDING转换为RESOLVED时, 会触发<code>onResolve</code>回调, 并且只执行一次</li>
<li>当Promise由PENDING转换为REJECTED时, 会触发<code>onReject</code>回调, 并且只执行一次</li>
<li>Promise状态的转换时机在于开发者何时调用promise的resolve或者reject函数</li>
</ul>

      <div class="hljs javascript code">
        <pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>{
    <span class="hljs-keyword">constructor</span>(func) {
        <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span> <span class="hljs-comment">// 终值或者据因</span>
        <span class="hljs-keyword">this</span>.status = PENDING <span class="hljs-comment">// 状态</span>
        <span class="hljs-keyword">this</span>.onResolveCallBack = [] <span class="hljs-comment">// resolved 回调</span>
        <span class="hljs-keyword">this</span>.onRejectCallBack = [] <span class="hljs-comment">// rejected 回调</span>
        <span class="hljs-keyword">try</span> {
            func(<span class="hljs-keyword">this</span>.resolve.bind(<span class="hljs-keyword">this</span>), <span class="hljs-keyword">this</span>.reject.bind(<span class="hljs-keyword">this</span>))
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-keyword">this</span>.reject(e)
        }
    }
    resolve(<span class="hljs-keyword">val</span>){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === PENDING) {
            <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">val</span> <span class="hljs-comment">// 设置终值</span>
            <span class="hljs-keyword">this</span>.status = RESOLVED <span class="hljs-comment">// 设置状态</span>
            <span class="hljs-keyword">this</span>.onResolveCallBack.forEach(each =&gt; {
                each(<span class="hljs-keyword">val</span>) <span class="hljs-comment">// 执行回调</span>
            })
        }
    }
    reject(reason){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === PENDING) {
            <span class="hljs-keyword">this</span>.value = reason <span class="hljs-comment">// 设置据因</span>
            <span class="hljs-keyword">this</span>.status = REJECT <span class="hljs-comment">// 设置状态</span>
            <span class="hljs-keyword">this</span>.onRejectCallBack.forEach(each =&gt; {
                each(reason) <span class="hljs-comment">// 执行回调</span>
            })
        }
    }
    then(onReslove, onReject){}
}</pre>
      </div>
    <p>这里可能有人会说Promise应该是一个异步的过程, 在上面代码中并没有看到任何的异步. 比如说: setTimeout。</p>
<p>解答：</p>
<p>其实当创建一个Promise实例的时候，整个过程是同步的。</p>
<p>也就是说</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-keyword">const</span> ins = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
    res(<span class="hljs-number">10</span>)
})
<span class="hljs-built_in">console</span>.log(ins)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after ins'</span>)

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// Promise {&lt;resolved&gt;: 10}</span>
<span class="hljs-comment">// after ins</span>
</pre>
      </div>
    <p>当你执行完这一句， ins的状态会马上变成<code>RESOLVED</code>. 说明在构造方法中并没有执行异步操作。如果真的需要异步的话，则需要主动在调用<code>res</code>前，加上<code>setTimeout</code>来触发异步。</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-keyword">const</span> ins = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        res(<span class="hljs-number">10</span>)
    })
})
<span class="hljs-built_in">console</span>.log(ins)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after ins'</span>)

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// Promise {&lt;pending&gt;}</span>
<span class="hljs-comment">// after ins</span></pre>
      </div>
    
    <h3 id="%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AAthen%E6%96%B9%E6%B3%95%E6%B2%A1%E6%9C%89%E5%AE%8C%E6%88%90-%E5%85%88%E7%9C%8B%E4%B8%8B%E8%A7%84%E8%8C%83%E6%80%8E%E4%B9%88%E8%AF%B4" class="heading">
      <a href="#%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AAthen%E6%96%B9%E6%B3%95%E6%B2%A1%E6%9C%89%E5%AE%8C%E6%88%90-%E5%85%88%E7%9C%8B%E4%B8%8B%E8%A7%84%E8%8C%83%E6%80%8E%E4%B9%88%E8%AF%B4" class="heading-anchor"></a>还有一个<code>then</code>方法没有完成. 先看下规范怎么说
    </h3>
  <ul>
<li>一个promise必须提供一个<code>then</code>方法以访问当前值, 终止和据因</li>
<li>then接受两个参数<code>then(onResolve, onReject)</code></li>
<li>onResolve和onReject都是可选, 如果不是函数则被忽略</li>
<li>onResolve方法在promise执行结束后被调用, 其第一个参数为promise的终值, 被调用次数不超过一次</li>
<li>onReject方法在promise被拒绝后被调用, 其第一个参数为promise的据因, 同样被调用次数不超过一次</li>
<li>onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用 </li>
<li>如果onResolve和onReject返回一个值x, 则执行 <strong>Promise解决过程</strong></li>
<li>then方法必须返回一个<code>promise</code>对象</li>
</ul>
<p>简单说就是</p>
<ul>
<li>如果promise处于pending, 则将then回调放入promise的回调列表中</li>
<li>如果promise处于resolved, 则实行then方法中的onResolve</li>
<li>如果promise处于rejected, 则执行then方法中的onReject</li>
<li>then方法要确保onResolve和onReject异步执行</li>
<li>onResolve和onReject返回的值都将用来解决下一个promise(后面再讲解)</li>
<li>返回新的promise(注意: 一定是新的promise)</li>
</ul>

      <div class="hljs javascript code">
        <pre><span class="hljs-keyword">class</span> <span class="hljs-constructor">Promise()</span> {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">then</span>(onResolve, onReject){
        const self = this
        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">nextResolve</span>, <span class="hljs-params">nextReject</span>)</span> {
            <span class="hljs-keyword">if</span>(self.status<span class="hljs-operator"> === </span>PENDING) {
                <span class="hljs-comment">// 加入到任务队列</span>
                self.onResolveCallback.push(onResolve)
                self.onRejectCallback.push(onReject)
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(self.status<span class="hljs-operator"> === </span>RESOLVED) {
                <span class="hljs-comment">// 异步执行</span>
                set<span class="hljs-constructor">Timeout(<span class="hljs-params">onResolve</span>, 0, <span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 异步执行</span>
                set<span class="hljs-constructor">Timeout(<span class="hljs-params">onReject</span>, 0, <span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>
            }
        })
    }
}</pre>
      </div>
    <p>此时Promise已经可以完成异步操作.
但是Promise还有一个关键特点是可以链式调用. 目前是还没有实现链式调用这一步.
具体代码看<a href="https://github.com/zWingz/Promise/blob/master/promise2.js">promise2.js</a></p>

    <h3 id="%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%BB%A7%E7%BB%AD%E7%9C%8B%E4%B8%8B%E8%A7%84%E8%8C%83%E6%80%8E%E4%B9%88%E8%AF%B4" class="heading">
      <a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%BB%A7%E7%BB%AD%E7%9C%8B%E4%B8%8B%E8%A7%84%E8%8C%83%E6%80%8E%E4%B9%88%E8%AF%B4" class="heading-anchor"></a>接下来继续看下规范怎么说
    </h3>
  <p>Promise 解决过程</p>
<ul>
<li>blablabla 这里比较长</li>
</ul>
<p><strong>简单说就是</strong></p>
<p><code>x</code>为<code>then</code>方法中<code>onResolve</code>或者<code>onReject</code>中返回的值, <code>promise2</code>为<code>then</code>方法返回的新<code>promise</code>.</p>
<p><code>promise</code>的解决过程是一个抽象步骤. 需要输入一个<code>promise</code>和一个<strong>值</strong>. 表示为<code>[[Resolve]](promise, x)</code></p>
<ul>
<li>如果<code>x</code>和<code>promise2</code>相等, 则以<code>TypeError</code>为据因拒绝执行promise2</li>
<li>如果<code>x</code>为<code>Promise</code>实例, 则让<code>promise2</code>接受x的状态</li>
<li>如果<code>x</code>为<code>thenable</code>对象, 则调用其<code>then</code>方法</li>
<li>如果都不满足, 则用<code>x</code>为参数执行<code>promise2</code></li>
</ul>
<p>继续修改then方法, 以及添加<code>resolvePromise</code>来执行<code>Promise</code>解决过程</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-keyword">function</span> <span class="hljs-constructor">_isFunction(<span class="hljs-params">val</span>)</span> {
  return typeof <span class="hljs-keyword">val</span><span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>'
}
<span class="hljs-keyword">function</span> <span class="hljs-constructor">_isThenable(<span class="hljs-params">x</span>)</span> {
  return <span class="hljs-constructor">_isFunction(<span class="hljs-params">x</span>)</span><span class="hljs-operator"> || </span>(typeof x<span class="hljs-operator"> === </span>'object'<span class="hljs-operator"> &amp;&amp; </span>x !== null)
}

<span class="hljs-comment">/**
 * Promise 解决过程
 * 如果是thenable对象, 则触发该对象的then方法
 * 如果是一个值, 则直接调用resolve解析这个值
 * @param {Promise}} promise
 * @param {Object} x
 * @param {Function} resolve
 * @param {Function} reject
 */</span>
<span class="hljs-keyword">function</span> resolve<span class="hljs-constructor">Promise(<span class="hljs-params">promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> {
  <span class="hljs-comment">// 要求每次返回新的promise</span>
  <span class="hljs-comment">// 如果返回是当前的promise, 则抛出typeError</span>
  <span class="hljs-keyword">if</span> (x<span class="hljs-operator"> === </span>promise) {
    reject(<span class="hljs-keyword">new</span> <span class="hljs-constructor">TypeError('Chaining <span class="hljs-params">cycle</span> <span class="hljs-params">detected</span> <span class="hljs-params">for</span> <span class="hljs-params">promise</span>')</span>)
  }
  <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>
  <span class="hljs-comment">// 判断是否thenable对象</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-constructor">_isThenable(<span class="hljs-params">x</span>)</span>) {
    <span class="hljs-keyword">try</span> {
      const { <span class="hljs-keyword">then</span> } = x
      <span class="hljs-keyword">if</span> (<span class="hljs-constructor">_isFunction(<span class="hljs-params">then</span>)</span>) {
        <span class="hljs-keyword">then</span>.call(
          x,
         <span class="hljs-function"> <span class="hljs-params">val</span> =&gt;</span> {
            <span class="hljs-keyword">if</span> (!called) {
              called = <span class="hljs-literal">true</span>
              <span class="hljs-comment">// 如果不断的返回thenable</span>
              <span class="hljs-comment">// 则需要不断地递归</span>
              <span class="hljs-comment">// 但是实际上不应该不断的返回thenable</span>
              resolve<span class="hljs-constructor">Promise(<span class="hljs-params">promise</span>, <span class="hljs-params">val</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>
            }
          },
         <span class="hljs-function"> <span class="hljs-params">reason</span> =&gt;</span> {
            <span class="hljs-keyword">if</span> (!called) {
              called = <span class="hljs-literal">true</span>
              reject(reason)
            }
          }
        )
      } <span class="hljs-keyword">else</span> {
        resolve(x)
      }
    } catch (e) {
      <span class="hljs-keyword">if</span> (called) {
        return
      }
      called = <span class="hljs-literal">true</span>
      reject(e)
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//  非thenable, 则以该值来执行resolve</span>
    resolve(x)
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-constructor">Promise()</span> {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">/**
   * then方法
   * @param {Function} [onFulfilled] 前then的resolve函数, 当promise为RESOLVE时,处理当前结果
   * @param {Function} onRejected 当前then的reject函数, 当promise被REJECT时调用
   * @returns {Promise}
   * @memberof Promise
   */</span>
  <span class="hljs-keyword">then</span>(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled<span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>' ? onFulfilled :<span class="hljs-function"> <span class="hljs-params">val</span> =&gt;</span> <span class="hljs-keyword">val</span>
    onRejected =
      typeof onRejected<span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>'
        ? onRejected
        :<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> {
            throw err
          }
    const self = this
    <span class="hljs-comment">// 如果有then方法调用, 则将hasThenHandle设为true</span>
    <span class="hljs-comment">// console.log(this);</span>
    this.hasThenHandle = <span class="hljs-literal">true</span>
    <span class="hljs-comment">/**
     * 返回一个新的promise, 用于链式调用
     */</span>
    const ret = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> {
      <span class="hljs-comment">// 用try..catch包裹执行方法</span>
      const tryCatchWrapper = <span class="hljs-keyword">function</span>(fnc) {
        return <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> {
          <span class="hljs-keyword">try</span> {
            fnc<span class="hljs-literal">()</span>
          } catch (e) {
            reject(e)
          }
        }
      }
      <span class="hljs-comment">// 封装resolve方法回调</span>
      const doResolve = <span class="hljs-keyword">try</span><span class="hljs-constructor">CatchWrapper(<span class="hljs-params">function</span>()</span> {
        resolve<span class="hljs-constructor">Promise(<span class="hljs-params">ret</span>, <span class="hljs-params">onFulfilled</span>(<span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>, resolve, reject)
      })
      <span class="hljs-comment">// 封装reject方法回调</span>
      <span class="hljs-comment">// 如果当前then没有相应的reject回调</span>
      const doReject = <span class="hljs-keyword">try</span><span class="hljs-constructor">CatchWrapper(<span class="hljs-params">function</span>()</span> {
        resolve<span class="hljs-constructor">Promise(<span class="hljs-params">ret</span>, <span class="hljs-params">onRejected</span>(<span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>, resolve, reject)
      })
      <span class="hljs-keyword">if</span> (self.status<span class="hljs-operator"> === </span>PENDING) {
        <span class="hljs-comment">// 如果当前promise还未执行完毕, 则设置回调</span>
        self.onResolveCallback.push(doResolve)
        self.onRejectCallback.push(doReject)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status<span class="hljs-operator"> === </span>RESOLVED) {
        <span class="hljs-comment">// 如果为RESOLVE, 则异步执行resolve</span>
        set<span class="hljs-constructor">Timeout(<span class="hljs-params">doResolve</span>, 0)</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 如果为REJECT, 则异步执行reject</span>
        set<span class="hljs-constructor">Timeout(<span class="hljs-params">doReject</span>, 0)</span>
      }
    })
    return ret
  }
}</pre>
      </div>
    <p>至此一个<code>Promise</code>可以说基本完成了.(完整代码请看<a href="https://github.com/zWingz/Promise/blob/master/index.js">index.js</a>)</p>

    <h3 id="%E8%A7%84%E8%8C%83%E5%A4%96%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF" class="heading">
      <a href="#%E8%A7%84%E8%8C%83%E5%A4%96%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF" class="heading-anchor"></a>规范外的一些东西
    </h3>
  <p>其实规范中定义的是<code>Promise</code>的构建和执行过程.</p>
<p>而我们日常用到的却不至于规范中所提到的.</p>
<p>比如</p>
<ul>
<li>catch</li>
<li>finally</li>
<li>Promise.resolve</li>
<li>Promise.reject</li>
<li>all (未实现)</li>
<li>race (未实现)</li>
</ul>
<p>那接下来就说下关于这部分的实现</p>

    <h4 id="catch" class="heading">
      <a href="#catch" class="heading-anchor"></a>catch
    </h4>
  <p>上面有提到. catch其实是<code>then(undefined, reject)</code> 的简写. 所以这里比较简单</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span></span>() {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">catch</span>(reject) {
        <span class="hljs-comment">// 相当于新加入一个then方法</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(undefined, reject)
    }
}</pre>
      </div>
    
    <h4 id="finally-es2018%E5%BC%95%E5%85%A5%E6%A0%87%E5%87%86" class="heading">
      <a href="#finally-es2018%E5%BC%95%E5%85%A5%E6%A0%87%E5%87%86" class="heading-anchor"></a>finally (ES2018引入标准)
    </h4>
  <p>finally函数作用我想大家都应该知道, 就是无论当前promise状态是如何. 都一定会执行回调.</p>
<p>finally方法中, 不接收任何参数, 所以并不能知道前面的Promise的状态.</p>
<p>同时, 他不会对promise产生影响.总是返回原来的值 所以在<code>finally</code>中的操作,应该是与状态无关, 不依赖于promise的执行结果</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-keyword">class</span> <span class="hljs-built_in">Promise</span>() {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">finally</span>(fnc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> {
            fnc()
            <span class="hljs-keyword">return</span> val
        }, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
            fnc()
            <span class="hljs-keyword">throw</span> err
        })
    }
}</pre>
      </div>
    
    <h4 id="promiseresolve%E5%92%8Cpromisereject-%E8%BF%99%E9%87%8C%E6%98%AF%E4%BB%8Ees6%E5%85%A5%E9%97%A8%E4%B8%AD%E7%9C%8B%E5%88%B0%E7%9A%84%E5%AE%9A%E4%B9%89" class="heading">
      <a href="#promiseresolve%E5%92%8Cpromisereject-%E8%BF%99%E9%87%8C%E6%98%AF%E4%BB%8Ees6%E5%85%A5%E9%97%A8%E4%B8%AD%E7%9C%8B%E5%88%B0%E7%9A%84%E5%AE%9A%E4%B9%89" class="heading-anchor"></a>Promise.resolve和Promise.reject (这里是从ES6入门中看到的定义)
    </h4>
  
      <div class="hljs javascript code">
        <pre><span class="hljs-comment">// 调用形式</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve(arg)
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(arg)</pre>
      </div>
    <ul>
<li><p>Promise.resolve</p>
<p>  根据arg的不同, 会执行不同的操作</p>

      <div class="hljs code">
        <pre> - arg为Promise实例, 则原封不动的返回这个实例
 - arg为thenable对象, 则会将arg转成promise, 并且立即执行&#x60;arg.then&#x60;方法(并不代表同步, 而是本轮事件循环结束时执行)
 - arg不满足上述情况, 则返回一个新的Promise实例, 状态为resolved, 终值为arg</pre>
      </div>
    <p>  因此<code>Promise.resolve</code>是一个更方便的创建<code>Promise</code>实例的方法.</p>
</li>
<li><p>Promise.reject</p>
<p>  这里就不会区分arg, 而是原封不动的把arg作为据因, 执行后续方法的调用.</p>
</li>
</ul>
<p>实现代码</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span>() </span>{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">/**
     * Promise.resolve
     * 将参数转成Promise对象
     * @static
     * @param {any} val
     * @returns {MPromise}
     * @memberof MPromise
     */</span>
    <span class="hljs-keyword">static</span> resolve(x) {
        <span class="hljs-comment">// 如果为MPromise实例</span>
        <span class="hljs-comment">// 则返回该实例</span>
        <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {
            <span class="hljs-keyword">return</span> val
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_isThenable(x)) {
            <span class="hljs-comment">// 如果为具有then方法的对象</span>
            <span class="hljs-comment">// 则转为MPromise对象, 并且执行thenable</span>
            <span class="hljs-comment">/**
             * @example
             * MPromise.resolve({
             *      then(res) {
             *          console.log('do promise')
             *          res(10)
             *      }
             *  })
             */</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
                <span class="hljs-comment">// 执行异步</span>
                setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    val.then(res, rej)
                }, <span class="hljs-number">0</span>)
            })
        }
        <span class="hljs-comment">// 如果val为一个原始值,或者不具有then方法的对象</span>
        <span class="hljs-comment">// 则返回一个新的MPromise对象,状态为resolved</span>
        <span class="hljs-comment">/**
         * @example
         * MPromise.resolve()
         */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>{res(x)})
    }
    <span class="hljs-comment">/**
     * reject方法参数会原封不动的作为据因而变成后续方法的参数
     * 且初始状态为REJECT
     * 不存在判别thenable
     * @static
     * @param {any} reason 
     * @returns 
     * @memberof MPromise
     */</span>
    <span class="hljs-keyword">static</span> reject(reason) {
        <span class="hljs-comment">/**
         * @example
         * MPromise.reject('some error')
         */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{rej(reason)})
    }
}</pre>
      </div>
    
    <h3 id="%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" class="heading">
      <a href="#%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" class="heading-anchor"></a>开发过程中遇到其他问题
    </h3>
  
    <h4 id="node%E4%B8%AD%E7%9A%84unhandledrejection%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84uncaught-in-promise-%E6%8F%90%E7%A4%BA" class="heading">
      <a href="#node%E4%B8%AD%E7%9A%84unhandledrejection%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84uncaught-in-promise-%E6%8F%90%E7%A4%BA" class="heading-anchor"></a>node中的<code>unhandledRejection</code>和浏览器中的<code>Uncaught (in promise)</code> 提示
    </h4>
  <p>在Promise中产生的所有错误都会被Promise吞掉. 当没有相应的错误处理函数时候, node和浏览器分别有不同的表现.</p>
<p>但是这并不是一个新的错误, 因为不能用<code>try{} catch(){}</code> 捕获.</p>
<p>所以在浏览器端, 是一个<code>console.error</code>的错误提示, 在<code>node</code>中, 这个算是一个事件. 具体可以通过<code>process.on</code>来监听</p>

      <div class="hljs javascript code">
        <pre>process.on(<span class="hljs-string">'unhandledRejection'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, p)</span> </span>{
  <span class="hljs-keyword">throw</span> err;
});</pre>
      </div>
    <p>在编写代码中, 一开始卡在这一步挺久.</p>
<p>由于无法知道promise实例后续是否有相应的错误处理函数.</p>
<p>简单的判断<code>onReject === undefined</code> 是不行的.</p>
<p>形如:</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(<span class="hljs-number">10</span>)
<span class="hljs-comment">// 或者</span>
<span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">res</span>, <span class="hljs-params">rej</span>)</span> {
    rej(<span class="hljs-number">10</span>)
})</pre>
      </div>
    <p>这类是同步执行的, <code>onReject === undefined</code> 恒为<code>true</code>.</p>
<p>我的做法是给promise实例添加一个<code>hasThenHandle</code>的属性, 在<code>then</code>方法中将其设为<code>true</code></p>
<p>在<code>reject</code>方法中使用<code>setTimeout</code>异步判断该值是否为<code>true</code>, 如果不是则通过<code>console.error</code>抛出提示.</p>
<p>其实在原生Promise中, 抛出的<code>unhandledRejection</code> 也是属于异步的.</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">10</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after Promise.reject'</span>)
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
    rej(<span class="hljs-number">10</span>)
})
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after new Promise'</span>)

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// after Promise.reject</span>
<span class="hljs-comment">// after new Promise</span>
<span class="hljs-comment">// Uncaught (in promise) 10</span>
<span class="hljs-comment">// Uncaught (in promise) 10</span></pre>
      </div>
    <p>于是这个问题也能得到很好地解决.</p>
<p>至此完整代码已经结束, 具体看<code>index.js</code>.</p>

    <h2 id="%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" class="heading">
      <a href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" class="heading-anchor"></a>存在的问题
    </h2>
  <ul>
<li>由于用的是setTimeout模拟, 所以优先级不能保证高于setTimeout<ul>
<li>浏览器中可以用MessageChannel(macrotask)</li>
<li>node中可以用setImmediate(优先级在某些情况下比setTimeout高一些)</li>
<li>setTimeout和setImmediate在无IO操作下,两者执行顺序不确定,但是在IO操作下,setImmediate比setTimeout优先级高. 且setImmediate只在IE下有效</li>
</ul>
</li>
</ul>

    <h2 id="%E5%8F%82%E8%80%83" class="heading">
      <a href="#%E5%8F%82%E8%80%83" class="heading-anchor"></a>参考
    </h2>
  <p><a href="http://www.ituring.com.cn/article/66566">【翻译】Promises/A+规范</a></p>
<p><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-prototype-finally">ECMAScript 6入门</a></p>
]]></description><link>http://zwingz.github.io/posts/316337025.html</link><guid isPermaLink="false">316337025</guid><category><![CDATA[front-end]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Fri, 20 Apr 2018 16:40:56 GMT</pubDate></item><item><title><![CDATA[初次制作戚风蛋糕（6寸）]]></title><description><![CDATA[
    <h2 id="%E6%9D%90%E6%96%99" class="heading">
      <a href="#%E6%9D%90%E6%96%99" class="heading-anchor"></a>材料
    </h2>
  <ul>
<li>低筋面粉 45g</li>
<li>鸡蛋 3个</li>
<li>色拉油(植物油/玉米油) 20g</li>
<li>牛奶25g (没有牛奶.所以用了奶粉+水冲兑)</li>
<li>砂糖 40g(蛋白30g 蛋黄10g)</li>
<li>打蛋盆和有同样大的盆子</li>
<li>6寸模具（我的模具是8寸）</li>
</ul>

    <h2 id="%E6%AD%A5%E9%AA%A4" class="heading">
      <a href="#%E6%AD%A5%E9%AA%A4" class="heading-anchor"></a>步骤
    </h2>
  <ul>
<li>用电子秤准确称取上次材料.。糖要分开秤,因为用途不一样。</li>
<li>是蛋清分离器将蛋白和蛋黄分开。每次分离时候在小碗里面分离，分离完了才将蛋白倒入打蛋盆中，以免污染了打蛋盆中的蛋白。将蛋黄放入另一个盆子中。</li>
<li>加入10g砂糖到打蛋盆中，使用电动打蛋器低速搅动。待出现大量泡泡时候，倒入10g糖，开高速档进行搅动，当蛋清出现纹路后，加入最后10g砂糖，继续搅动。直到打蛋器提起后蛋白不会掉落，此时蛋白已经算打发完成。</li>
<li>用手动打蛋器搅拌蛋黄，搅拌完后，倒入10g砂糖、25g牛奶、20g植物油。继续搅拌。</li>
<li>用面粉筛将低筋面粉塞入蛋黄液中。</li>
<li>使用刮刀将面粉和蛋黄液混合，此处不能用打蛋器。刮刀混合时候从下往上翻，不能想打鸡蛋一样顺时针转动。要像炒菜一样。</li>
<li>混合搅拌至面粉糊没有颗粒。</li>
<li>烤箱150°预热10分钟。</li>
<li>取1/3打发好的蛋白，混入面糊当中，继续用刮刀将两者搅拌均匀。</li>
<li>将面糊全部倒入到打蛋盆中，与剩余的蛋白继续搅拌均匀，直到没有颗粒。</li>
<li>将搅拌好的面糊倒入蛋糕模中。</li>
<li>烤箱150°烤30-40分钟。</li>
<li>完成后取出。</li>
<li>摔模：将模具举高离台面5-8cm，摔下。</li>
<li>然后将模具倒扣在烤网上面，待蛋糕冷却后脱模。</li>
<li>此时戚风蛋糕制作完成。</li>
</ul>

    <h2 id="%E5%A4%B1%E8%B4%A5%E7%82%B9%E4%B8%8E%E6%80%BB%E7%BB%93" class="heading">
      <a href="#%E5%A4%B1%E8%B4%A5%E7%82%B9%E4%B8%8E%E6%80%BB%E7%BB%93" class="heading-anchor"></a>失败点与总结
    </h2>
  <ul>
<li>烤的中途打开了烤箱门，可能导致蛋糕回缩了。 因为一开始时候蛋糕还是逐渐增高，后面不知道为什么缩回去了，有可能是因为我打开了烤箱门。</li>
<li>第三个鸡蛋蛋清分离失败了，然后就直接把整个鸡蛋放入蛋黄液中，也不清楚是否有影响。</li>
<li>没有用牛奶而是用奶粉+水，可能有影响。 </li>
</ul>

    <h2 id="%E5%9B%BE%E7%89%87" class="heading">
      <a href="#%E5%9B%BE%E7%89%87" class="heading-anchor"></a>图片
    </h2>
  <p><img src="https://zwing.site/imgur/92583692.jpg" alt=""></p>
<p><img src="https://zwing.site/imgur/31921272.jpg" alt=""></p>
<p><img src="https://zwing.site/imgur/61126157.jpg" alt=""></p>
<p><img src="https://zwing.site/imgur/44394098.jpg" alt=""></p>

    <h2 id="%E6%9C%80%E5%90%8E" class="heading">
      <a href="#%E6%9C%80%E5%90%8E" class="heading-anchor"></a>最后
    </h2>
  <p>这次戚风蛋糕第一次尝试，还是挺不错的，评个80分吧。</p>
<p>本来是打算弄芝士蛋糕，奈何没有奶油奶酪，只能做原味戚风蛋糕了。
下次可以买奶油奶酪试试做芝士蛋糕。</p>
<p>周末做了下蛋包饭，差点就做成了蛋炒饭。</p>
<p>原因还是材料太多了，炒起来鸡蛋都保不住。</p>
<p>不过吃起来还是挺好吃，可能下次要注意下材料分量，鸡蛋能包起来就更好吃了。</p>
]]></description><link>http://zwingz.github.io/posts/310330786.html</link><guid isPermaLink="false">310330786</guid><category><![CDATA[杂事]]></category><category><![CDATA[烘焙]]></category><category><![CDATA[生活]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Sun, 01 Apr 2018 15:13:17 GMT</pubDate></item><item><title><![CDATA[记：再一次制作蛋挞。]]></title><description><![CDATA[
    <h2 id="%E6%9D%90%E6%96%99" class="heading">
      <a href="#%E6%9D%90%E6%96%99" class="heading-anchor"></a>材料
    </h2>
  <ul>
<li>蛋黄3个 (蛋清分离，只要蛋黄)</li>
<li>糖霜 10g （太少了，下次可以试着20g）</li>
<li>牛奶250ml</li>
<li>低筋粉 15g （有点多，下次试着10g）</li>
<li>蛋挞皮9个 （刚好的）</li>
</ul>

    <h2 id="%E8%BF%87%E7%A8%8B" class="heading">
      <a href="#%E8%BF%87%E7%A8%8B" class="heading-anchor"></a>过程
    </h2>
  <ul>
<li>用蛋清分离器，将鸡蛋逐个进行蛋清分离。将蛋黄放入打蛋盆中，蛋清可以另外存放，可以作为双皮奶原料。</li>
<li>由于没有牛奶，于是用了4勺奶粉代替。</li>
<li>电子秤称取10g糖霜。此次蛋挞不够甜，下次可以尝试放20g，或者15g砂糖也可以。</li>
<li>将糖霜倒入奶粉中，并用热水冲兑，搅拌，静置到常温。</li>
<li>用电子秤称取15g低筋粉（此次感觉过多，下次只称取10g），放入小碗中存放。</li>
<li>用打蛋器（手动）将蛋黄打散，并逐步加入混入糖霜的牛奶，分三次倒入，一边倒一边搅拌。</li>
<li>用面粉筛分三次筛入低筋面粉，并且一边筛入一边搅拌，尽量让蛋液和面粉混合。</li>
<li>筛入面粉后，此时蛋液有较多的泡沫。</li>
<li>使用过滤筛，过滤掉过多的泡沫。此次我一共过滤了三遍。</li>
<li>烤箱220度预热10分钟。</li>
<li>取出烤盆，铺上油纸，放入9个蛋挞皮。</li>
<li>倒入蛋挞液，9成满。</li>
<li>烤箱预热完毕，则放入蛋挞烤即可。</li>
<li>220度烤25分钟即可完成。</li>
</ul>

    <h2 id="%E4%B8%8A%E5%9B%BE" class="heading">
      <a href="#%E4%B8%8A%E5%9B%BE" class="heading-anchor"></a>上图
    </h2>
  
    <h3 id="%E5%80%92%E5%85%A5%E8%9B%8B%E6%8C%9E%E6%B6%B2%E5%90%8E" class="heading">
      <a href="#%E5%80%92%E5%85%A5%E8%9B%8B%E6%8C%9E%E6%B6%B2%E5%90%8E" class="heading-anchor"></a>倒入蛋挞液后
    </h3>
  <p><img src="https://zwing.site/imgur/45790429.jpg" alt=""></p>

    <h3 id="%E6%94%BE%E5%85%A5%E7%83%A4%E7%AE%B1" class="heading">
      <a href="#%E6%94%BE%E5%85%A5%E7%83%A4%E7%AE%B1" class="heading-anchor"></a>放入烤箱
    </h3>
  <p><img src="https://zwing.site/imgur/75661678.jpg" alt=""></p>

    <h3 id="%E6%AD%A3%E5%9C%A8%E7%83%A4%E7%9A%84%E8%9B%8B%E6%8C%9E" class="heading">
      <a href="#%E6%AD%A3%E5%9C%A8%E7%83%A4%E7%9A%84%E8%9B%8B%E6%8C%9E" class="heading-anchor"></a>正在烤的蛋挞
    </h3>
  <p><img src="https://zwing.site/imgur/33388698.jpg" alt=""></p>

    <h3 id="%E6%88%90%E5%93%81" class="heading">
      <a href="#%E6%88%90%E5%93%81" class="heading-anchor"></a>成品
    </h3>
  <p><img src="https://zwing.site/imgur/38696134.jpg" alt=""></p>

    <h2 id="%E7%BB%93%E8%AF%AD" class="heading">
      <a href="#%E7%BB%93%E8%AF%AD" class="heading-anchor"></a>结语
    </h2>
  <ul>
<li>不够甜，需要加多点糖。</li>
<li>面粉太多了，有点沉底。</li>
</ul>
]]></description><link>http://zwingz.github.io/posts/308242286.html</link><guid isPermaLink="false">308242286</guid><category><![CDATA[杂事]]></category><category><![CDATA[烘焙]]></category><category><![CDATA[生活]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Sat, 24 Mar 2018 09:13:45 GMT</pubDate></item><item><title><![CDATA[开发环境搭建]]></title><description><![CDATA[
    <h1 id="mac%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" class="heading">
      <a href="#mac%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" class="heading-anchor"></a>mac开发环境
    </h1>
  
    <h2 id="%E5%AE%89%E8%A3%85-brew" class="heading">
      <a href="#%E5%AE%89%E8%A3%85-brew" class="heading-anchor"></a>安装 brew
    </h2>
  
      <div class="hljs bash code">
        <pre><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/ruby -e "$(curl -fsSL https:/</span><span class="hljs-regexp">/raw.githubusercontent.com/</span>Homebrew<span class="hljs-regexp">/install/m</span>aster<span class="hljs-regexp">/install)"</span></pre>
      </div>
    
    <h2 id="%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83" class="heading">
      <a href="#%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83" class="heading-anchor"></a>终端环境
    </h2>
  <ul>
<li><p><a href="https://www.iterm2.com/">iterm2</a></p>
</li>
<li><p><a href="http://ohmyz.sh/">oh-my-zsh</a></p>
<p>安装</p>

      <div class="hljs bash code">
        <pre>sh -c <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></pre>
      </div>
    <p>添加插件</p>

      <div class="hljs bash code">
        <pre>vim ~<span class="hljs-string">/.zshrc</span></pre>
      </div>
    
      <div class="hljs bash code">
        <pre>plugins=(
  <span class="hljs-name">git</span>
  z
)</pre>
      </div>
    <p>​</p>
</li>
</ul>

    <h2 id="node-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" class="heading">
      <a href="#node-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" class="heading-anchor"></a>node 环境搭建
    </h2>
  <ul>
<li><p>安装 nvm</p>

      <div class="hljs shell code">
        <pre>curl -o- https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/creationix/</span>nvm<span class="hljs-regexp">/v0.33.8/i</span>nstall.sh | bash
<span class="hljs-comment"># or</span>
wget -qO- https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/creationix/</span>nvm<span class="hljs-regexp">/v0.33.8/i</span>nstall.sh | bash

</pre>
      </div>
    </li>
</ul>

    <h1 id="then" class="heading">
      <a href="#then" class="heading-anchor"></a>then
    </h1>
  
    <h1 id="vim-bash_profile-or-zshrc-or-profile-or-bashrc" class="heading">
      <a href="#vim-bash_profile-or-zshrc-or-profile-or-bashrc" class="heading-anchor"></a>vim ~/.bash_profile or ~/.zshrc or ~/.profile or ~/.bashrc
    </h1>
  
    <h1 id="insert" class="heading">
      <a href="#insert" class="heading-anchor"></a>insert
    </h1>
  <p>  export NVM_DIR=&quot;$HOME/.nvm&quot;
  [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</p>

    <h1 id="last" class="heading">
      <a href="#last" class="heading-anchor"></a>last
    </h1>
  <p>  source ~/.your_rcprofile</p>

      <div class="hljs code">
        <pre>
  ​

  使用方法

  &#x60;&#x60;&#x60;shell
  # 本地node版本
  nvm ls


  # node所有版本
  nvm ls-remote


  # 安装最新node(稳定版,即偶数版)
  nvm install --lts


  # 安装指定版本node
  nvm install v8.9.4


  # 切换到指定版本&#x2F;别名node
  nvm use v8.9.4


  # 给node版本起别名
  nvm alias default v8.9.4</pre>
      </div>
    <ul>
<li><p>安装 node</p>
<p><code>nvm install v8.9.4</code></p>
</li>
<li><p>npm 换源</p>

      <div class="hljs bash code">
        <pre><span class="hljs-meta"># npm 源</span>
npm config <span class="hljs-keyword">set</span> registry https:<span class="hljs-comment">//registry.npm.taobao.org</span>
<span class="hljs-meta"># sass 源</span>
npm config <span class="hljs-keyword">set</span> sass_binary_site https:<span class="hljs-comment">//npm.taobao.org/mirrors/node-sass/</span></pre>
      </div>
    <p>​</p>
</li>
</ul>

    <h2 id="git-%E9%85%8D%E7%BD%AE" class="heading">
      <a href="#git-%E9%85%8D%E7%BD%AE" class="heading-anchor"></a>git 配置
    </h2>
  <ul>
<li><p>安装</p>

      <div class="hljs code">
        <pre>brew install git</pre>
      </div>
    </li>
<li><p>配置 ssh-key</p>

      <div class="hljs bash code">
        <pre>git config --global user<span class="hljs-selector-class">.name</span> <span class="hljs-string">''</span>
git config --global user<span class="hljs-selector-class">.email</span> <span class="hljs-string">''</span>

ssh-keygen -t res -C <span class="hljs-string">'email'</span></pre>
      </div>
    <p>​</p>
</li>
<li><p>配置 hosts</p>

      <div class="hljs bash code">
        <pre>cd ~/.ssh
vim<span class="hljs-built_in"> config
</span>
<span class="hljs-comment"># 写入</span>
Host github.com
HostName github.com<span class="hljs-built_in">
User </span>git
IdentityFile ~/.ssh/id_rsa_github

Host gitlab.com
HostName gitlab.com<span class="hljs-built_in">
User </span>git
IdentityFile ~/.ssh/id_rsa_gitlab

</pre>
      </div>
    </li>
</ul>

    <h1 id="%E6%B3%A8%E5%85%A5%E5%AF%86%E7%A0%81%E4%B8%8B%E6%AC%A1%E4%B8%8D%E9%9C%80%E8%A6%81%E5%86%8D%E8%BE%93%E5%AF%86%E7%A0%81%E9%99%A4%E9%9D%9E%E9%87%8D%E5%90%AF" class="heading">
      <a href="#%E6%B3%A8%E5%85%A5%E5%AF%86%E7%A0%81%E4%B8%8B%E6%AC%A1%E4%B8%8D%E9%9C%80%E8%A6%81%E5%86%8D%E8%BE%93%E5%AF%86%E7%A0%81%E9%99%A4%E9%9D%9E%E9%87%8D%E5%90%AF" class="heading-anchor"></a>注入密码,下次不需要再输密码(除非重启)
    </h1>
  <p>  ssh-add -k ~/.ssh/id_rsa_gitlab</p>

      <div class="hljs code">
        <pre>
  ​

## [vscode](https:&#x2F;&#x2F;code.visualstudio.com&#x2F;) 编辑器

+ 安装插件 &#x60;Setting Sync&#x60;
+ 设置 gist &#x60;&quot;sync.gist&quot;: &quot;8162a18bd9632ab95c50704e92e1a57c&quot;&#x60;
+ 同步 Setting
+ 主要插件&#x60; eslint&#x60; &#x60;vetur&#x60; &#x60;document this&#x60; &#x60;javascript code snippets&#x60; &#x60;project manager&#x60;






开发环境搭建完毕
------------------
</pre>
      </div>
    ]]></description><link>http://zwingz.github.io/posts/303526921.html</link><guid isPermaLink="false">303526921</guid><category><![CDATA[front-end]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Thu, 08 Mar 2018 15:45:19 GMT</pubDate></item><item><title><![CDATA[vue组件-固定表格]]></title><description><![CDATA[
    <h1 id="%E5%9B%BA%E5%AE%9A%E8%A1%A8%E6%A0%BC" class="heading">
      <a href="#%E5%9B%BA%E5%AE%9A%E8%A1%A8%E6%A0%BC" class="heading-anchor"></a>固定表格
    </h1>
  <p>后台管理系统,多多少少会有列表页.</p>
<p>而列表页又正是由表格形成.</p>
<p>但是原生的表头并不能固定头部以及两侧.</p>
<p>一旦数据多了,查看起来就不方便了.</p>
<p>于是乎就出现很多固定表头/两侧的表格组件</p>

    <h2 id="%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" class="heading">
      <a href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" class="heading-anchor"></a>实现原理
    </h2>
  
    <h3 id="%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D" class="heading">
      <a href="#%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D" class="heading-anchor"></a>绝对定位
    </h3>
  <ul>
<li><p>实现方式
这种应该是最普遍也是最简单的方式.</p>
<p>就是将一个表格分成多个表格.</p>
<p>包括表头/左侧/右侧/表体, 共四个表格</p>
<p>然后通过 css 方式将表头以及两侧固定</p>
<p>之后通过 scroll 事件的监听,同步表头以及两侧的 scroll 值,就可以达到固定的效果</p>
</li>
<li><p>优点
实现起来简单,而且无缝滚动</p>
</li>
<li><p>缺点
表格都是使用 table-layout:fixed; 使得每个单元格宽度固定.</p>
<p>如果不使用 fixed 的话.则需要一个 <col> 管理每一列的宽度.</p>
<p>这样不能达到宽度自适应的情况</p>
<p>滚动必须是局部滚动.而不是跟随全局.</p>
</li>
<li><p>例子
elementUI 的表格就是这样实现的.
<img src="https://zwing.site/imgur/39962386.jpg" alt="">
同一个表格的表头,表体分别复制了3次.用来形成表头和两侧的固定.</p>
<p>使用绝对定位固定两侧.</p>
<p>通过管理 scroll 的值管理表头以及两侧滚动.</p>
<p>这样就会导致 dom 数量的增加.</p>
</li>
</ul>

    <h2 id="css-%E6%96%B9%E6%B3%95---position-sticky" class="heading">
      <a href="#css-%E6%96%B9%E6%B3%95---position-sticky" class="heading-anchor"></a>css 方法 - position: sticky
    </h2>
  <p>此方法原生支持固定表头.</p>
<p>但是目前<a href="https://caniuse.com/#feat=css-sticky">兼容性</a>不客观
<img src="https://zwing.site/imgur/67634294.jpg" alt=""></p>

    <h2 id="%E6%9C%AC%E6%96%87%E5%AE%9E%E7%8E%B0" class="heading">
      <a href="#%E6%9C%AC%E6%96%87%E5%AE%9E%E7%8E%B0" class="heading-anchor"></a>本文实现
    </h2>
  <ul>
<li><a href="http://zwing.site/vue-fixed-table/release/demo.html">DEMO</a>(原谅我没弄样式)</li>
</ul>

    <h3 id="%E8%83%8C%E6%99%AF" class="heading">
      <a href="#%E8%83%8C%E6%99%AF" class="heading-anchor"></a>背景
    </h3>
  <p>当固定表头的需求提出来时,我也是曾经想过直接使用 elementUI 的表格.</p>
<p>但是发现使用 elementUI 的表格插件需要改动不少代码.而且感觉不够灵活.</p>
<p>于是就自己去实现</p>

    <h3 id="%E7%AC%AC%E4%B8%80%E7%89%88" class="heading">
      <a href="#%E7%AC%AC%E4%B8%80%E7%89%88" class="heading-anchor"></a>第一版
    </h3>
  <p>由于考虑到不想使用 fixed 布局以及组个单元格去管理宽度.</p>
<p>而且不想使用局部滚动</p>
<p>所以一开始就决定使用 监听全局滚动+transition 方式.让表格头跟随滚动走</p>
<p>也就是说.当表头贴近浏览器上端的时候才固定.</p>
<p>而不是局部滚动式的固定.</p>
<p>这样 thead 和 tbody 就是一体,不存在宽度不一致问题</p>

    <h3 id="%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98" class="heading">
      <a href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98" class="heading-anchor"></a>兼容性问题
    </h3>
  <p>一旦thead产生了 transform. 表格的 border-collapse 会失效.表格头的边框会消失.</p>
<p>为了解决这个问题.我使用阴影来替代 border.</p>
<p>但是在 safari 上.transform 部分不会显示出阴影..暂无解</p>
<p>对于 transition 问题.</p>
<p>在 chrome 下不存在闪烁卡顿现象, 而在 Firefox 和 safari 则存在闪烁和卡顿现象.</p>
<p>由于是内部系统, 使用 chrome 居多.所以 firefox 和 safari 下只做了兼容性处理.</p>

    <h3 id="%E7%AC%AC%E4%BA%8C%E7%89%88" class="heading">
      <a href="#%E7%AC%AC%E4%BA%8C%E7%89%88" class="heading-anchor"></a>第二版
    </h3>
  <p>在第一版完成后, 基本实现了固定表格头功能. 而且在 chrome 下表现顺畅.</p>
<p>于是着手实现固定两侧.这里实现原理一样.所以很容易实现
<img src="https://zwing.site/imgur/60520413.jpg" alt=""></p>
<p>这种虽然右侧是固定在浏览器右侧.</p>
<p>但是整体页面还是被撑开的.</p>
<p>那么对于表格上下的其他组件,他们依旧是被浏览器隐藏.需要横向滚动才能看到.</p>
<p>于是我继续开始第三版改造</p>

    <h3 id="%E7%AC%AC%E4%B8%89%E7%89%88" class="heading">
      <a href="#%E7%AC%AC%E4%B8%89%E7%89%88" class="heading-anchor"></a>第三版
    </h3>
  <p>这一版主要就是为了页面的其他组件不被表格的宽高影响.也就是说不管表格多高多宽.</p>
<p>都可以在不滚动的前提下看到.</p>
<p>那么就是将表格变成局部滚动了.</p>
<p><img src="https://zwing.site/imgur/99932867.jpg" alt=""></p>
<p>其实就是一个自适应的内滚动容器.</p>
<p>前提是页面高度宽度都是100%</p>
<p>也就是说要有环境让容器产生滚动</p>
<p>监听此容器的滚动来控制表格头和两侧的固定.</p>
<p>但是收到反馈说这种表格看起来很狭小.不够大气</p>
<p><img src="https://zwing.site/imgur/42701513.jpg" alt=""></p>
<p>没办法,只能继续进行思考改进</p>

    <h3 id="%E6%80%9D%E8%80%83%E6%94%B9%E8%BF%9B" class="heading">
      <a href="#%E6%80%9D%E8%80%83%E6%94%B9%E8%BF%9B" class="heading-anchor"></a>思考改进
    </h3>
  <p>在开始之前我的想法是</p>
<p>结合第二第三版.</p>
<p>将垂直滚动交给页面.横向滚动自管理.</p>
<p>什么意思呢?</p>
<p>就是页面高度可以被撑开. 但是宽度不能被撑开.</p>
<p>也就是说全局只有 y 轴滚动.没有 x 轴滚动.</p>
<p>其实第三版是可以实现的.</p>
<p>页面只需限制宽度为100%.高度不做限制,就可以轻松的达到要求.</p>
<p><img src="https://zwing.site/imgur/27128653.jpg" alt=""></p>
<p>注意这里的高度其实没有做限制的.也就是说容器滚动条被隐藏了.</p>
<p>那如果要横向滚动怎么办.</p>
<p>很简单啊.按着 shift 再滚动就是横向滚动了.</p>
<p><img src="https://zwing.site/imgur/42701513.jpg" alt=""></p>
<p>这是不科学的.不是每个人都知道.</p>
<p>那样是不是可以有一条虚拟的横向滚动条, 来管理表格的横向滚动呢.</p>
<p>于是就有第四版</p>

    <h3 id="%E7%AC%AC%E5%9B%9B%E7%89%88" class="heading">
      <a href="#%E7%AC%AC%E5%9B%9B%E7%89%88" class="heading-anchor"></a>第四版
    </h3>
  <p>就是就是额外添加一个虚拟滚动条的组件.</p>
<p>当容器底部被浏览器隐藏时候.则平移这个滚动条至屏幕底部</p>
<ul>
<li>原生滚动条被隐藏时候,显示虚拟滚动条
<img src="https://zwing.site/imgur/24267221.jpg" alt=""></li>
<li>原生滚动条显示时候,隐藏虚拟滚动条
<img src="https://zwing.site/imgur/61056576.jpg" alt=""></li>
</ul>
<p>这样, 既能使得页面不被撑开. 同时高度也不需要限定在100%.</p>
<p>刚好能满足需求.</p>

    <h3 id="%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95" class="heading">
      <a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95" class="heading-anchor"></a>实现方法
    </h3>
  <p>实现方法其实就是使用 transform 以及监听滚动来实现固定咯.</p>
<p>但是在使用上,则需要有一定的规则.</p>
<p><img src="https://zwing.site/imgur/81508433.jpg" alt=""></p>
<p>也就是说</p>
<p>在使用的时候.要通过 slot 分别配置 head,left,right 的内容.</p>
<p>简单说就是把表格拆分成左/中/右</p>
<p>那么 thead 和 tbody 就能保持列宽度.</p>
<p>关键处理:</p>
<ul>
<li>通过 slot配置左/中/右以及表格头/表格体 </li>
</ul>
<ul>
<li>hover 样式需要通过 mouseOver 和 mouseleave 去管理</li>
<li>通过监听表格和窗口的 resize 事件,以及使用 MutationObserver 来监听表格子节点的变化来重新获取表格宽度.(因为双侧固定需要依赖左中右的宽度)</li>
<li>通过监听全局滚动, 固定表格头</li>
<li>通过监听父容器的横向滚动, 固定两侧</li>
</ul>

    <h3 id="%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84" class="heading">
      <a href="#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84" class="heading-anchor"></a>不足之处
    </h3>
  <ul>
<li><p>兼容性不太好, 在 chrome 表现良好(至少高版本的流畅), firefox 和 safari 则有卡顿现象,目前做法是在滚动时候,使用 opcity 将固定部分隐藏.滚动结束后显示</p>
</li>
<li><p>table 宽度变更时候. 右侧会有闪烁. 因为右侧固定算是很依赖表格宽度以及自身宽度.所以宽度变化对右侧影响很大. 暂未解决</p>
</li>
<li><p>需要有 css 支持. 让容易有一个可滚动的环境.</p>
</li>
<li><p>使用时候会把正常的 table 拆分成几部分. </p>
<p><img src="https://zwing.site/imgur/67633591.jpg" alt=""></p>
</li>
</ul>

    <h3 id="aligncell-%E6%98%AF%E4%BB%80%E4%B9%88-" class="heading">
      <a href="#aligncell-%E6%98%AF%E4%BB%80%E4%B9%88-" class="heading-anchor"></a>AlignCell 是什么 ?
    </h3>
  <p>其实就是 th 或者 td.</p>
<p>封装起来就是因为设计师想要达到表格每一列整体居中的前提下,左或者右对齐.</p>
<p>当然, 当数据量多的时候,每个单元格基本都是刚满足宽度. 直接左对齐是没问题的.</p>
<p>但是当数据不多.每个单元格宽度都是充足时候,这时候直接使用左对齐是不行的</p>
<p>那么,我也只好封装一层了. 这里就不介绍了</p>

    <h2 id="%E7%BB%93%E8%AF%AD" class="heading">
      <a href="#%E7%BB%93%E8%AF%AD" class="heading-anchor"></a>结语
    </h2>
  <p>虽然瑕疵比较多.但是开发整个组件过程,我个人是收获不少的.</p>
<p>由于是内部系统.也没怎么考虑兼容性.能在 chrome 顺利跑就问题不大了.</p>
<p>后续会继续优化</p>

    <h2 id="%E6%94%BE%E5%81%87%E4%BA%86-%E8%BF%87%E5%B9%B4%E4%BA%86" class="heading">
      <a href="#%E6%94%BE%E5%81%87%E4%BA%86-%E8%BF%87%E5%B9%B4%E4%BA%86" class="heading-anchor"></a>放假了, 过年了
    </h2>
  <p>祝大家新年快乐 !</p>
]]></description><link>http://zwingz.github.io/posts/295960409.html</link><guid isPermaLink="false">295960409</guid><category><![CDATA[front-end]]></category><category><![CDATA[vue]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Fri, 09 Feb 2018 18:10:56 GMT</pubDate></item><item><title><![CDATA[使用vuexStore.registerModule构建命令式组件]]></title><description><![CDATA[
    <h2 id="%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BB%84%E4%BB%B6" class="heading">
      <a href="#%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BB%84%E4%BB%B6" class="heading-anchor"></a>命令式组件
    </h2>
  <p>例如Notification, MessageBox, Alert, ConfirmBox 等等</p>
<p>这类组件都是通过命令式来调用.</p>
<p>例如<code>elementUi</code>中<code>this.$message</code>或者<code>Message</code>来调用.</p>
<p>对于我们来说,<code>this.$message</code>这种调用方法莫过于是最方便.因为不需要处处引入<code>Message</code>或者在<code>webpack</code>中配置插件使得<code>Message</code>暴露于全局</p>
<p>那么我就从<code>this.$message</code>这类讲起</p>

    <h2 id="%E7%BB%84%E4%BB%B6%E7%BC%96%E5%86%99" class="heading">
      <a href="#%E7%BB%84%E4%BB%B6%E7%BC%96%E5%86%99" class="heading-anchor"></a>组件编写
    </h2>
  <p>其实也只是编写一个Comp组件, 这里不多说.</p>

    <h2 id="%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F" class="heading">
      <a href="#%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F" class="heading-anchor"></a>接入方式
    </h2>
  
    <h3 id="%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F" class="heading">
      <a href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F" class="heading-anchor"></a>第一种接入方式
    </h3>
  <p>将<code>Vue</code>组件挂载到一个<code>dom</code>上,也就是将组件实例化.</p>
<p>然后将组件实例挂载命名空间中或者<code>Vue.prototype</code>中,</p>
<p>这样相当于直接操作组件实例的<code>methods</code>来改变组件的状态.</p>
<p><code>ElementUI</code>使用的是这种方式.</p>
<p>无入侵式</p>

    <h3 id="%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F" class="heading">
      <a href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F" class="heading-anchor"></a>第二种接入方式
    </h3>
  <p>这方式前提必须要使用Vuex, 因为他是依赖vuex.registerStore实现</p>
<p>关于registerStore请移步到<a href="https://vuex.vuejs.org/en/modules.html">文档</a>中</p>
<p>其实就是动态注册一个storeModule, 用来管理组件的状态.</p>
<p>所有操作都通过细改store的状态来引起组件的改变</p>

      <div class="hljs javascript code">
        <pre>// 引入组件
<span class="hljs-keyword">import</span> Comp from <span class="hljs-string">'Comp.vue'</span>
<span class="hljs-keyword">function</span> registerModule(store) {
    store.registerModule(<span class="hljs-string">'compNameSpaceState'</span>, {
        namespaced: true,
        state: {},
        getters: {},
        mutations: {},
        actions: {}
    })
}</pre>
      </div>
    <p>之后可以将通过对象将调用接口暴露出去</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-keyword">let</span> $compApi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// 此处需要使用建投函数,确保this指向</span>
        action: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">'compNameSpaceState/compAction'</span>)
        }
    }
}</pre>
      </div>
    <p>接下来很简单,就是将$compApi.prototype中.</p>
<p>那么如何保证<code>$compApi</code>中<code>this</code>指向<code>Vue</code>实例呢</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-keyword">let</span> bind = <span class="hljs-literal">false</span>
<span class="hljs-comment">// Vue.use() 会自动调用install方法,此时可以注册组件</span>
Comp.install = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Vue</span>) </span>{
    <span class="hljs-comment">// 代理带vue原形上.可以通过this.$spin调用</span>
    <span class="hljs-built_in">Object</span>.defineProperties(Vue.prototype, {
        <span class="hljs-attr">$compApi</span>: { <span class="hljs-comment">// 挂载到Vue.prototype中的$compApi</span>
            get() {
                <span class="hljs-keyword">if</span>(!bind) {
                    <span class="hljs-comment">// 注册store</span>
                    registerModule(<span class="hljs-keyword">this</span>.$store)
                    <span class="hljs-comment">// 只需要绑定一次即可</span>
                    <span class="hljs-comment">// 绑定后可以将原来的$compApi覆盖掉</span>
                    <span class="hljs-comment">// 调用bind函数确保this指向</span>
                    $compApi = $compApi.bind(<span class="hljs-keyword">this</span>)()
                    bind = <span class="hljs-literal">true</span>
                }
                <span class="hljs-keyword">return</span> $compApi
            }
        }
    })
    <span class="hljs-comment">// 将组件注册为Vue全局组件</span>
    Vue.component(<span class="hljs-string">'Comp'</span>, Comp)
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Comp</pre>
      </div>
    <p>最后一步则需要在App.vue将Comp挂载上去</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-comment">// 这一步自动调用install, 会全局注册Comp</span>
<span class="hljs-comment">// 但是在第一次调用$compApi时候才会进行registerStore.</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vue</span>.</span></span>use(Comp)</pre>
      </div>
    
      <div class="hljs html code">
        <pre><span class="hljs-comment">&lt;!-- App.vue--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Comp</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></pre>
      </div>
    <p>这种方法是入侵式的</p>
<p>但是可以很方便的追踪组件状态, 而且实现起来也很方便.</p>
<p>在自己开发组件的时候可以考虑</p>
]]></description><link>http://zwingz.github.io/posts/294718179.html</link><guid isPermaLink="false">294718179</guid><category><![CDATA[front-end]]></category><category><![CDATA[js]]></category><category><![CDATA[vue]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Tue, 06 Feb 2018 11:04:40 GMT</pubDate></item><item><title><![CDATA[Eventloop中的microtask和macrotask]]></title><description><![CDATA[
    <h1 id="eventloop" class="heading">
      <a href="#eventloop" class="heading-anchor"></a>EventLoop
    </h1>
  <p>js是单线程的, 所有异步都需要经过Eventloop(事件循环).这里不介绍eventloop</p>
<p> 主要记录下eventloop中的microtask 和macrotask</p>

    <h2 id="microtask" class="heading">
      <a href="#microtask" class="heading-anchor"></a>microtask
    </h2>
  <ul>
<li>process.nextTick</li>
<li>Promise</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>

    <h2 id="macrotask" class="heading">
      <a href="#macrotask" class="heading-anchor"></a>macrotask
    </h2>
  <ul>
<li>setTimeout</li>
<li>setImmediate</li>
<li>setInterval</li>
<li>UI rendering</li>
<li>网络I/O以及用户I/O</li>
<li>network</li>
</ul>

    <h2 id="%E4%BC%98%E5%85%88%E7%BA%A7" class="heading">
      <a href="#%E4%BC%98%E5%85%88%E7%BA%A7" class="heading-anchor"></a>优先级
    </h2>
  <ul>
<li>microtask &gt; macrotask</li>
<li>process.nextTick &gt; promise (process.nextTick只在node使用)</li>
<li>setTimeout和setImmediate在无IO操作下,两者执行顺序不确定,但是在IO操作下,setImmediate比setTimeout优先级高. 且setImmediate只在IE下有效</li>
</ul>

    <h2 id="%E5%BA%94%E7%94%A8" class="heading">
      <a href="#%E5%BA%94%E7%94%A8" class="heading-anchor"></a>应用
    </h2>
  <p>Vue.nextTick源码中,分别使用了microtask和macrotask</p>
<p>在Vue2.4版本之前,默认都是使用microtask.优先判断是否支持promise,如果不支持则退回到MutationObserver,如果再不支持则回退到setTimeout</p>
<p>但在后续更新中,Vue已经修改nextTick实现方式.默认使用microtask, 同时也提供方法强制使用macrotask,例如由v-on绑定的事件处理.</p>
<p>原因就是因为microtask优先级太高.甚至高于事件冒泡. 而macrotask则会引起一些问题.</p>
<p>详情请看<a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L20:4">Vue.nextTick源码</a></p>

      <div class="hljs javascript code">
        <pre><span class="hljs-comment">// Here we have async deferring wrappers using both micro and macro tasks.</span>
<span class="hljs-comment">// In &lt; 2.4 we used micro tasks everywhere, but there are some scenarios where</span>
<span class="hljs-comment">// micro tasks have too high a priority and fires in between supposedly</span>
<span class="hljs-comment">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span>
<span class="hljs-comment">// event (#6566). However, using macro tasks everywhere also has subtle problems</span>
<span class="hljs-comment">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span>
<span class="hljs-comment">// Here we use micro task by default, but expose a way to force macro task when</span>
<span class="hljs-comment">// needed (e.g. in event handlers attached by v-on).</span>
<span class="hljs-keyword">let</span> microTimerFunc
<span class="hljs-keyword">let</span> macroTimerFunc
<span class="hljs-keyword">let</span> useMacroTask = <span class="hljs-literal">false</span>

<span class="hljs-comment">// Determine (macro) Task defer implementation.</span>
<span class="hljs-comment">// Technically setImmediate should be the ideal choice, but it's only available</span>
<span class="hljs-comment">// in IE. The only polyfill that consistently queues the callback after all DOM</span>
<span class="hljs-comment">// events triggered in the same loop is by using MessageChannel.</span>
<span class="hljs-comment">/* istanbul ignore if */</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(setImmediate)) {
  macroTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setImmediate(flushCallbacks)
  }
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> MessageChannel !== <span class="hljs-string">'undefined'</span> &amp;&amp; (
  isNative(MessageChannel) ||
  <span class="hljs-comment">// PhantomJS</span>
  MessageChannel.toString() === <span class="hljs-string">'[object MessageChannelConstructor]'</span>
)) {
  <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> MessageChannel()
  <span class="hljs-keyword">const</span> port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    port.postMessage(<span class="hljs-number">1</span>)
  }
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">/* istanbul ignore next */</span>
  macroTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setTimeout(flushCallbacks, <span class="hljs-number">0</span>)
  }
}

<span class="hljs-comment">// Determine MicroTask defer implementation.</span>
<span class="hljs-comment">/* istanbul ignore next, $flow-disable-line */</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(<span class="hljs-built_in">Promise</span>)) {
  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve()
  microTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    p.then(flushCallbacks)
    <span class="hljs-comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span>
    <span class="hljs-comment">// it can get stuck in a weird state where callbacks are pushed into the</span>
    <span class="hljs-comment">// microtask queue but the queue isn't being flushed, until the browser</span>
    <span class="hljs-comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span>
    <span class="hljs-comment">// "force" the microtask queue to be flushed by adding an empty timer.</span>
    <span class="hljs-keyword">if</span> (isIOS) setTimeout(noop)
  }
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// fallback to macro</span>
  microTimerFunc = macroTimerFunc
}</pre>
      </div>
    ]]></description><link>http://zwingz.github.io/posts/294602245.html</link><guid isPermaLink="false">294602245</guid><category><![CDATA[front-end]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Tue, 06 Feb 2018 01:35:11 GMT</pubDate></item><item><title><![CDATA[多个git 配置ssh key]]></title><description><![CDATA[
    <h2 id="%E5%AE%89%E8%A3%85" class="heading">
      <a href="#%E5%AE%89%E8%A3%85" class="heading-anchor"></a>安装
    </h2>
  
      <div class="hljs bash code">
        <pre>brew install git
<span class="hljs-meta"># or</span>
<span class="hljs-meta"># apt-get install git</span>

<span class="hljs-meta">## 配置ssh-key</span>

git config --global user.name <span class="hljs-string">''</span>
git config --global user.email <span class="hljs-string">''</span>

ssh-keygen -t res -C <span class="hljs-string">'email'</span>
<span class="hljs-meta"># 然后就是自定义</span>
<span class="hljs-meta"># 要不要密码随便你</span>
<span class="hljs-meta"># 反正下面都会进行ssh-add</span></pre>
      </div>
    <p>上github或者gitlab, 进入setting,找到ssh-key, 点击new SSH Key 把id_rsa.pub内容粘贴进去就ok了</p>
<p><img src="https://user-images.githubusercontent.com/13031838/35666461-2aaa5d40-0765-11e8-9e62-1ae17cb933a2.png" alt="image"></p>

    <h2 id="%E6%A3%80%E6%9F%A5" class="heading">
      <a href="#%E6%A3%80%E6%9F%A5" class="heading-anchor"></a>检查
    </h2>
  <p><code>ssh git@github.com</code></p>
<p><img src="https://user-images.githubusercontent.com/13031838/35666525-620a3544-0765-11e8-8590-1018bdabae20.png" alt="image"></p>

    <h2 id="%E9%85%8D%E7%BD%AEhosts" class="heading">
      <a href="#%E9%85%8D%E7%BD%AEhosts" class="heading-anchor"></a>配置hosts
    </h2>
  
      <div class="hljs bash code">
        <pre>cd ~/.ssh
vim<span class="hljs-built_in"> config
</span>
Host github.com
HostName github.com<span class="hljs-built_in">
User </span>git
IdentityFile ~/.ssh/id_rsa_github

Host gitlab.com
HostName gitlab.com<span class="hljs-built_in">
User </span>git
IdentityFile ~/.ssh/id_rsa_gitlab


<span class="hljs-comment"># 注入密码,下次不需要再输密码(除非重启)</span>
ssh-<span class="hljs-builtin-name">add</span> -k ~/.ssh/id_rsa_gitlab</pre>
      </div>
    
    <h3 id="%E7%AE%80%E5%8D%95%E5%BF%AB%E6%8D%B7%E5%AE%8C%E6%88%90git%E9%85%8D%E7%BD%AE%E4%BA%86" class="heading">
      <a href="#%E7%AE%80%E5%8D%95%E5%BF%AB%E6%8D%B7%E5%AE%8C%E6%88%90git%E9%85%8D%E7%BD%AE%E4%BA%86" class="heading-anchor"></a>简单快捷完成git配置了
    </h3>
  ]]></description><link>http://zwingz.github.io/posts/293431355.html</link><guid isPermaLink="false">293431355</guid><category><![CDATA[front-end]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Thu, 01 Feb 2018 07:37:09 GMT</pubDate></item><item><title><![CDATA[记一次webpack优化 --- 从babelrc和UglifyPlugin下手]]></title><description><![CDATA[
    <h2 id="%E4%BC%98%E5%8C%96%E5%89%8D" class="heading">
      <a href="#%E4%BC%98%E5%8C%96%E5%89%8D" class="heading-anchor"></a>优化前
    </h2>
  <p>先来看优化前打包速度
大的第三方库大概有vue+axios+vueRouter+vuex+elementUI(datepicker, message两个插件)+jquery
打包总体积为2648k, 一共14个chunk(使用了异步路由)
<img src="https://user-images.githubusercontent.com/13031838/35665400-19f380fc-0761-11e8-944b-85a5117364c2.png" alt="image"></p>
<p>在我本地打包一次需要31s</p>
<p><img src="https://user-images.githubusercontent.com/13031838/35664714-26a6075a-075e-11e8-8df9-1cde8b4f1878.png" alt="image"></p>
<p>而在服务器打包时候则要70s以上, 这里就不贴图了. </p>

    <h2 id="%E4%BC%98%E5%8C%96%E5%90%8E" class="heading">
      <a href="#%E4%BC%98%E5%8C%96%E5%90%8E" class="heading-anchor"></a>优化后
    </h2>
  <p>优化后时间
打包总体积上升为2700k, 上升了50k</p>
<p><img src="https://user-images.githubusercontent.com/13031838/35665453-3ce893ea-0761-11e8-8d79-2c8b3555acb5.png" alt="image"></p>
<p>本地打包18s</p>
<p><img src="https://user-images.githubusercontent.com/13031838/35664879-c88ec336-075e-11e8-88c0-a61590c97cad.png" alt="image"></p>
<p>服务器打包时间40s</p>
<p><img src="https://user-images.githubusercontent.com/13031838/35664898-d966d888-075e-11e8-8e6b-70b4043afe8b.png" alt="image"></p>
<p><strong>提升很明显有没有</strong></p>

    <h2 id="%E4%BF%AE%E6%94%B9%E4%BA%86%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9" class="heading">
      <a href="#%E4%BF%AE%E6%94%B9%E4%BA%86%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9" class="heading-anchor"></a>修改了哪些地方?
    </h2>
  
    <h3 id="uglifeplugin" class="heading">
      <a href="#uglifeplugin" class="heading-anchor"></a>UglifePlugin
    </h3>
  <p>主要修改地方还是在UglifyPlugin配置中
由于我是用的并不是webpack自带的,而是独立的<a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin">uglifyjs-webpack-plugin</a></p>
<p>其实官方使用的也是这个插件. 只不过官方使用的暂且不是最新版,而webpack4.0-beta已经使用此插件最新版本</p>
<p>用法很简单</p>

      <div class="hljs javascript code">
        <pre><span class="hljs-variable">const</span> <span class="hljs-variable">UglifyJsPlugin</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">'uglifyjs-webpack-plugin'</span>)</span>

<span class="hljs-variable">module</span>.exports = {
  <span class="hljs-variable">plugins</span>: [
    <span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">UglifyJsPlugin</span>()</span>
  ]
}</pre>
      </div>
    <p>如果使用默认配置,那么打包速度并不会有提升.</p>
<p>而且uglifyplugin在打包过程中其实也会进行一些压缩优化,比如内敛静态变量等等.</p>
<p>那么我们可以从这里面入手,去除一切不必要的压缩优化.可以提升压缩速度.</p>
<p>同时.我们需要开启parallel和cache选项,对压缩进行缓存和多线程执行</p>
<p>具体配置规则请参考官方文档<a href="https://github.com/mishoo/UglifyJS2/tree/harmony#minify-options">UglifyOptions</a></p>
<p>我的最终配置如下</p>

      <div class="hljs javascript code">
        <pre>    <span class="hljs-string">new</span> <span class="hljs-string">UglifyEsPlugin({</span>
<span class="hljs-attr">            parallel:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
<span class="hljs-attr">            cache:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
<span class="hljs-attr">            sourceMap:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
<span class="hljs-attr">            uglifyOptions:</span> <span class="hljs-string">{</span>
<span class="hljs-attr">                ecma:</span> <span class="hljs-number">8</span><span class="hljs-string">,</span>
                <span class="hljs-string">//</span> <span class="hljs-string">详细规则</span>
                <span class="hljs-string">//</span> <span class="hljs-attr">https://github.com/mishoo/UglifyJS2/tree/harmony#minify-options</span>
<span class="hljs-attr">                compress:</span> <span class="hljs-string">{</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">在UglifyJs删除没有用到的代码时不输出警告</span>
<span class="hljs-attr">                    warnings:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">删除所有的</span> <span class="hljs-string">`console`</span> <span class="hljs-string">语句</span>
<span class="hljs-attr">                    drop_console:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">将()=&gt;{return</span> <span class="hljs-string">x}</span> <span class="hljs-string">转成</span> <span class="hljs-string">()=&gt;x</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.eslint有做检查</span>
<span class="hljs-attr">                    arrows:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">转换类似!!a</span> <span class="hljs-string">?</span> <span class="hljs-string">b</span> <span class="hljs-string">:</span> <span class="hljs-string">c</span> <span class="hljs-string">→</span> <span class="hljs-string">a</span> <span class="hljs-string">?</span> <span class="hljs-string">b</span> <span class="hljs-string">:</span> <span class="hljs-string">c</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.eslint做检查</span>
<span class="hljs-attr">                    booleans:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">转换由计算得来的属性名</span> <span class="hljs-string">{["computed"]:</span> <span class="hljs-number">1</span><span class="hljs-string">}</span> <span class="hljs-string">is</span> <span class="hljs-string">converted</span> <span class="hljs-string">to</span> <span class="hljs-string">{computed:</span> <span class="hljs-number">1</span><span class="hljs-string">}.</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭,eslint做检查</span>
<span class="hljs-attr">                    computed_props:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">自动转换判断</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">e.g.</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> <span class="hljs-type">!b</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-type">!c</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-type">!d</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-type">!e</span> <span class="hljs-string">→</span> <span class="hljs-string">a=!(b||c||d||e)</span> <span class="hljs-string">etc.</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭,请自行做规范</span>
<span class="hljs-attr">                    comparisons:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">去掉死代码</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.eslint做检查</span>
<span class="hljs-attr">                    dead_code:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭debugger</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">eslint做检查</span>
<span class="hljs-attr">                    drop_debugger:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">自动进行静态算术计算</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">开启</span>
<span class="hljs-attr">                    evaluate:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">函数声明提升</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">默认就是关闭,不需要开启</span>
<span class="hljs-attr">                    hoist_funs:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">For</span> <span class="hljs-attr">example:</span> <span class="hljs-string">var</span> <span class="hljs-string">o={p:1,</span> <span class="hljs-attr">q:2};</span> <span class="hljs-string">f(o.p,</span> <span class="hljs-string">o.q);</span> <span class="hljs-string">is</span> <span class="hljs-string">converted</span> <span class="hljs-string">to</span> <span class="hljs-string">f(1,</span> <span class="hljs-number">2</span><span class="hljs-string">);</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">不需要咯</span>
<span class="hljs-attr">                    hoist_props:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">变量提升</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">不需要咯</span>
<span class="hljs-attr">                    hoist_vars:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span>  <span class="hljs-string">optimizations</span> <span class="hljs-string">for</span> <span class="hljs-string">if/return</span> <span class="hljs-string">and</span> <span class="hljs-string">if/continue</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">不需要,</span> <span class="hljs-string">eslint做检查</span>
<span class="hljs-attr">                    if_return:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">/**</span>
                     <span class="hljs-string">*</span> <span class="hljs-string">无法用言语表达,自行理解</span>
                     <span class="hljs-string">*</span> <span class="hljs-string">inline</span> <span class="hljs-string">(default:</span> <span class="hljs-literal">true</span><span class="hljs-string">)</span> <span class="hljs-bullet">--</span> <span class="hljs-string">inline</span> <span class="hljs-string">calls</span> <span class="hljs-string">to</span> <span class="hljs-string">function</span> <span class="hljs-string">with</span> <span class="hljs-string">simple/return</span> <span class="hljs-attr">statement:</span>
                        <span class="hljs-literal">false</span> <span class="hljs-bullet">--</span> <span class="hljs-string">same</span> <span class="hljs-string">as</span> <span class="hljs-number">0</span>
                        <span class="hljs-number">0</span> <span class="hljs-bullet">--</span> <span class="hljs-string">disabled</span> <span class="hljs-string">inlining</span>
                        <span class="hljs-number">1</span> <span class="hljs-bullet">--</span> <span class="hljs-string">inline</span> <span class="hljs-string">simple</span> <span class="hljs-string">functions</span>
                        <span class="hljs-number">2</span> <span class="hljs-bullet">--</span> <span class="hljs-string">inline</span> <span class="hljs-string">functions</span> <span class="hljs-string">with</span> <span class="hljs-string">arguments</span>
                        <span class="hljs-number">3</span> <span class="hljs-bullet">--</span> <span class="hljs-string">inline</span> <span class="hljs-string">functions</span> <span class="hljs-string">with</span> <span class="hljs-string">arguments</span> <span class="hljs-string">and</span> <span class="hljs-string">variables</span>
                        <span class="hljs-literal">true</span> <span class="hljs-bullet">--</span> <span class="hljs-string">same</span> <span class="hljs-string">as</span> <span class="hljs-number">3</span>
                     <span class="hljs-string">*/</span>
<span class="hljs-attr">                    inline:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">join</span> <span class="hljs-string">consecutive</span> <span class="hljs-string">var</span> <span class="hljs-string">statements</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">就是将变量声明合并到一个var中</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭,</span> <span class="hljs-string">eslin做检查</span>
<span class="hljs-attr">                    join_vars:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">自动去除无用的function参数</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.</span> <span class="hljs-string">eslint做检查</span>
<span class="hljs-attr">                    keep_fargs:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span>  <span class="hljs-string">Pass</span> <span class="hljs-literal">true</span> <span class="hljs-string">to</span> <span class="hljs-string">prevent</span> <span class="hljs-string">Infinity</span> <span class="hljs-string">from</span> <span class="hljs-string">being</span> <span class="hljs-string">compressed</span> <span class="hljs-string">into</span> <span class="hljs-number">1</span><span class="hljs-string">/0</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">禁止将infinity转成1/0</span>
<span class="hljs-attr">                    keep_infinity:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">optimizations</span> <span class="hljs-string">for</span> <span class="hljs-string">do,</span> <span class="hljs-string">while</span> <span class="hljs-string">and</span> <span class="hljs-string">for</span> <span class="hljs-string">loops</span> <span class="hljs-string">when</span> <span class="hljs-string">we</span> <span class="hljs-string">can</span> <span class="hljs-string">statically</span> <span class="hljs-string">determine</span> <span class="hljs-string">the</span> <span class="hljs-string">condition.</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">优化循环</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">此处关闭,应该由开发者自行优化</span>
<span class="hljs-attr">                    loops:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">negate</span> <span class="hljs-string">"Immediately-Called Function Expressions"</span> <span class="hljs-string">where</span> <span class="hljs-string">the</span> <span class="hljs-string">return</span> <span class="hljs-string">value</span> <span class="hljs-string">is</span> <span class="hljs-string">discarded,</span> <span class="hljs-string">to</span> <span class="hljs-string">avoid</span> <span class="hljs-string">the</span> <span class="hljs-string">parens</span> <span class="hljs-string">that</span> <span class="hljs-string">the</span> <span class="hljs-string">code</span> <span class="hljs-string">generator</span> <span class="hljs-string">would</span> <span class="hljs-string">insert.</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">自行体会</span>
<span class="hljs-attr">                    negate_iife:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span>  <span class="hljs-string">rewrite</span> <span class="hljs-string">property</span> <span class="hljs-string">access</span> <span class="hljs-string">using</span> <span class="hljs-string">the</span> <span class="hljs-string">dot</span> <span class="hljs-string">notation,</span> <span class="hljs-string">for</span> <span class="hljs-string">example</span> <span class="hljs-string">foo["bar"]</span> <span class="hljs-string">→</span> <span class="hljs-string">foo.bar</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.eslint检查</span>
<span class="hljs-attr">                    properties:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">将只用到一次的function,通过inline方式插入</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">关闭.开发者自行把控</span>
<span class="hljs-attr">                    reduce_funcs:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">将静态变量直接lnline紧代码里</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">可以开启</span>
<span class="hljs-attr">                    reduce_vars:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">使用逗号运算符连接连续的简单语句</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">自行把控</span>
<span class="hljs-attr">                    sequences:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">/**</span>
                     <span class="hljs-string">*</span>  <span class="hljs-string">Pass</span> <span class="hljs-literal">false</span> <span class="hljs-string">to</span> <span class="hljs-string">disable</span> <span class="hljs-string">potentially</span> <span class="hljs-string">dropping</span> <span class="hljs-string">functions</span> <span class="hljs-string">marked</span> <span class="hljs-string">as</span> <span class="hljs-string">"pure"</span><span class="hljs-string">.</span> 
                     <span class="hljs-string">*</span> <span class="hljs-string">A</span> <span class="hljs-string">function</span> <span class="hljs-string">call</span> <span class="hljs-string">is</span> <span class="hljs-string">marked</span> <span class="hljs-string">as</span> <span class="hljs-string">"pure"</span> <span class="hljs-string">if</span> <span class="hljs-string">a</span> <span class="hljs-string">comment</span> <span class="hljs-string">annotation</span> <span class="hljs-string">\/*@__PURE__*\/</span> <span class="hljs-string">or</span> <span class="hljs-string">\/*#__PURE__*\/</span> <span class="hljs-string">immediately</span> <span class="hljs-string">precedes</span> <span class="hljs-string">the</span> <span class="hljs-string">call.</span> 
                     <span class="hljs-string">*</span> <span class="hljs-string">For</span> <span class="hljs-attr">example:</span> <span class="hljs-string">\/*@__PURE__*\/foo();</span>
                     <span class="hljs-string">*</span> <span class="hljs-string">就是关闭标注纯函数的注释了</span>
                     <span class="hljs-string">*/</span>
<span class="hljs-attr">                    side_effects:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">去掉重复和无法到达的switch分支</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">eslint做检查,</span> <span class="hljs-string">以及开发者把控</span>
<span class="hljs-attr">                    switches:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                    <span class="hljs-string">//</span> <span class="hljs-string">Transforms</span> <span class="hljs-string">typeof</span> <span class="hljs-string">foo</span> <span class="hljs-string">==</span> <span class="hljs-string">"undefined"</span> <span class="hljs-string">into</span> <span class="hljs-string">foo</span> <span class="hljs-string">===</span> <span class="hljs-string">void</span> <span class="hljs-number">0</span>
<span class="hljs-attr">                    typeofs:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
                <span class="hljs-string">}</span>
            <span class="hljs-string">}</span></pre>
      </div>
    <p>其实很多优化点都是可以通过eslint来检查,而不需要在压缩过程检查</p>
<p>再配合自身的开发习惯以及规范,可以去掉很多压缩检查, 压缩效率就能提升</p>
<p>但是带来的负面影响就是压缩体积会有上升/</p>
<p>因为对于第三方库来说,并不会安装项目配置的eslint来跑.自然就达不到要求.</p>
<p>再少了uglifyplugin的压缩优化,体积就会上升.</p>
<p>以我的例子来看,总体积上升了50k. 尚可以接受.</p>
<p>而打包时间足足提升了30s. </p>
<p>但可能也有人说上线打包不必在乎打包时间.</p>
<p>其实这些都看具体业务需求,以及自身的开发规范来配置.</p>
<p>重要的还是在打包速度和打包体积两者中找出一个最合适的平衡点</p>

    <h3 id="babelrc" class="heading">
      <a href="#babelrc" class="heading-anchor"></a>babelrc
    </h3>
  <p>其实babel并不会影响到打包速度.我也只是顺便提下</p>
<p>我的配置如下</p>

      <div class="hljs javascript code">
        <pre>{
    <span class="hljs-attr">"plugins"</span>: [
        [
            <span class="hljs-string">"component"</span>,
            [{
                <span class="hljs-attr">"libraryName"</span>: <span class="hljs-string">"element-ui"</span>,
                <span class="hljs-attr">"styleLibraryName"</span>: <span class="hljs-string">"theme-default"</span>
            }]]
    ],
    <span class="hljs-attr">"comments"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"env"</span>: {
        <span class="hljs-attr">"development"</span>: {
            <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"transform-object-rest-spread"</span>, <span class="hljs-string">"syntax-dynamic-import"</span>]
        },
        <span class="hljs-attr">"production"</span>: {
            <span class="hljs-attr">"presets"</span>: [[<span class="hljs-string">"es2015"</span>, {<span class="hljs-attr">"modules"</span>: <span class="hljs-literal">false</span>}], <span class="hljs-string">"stage-2"</span>],
            <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"transform-runtime"</span>]
        },
        <span class="hljs-attr">"test"</span>: {
            <span class="hljs-attr">"presets"</span>: [<span class="hljs-string">"env"</span>, <span class="hljs-string">"stage-2"</span>],
            <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"transform-runtime"</span>, <span class="hljs-string">"istanbul"</span>]
        }
    }
}
</pre>
      </div>
    <p>我把babel配置区分成了三个阶段,开发,生产和测试.</p>
<p>在开发过程不使用preset,直接跑原生代码. </p>
<p>在生产环境则使用es2015的preset</p>
<p>也许这样能提高开发环境的编译速度? 暂时不清楚,因为没感觉.一向很快.</p>
<p>这也看个人喜好了.</p>

    <h2 id="ps" class="heading">
      <a href="#ps" class="heading-anchor"></a>ps
    </h2>
  <p>eslint的作用真的很大很大.</p>
<p>但是在开发阶段使用eslint真的很烦很烦.</p>
<p>所以,我目前的做法就是在开发阶段关闭eslint检查.因为我的vscode有带插件提示</p>
<p>即便检查到有错误,也可以正常编译.</p>
<p>但是在commit的时候添加了一层pre-commit来对修改的文件执行eslint.</p>
<p>这样就确保上传到git的代码是经过eslint检查的</p>
<p>这样既能确保开发不被干扰,也能确保代码能按照规范.</p>
]]></description><link>http://zwingz.github.io/posts/293426099.html</link><guid isPermaLink="false">293426099</guid><category><![CDATA[front-end]]></category><category><![CDATA[webpack]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Thu, 01 Feb 2018 07:13:03 GMT</pubDate></item><item><title><![CDATA[烹饪和烘焙的点滴]]></title><description><![CDATA[<p>突然想写些什么..
那就写下这周做了什么吃的..
除了晚餐之外.
这周做了特别的可能就是<strong>炸薯条</strong>, <strong>火烧云</strong>以及<strong>芒果千层</strong>了.
下面就大概回忆下过程</p>

    <h2 id="%E7%82%B8%E8%96%AF%E6%9D%A1" class="heading">
      <a href="#%E7%82%B8%E8%96%AF%E6%9D%A1" class="heading-anchor"></a>炸薯条
    </h2>
  <p>  其实炸薯条本不是本人的意思, 只是女友说突然想吃薯条, 就在买菜的时候买多了一个土豆.
  由于不是本人的意思,过程也只是大概记得.</p>
<ul>
<li>土豆去皮, 切成条</li>
<li>用保鲜袋装好,放冰箱冷冻(其实嘛.我也不知道这一步是不是必须,也可能是那晚我们吃得饱,所以才放冰箱,留到下次弄得)</li>
<li>先把薯条煮一边,放盐, 软了后捞出</li>
<li>倒掉水, 并擦干平底锅</li>
<li>放油,(新买的一瓶油我放了三分一)</li>
<li>油热了之后把薯条放进去炸就ok了..</li>
<li>炸完捞出可以再撒些盐. 然后放置一阵子就能吃了</li>
</ul>
<p>其实一开始全程都是女友在弄.只不过她炸的时候油放的太少了..然后跑过来跟我说像是在炒薯条..
于是乎我就自己上了..其实这也是我第一次炸薯条.
炸完之后油也只能倒掉.感觉很浪费.炸一个土豆用了1/3瓶油..
感觉以后都不会再炸东西了.除非量大. 这里就没图了.很简单的</p>

    <h2 id="%E7%81%AB%E7%83%A7%E4%BA%91" class="heading">
      <a href="#%E7%81%AB%E7%83%A7%E4%BA%91" class="heading-anchor"></a>火烧云
    </h2>
  <p>  这个其实我上星期就有做过了.只不过做失败了.
  其实就是面包再加工一下啦, 外表看起来逼格挺高. 吃起来也还ok</p>
<ul>
<li>材料(鸡蛋两个, 吐司(方包)4片, 炼奶, 沙拉酱)</li>
<li>蛋清分离, 用蛋清分离器分离, 将蛋清倒入无水碗中, 然后将蛋黄放另外一个碗(两个鸡蛋的蛋清可以放于同一个碗中, 蛋黄必须放于两个不同的碗, 同时蛋黄一定不能破, 一旦破了混入到了蛋清中,就不容易打发蛋清了, 上周失败就是因为分离的时候蛋黄破了, 导致打发失败)</li>
<li>将蛋清倒入打蛋盆中, 加入一勺糖(根据自己喜好添加), 使用电动打蛋器进行打发, 当出现纹路的时候, 再加入一勺糖, 继续打发, 当感觉打发出现阻力时候, 继续加入一勺糖, 继续打发. 直到达到硬性打发程度, 就是打蛋器提起来, 蛋清不会掉下来, 就像我们平常吃的奶油一样. 整个步骤一定不能有水, 有水就不容易打发了. 砂糖除了调味, 还能促进打发</li>
<li>此时我们有的东西就是打发了的蛋清,以及两个蛋黄</li>
<li>取一片吐司, 涂上一层炼奶, 再涂上一层沙拉酱(也可以是其他,也可以不要,看个人), 再取一片方包, 盖在上面.</li>
<li>用刮刀将打发的蛋清涂到上一步中的吐司上方, 一共取一般的蛋清, 并对其进行造型, 弄成你觉得好看的样子.</li>
<li>在蛋清中间挖个孔, 将蛋黄倒进去, 此时已经完成一个火烧云了.</li>
<li>另一个就根据上述步骤一样就行</li>
<li>烤箱150度预热5分钟</li>
<li>将面包放入烤箱15分钟即可</li>
<li>这时候的蛋黄其实是溏心蛋, 我个人是很喜欢</li>
</ul>
<p>就是由于上周失败了, 并且找到原因, 所以这周就铁了心要把它完成. 当然这里肯定有图了</p>
<ul>
<li><p>这是入烤箱前
<img src="https://zwing.site/imgur/645802.jpg" alt=""></p>
</li>
<li><p>烤完后
<img src="https://zwing.site/imgur/84359394.jpg" alt="">
味道还是不错的, 也挺简单.</p>
</li>
</ul>

    <h2 id="%E8%8A%92%E6%9E%9C%E5%8D%83%E5%B1%82" class="heading">
      <a href="#%E8%8A%92%E6%9E%9C%E5%8D%83%E5%B1%82" class="heading-anchor"></a>芒果千层
    </h2>
  <p>做这个芒果千层, 耗时3小时, 也是不容易啊
这里先上图, 之后再补充制作过程
<img src="https://zwing.site/imgur/38760413.jpg" alt=""></p>

    <h2 id="%E5%85%B6%E4%BB%96" class="heading">
      <a href="#%E5%85%B6%E4%BB%96" class="heading-anchor"></a>其他
    </h2>
  <p>其实烤箱双十一就购入了, 同时也购入了一批烘焙工具,从此入了烘焙的坑,
不入不知道, 一入深似海
这里就顺便贴下图吧.过程就先忽略了</p>
<ul>
<li>鸡蛋布丁
<img src="https://zwing.site/imgur/42554020.jpg" alt=""></li>
</ul>
<ul>
<li>西多士
<img src="https://zwing.site/imgur/69072942.jpg" alt="">
<img src="https://raw.githubusercontent.com/zWingz/imgur/master/52877777.jpg" alt=""></li>
</ul>
<ul>
<li>蛋挞
<img src="https://zwing.site/imgur/59916873.jpg" alt="">
<img src="https://zwing.site/imgur/70796582.jpg" alt="">
<img src="https://zwing.site/imgur/48233877.jpg" alt=""></li>
</ul>
<ul>
<li>风琴土豆
<img src="https://zwing.site/imgur/33495732.jpg" alt=""></li>
</ul>
]]></description><link>http://zwingz.github.io/posts/292217983.html</link><guid isPermaLink="false">292217983</guid><category><![CDATA[烘焙]]></category><category><![CDATA[生活]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Sun, 28 Jan 2018 16:34:04 GMT</pubDate></item><item><title><![CDATA[vue后台系统开发实践]]></title><description><![CDATA[
    <h1 id="vue%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5" class="heading">
      <a href="#vue%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5" class="heading-anchor"></a>Vue后台系统开发实践
    </h1>
  
    <h2 id="%E4%BE%9D%E8%B5%96%E5%BA%93" class="heading">
      <a href="#%E4%BE%9D%E8%B5%96%E5%BA%93" class="heading-anchor"></a>依赖库
    </h2>
  <ul>
<li><a href="mailto:vue@2.4.4">vue@2.4.4</a></li>
<li><a href="mailto:vue-router@3.0.0">vue-router@3.0.0</a></li>
<li><a href="mailto:vuex@3.0.0">vuex@3.0.0</a></li>
<li>axios</li>
<li>element-ui</li>
</ul>

    <h2 id="%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B" class="heading">
      <a href="#%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B" class="heading-anchor"></a>搭建流程
    </h2>
  <ol>
<li><p><a href="https://github.com/zWingz/vue-webpack-template">webpack-template</a></p>
</li>
<li><p>createApp.js, createRouter.js, store.js, http.js</p>
<ul>
<li>createaApp.js 多页时候用来配置各个页面相同的vue选项,比如配置api,mixin等等</li>
<li>createRouter.js 多页时候用到配置各个页面相同的路由选项,比如配置路由模式,路由钩子等等</li>
<li>store.js 配置全局状态管理.state,action,mutation,getter</li>
<li>http.js 配置异步请求, 例如: baseRoot, 请求钩子interceptors</li>
</ul>
</li>
<li><p>utils.js, ConstValue.js, mixin.js, registerComponent.js</p>
<ul>
<li>utils.js 工具类函数</li>
<li>ConstValue.js 常量,例如: isProduction, httpRoot(后端地址)</li>
<li>mixin.js 混合</li>
<li>registerComponent.js 将经常用到的组件在这里引入并注册为全局组件</li>
</ul>
</li>
<li><p>route.js, app.js</p>
<ul>
<li>route/.js 具体的路由</li>
<li>app.js 每个页面的app启动页</li>
</ul>
</li>
<li><p>page-view&amp;components</p>
<ul>
<li>页面级内容</li>
</ul>
</li>
</ol>

    <h2 id="%E5%90%8E%E5%8F%B0%E5%A4%A7%E8%87%B4%E5%86%85%E5%AE%B9" class="heading">
      <a href="#%E5%90%8E%E5%8F%B0%E5%A4%A7%E8%87%B4%E5%86%85%E5%AE%B9" class="heading-anchor"></a>后台大致内容
    </h2>
  <ul>
<li>登录/权限</li>
<li>列表页</li>
<li>详情/审核页</li>
<li>创建/修改页</li>
</ul>

    <h2 id="%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90" class="heading">
      <a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90" class="heading-anchor"></a>问题分析
    </h2>
  <ul>
<li><p>登录/权限</p>
<ul>
<li>登录态的保存.以及用户权限的判断<ol>
<li>后端设置sessionid, 前端只需要在axios配置withCredentials=true.(此方法在Safari行不通,safari默认选项(仅)允许来自我访问的网站, 由于后端地址不是直接访问.所以safari不会带上cookie去请求.部署的时候将前后端都部署到同一个nginx就可以解决)</li>
<li>json web token(jwt)</li>
<li>后端生成token,并由保存在http header.</li>
<li>权限判断一种是导航显示控制,一种是直接通过url进去后的判断</li>
</ol>
</li>
</ul>
</li>
<li><p>列表页</p>
<ul>
<li><p>内容过多.会引起页面滚动.表头以及两侧需固定</p>
<ol>
<li>全局滚动.(表格过大.页面整体会被撑开)</li>
<li>容器内滚动.(表格显得很狭窄)</li>
<li>垂直方向全局滚动, 水平方向是局部滚动. (页面宽度不被撑开, 加虚拟滚动条辅助时候水平滚动不需要拉到最后)</li>
<li><a href="https://zwingz.github.io/vue-fixed-table/release/demo.html">Demo</a></li>
</ol>
</li>
<li><p>有很多的查询条件</p>
<ul>
<li>查询需要被保留,同时url需要被查询条件修改(<code>$router.replace</code>)</li>
</ul>
</li>
<li><p>每一个列表页类似.但又有不同,主要差异在于查询条件以及表格内容</p>
<ul>
<li>使用mixin</li>
<li>设置查询query</li>
<li>根据query以及url获取数据</li>
<li>对数据进行处理,比如: loading态设为false, 初始化多选等. 看具体</li>
</ul>
</li>
<li><p>列表页/详情页切换后列表数据的保存(保留列表页状态)</p>
<ul>
<li>vuex(全局状态管理, 写起来会很多,一个页面一个state,action,mutation,getters)</li>
<li>keepAlive(active/mounted获取数据, active会导致数据次数过多, mounted会导致数据不同步. 此时可以使用trigger,主动触发列表页拉取数据)</li>
</ul>
</li>
</ul>
</li>
<li><p>详情页/审核页</p>
<ul>
<li><p>数据展示形式类似. 形如: label: content;</p>
<ul>
<li>声明式会导致页面重复内容过多</li>
<li>封装Field组件,通过js去配置数据展示</li>
</ul>
</li>
<li><p>布局类似</p>
<ul>
<li>这是无解的,除非真的很像很像.就可以用mixin解决</li>
</ul>
</li>
</ul>
</li>
<li><p>创建/修改页</p>
<ul>
<li><p>数据形式类似. 形如: label: form</p>
<ul>
<li>声明式同样导致重复内容过多</li>
<li>依然使用封装的Field组件,通过js去配置form.</li>
</ul>
</li>
<li><p>数据验证. 简单点就是能否提交</p>
<ul>
<li>要么逐个验证</li>
<li>要么简单粗暴添加一个canSave的computed.保证数据不为空</li>
</ul>
</li>
</ul>
</li>
</ul>

    <h2 id="%E7%BB%84%E4%BB%B6" class="heading">
      <a href="#%E7%BB%84%E4%BB%B6" class="heading-anchor"></a>组件
    </h2>
  <ul>
<li><p>Table(如上所说) <a href="https://zwingz.github.io/vue-fixed-table/release/demo.html">Demo</a></p>
</li>
<li><p>LoadingBar(顶部的进度条,主要是切换路由时候出现,挂在beforeEach和afterEach中调用, 有异步路由时候建议使用)</p>
</li>
<li><p>Message(消息提示)</p>

    <h4 id="%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" class="heading">
      <a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" class="heading-anchor"></a>实现方式
    </h4>
  
      <div class="hljs code">
        <pre>  1. 使用createElement创建dom元素,并且把message组件挂载上去即可,不过需要使用到vue完整版
  2. 将组件挂在到App.vue中,并使用vuex管理其状态. 可以在初次调用message时候才注册store</pre>
      </div>
    </li>
<li><p>Modal 没什么好说.哪里用到就声明一个Modal.</p>
</li>
<li><p>Confirm(确认式提升,与message一样的实现方式)</p>
</li>
<li><p>AsyncButton(会触发异步操作的按钮,监听异步请求的路由,当请求未结束时button处于loading态.)</p>
</li>
<li><p>AutoCompleteInput(带搜索建议的Input. 可以封装多装搜索框)</p>
</li>
<li><p>Panel (可收缩面包.很简单)</p>
</li>
<li><p>Field (label: content\form; 类型展示组件)</p>
</li>
<li><p>Pagination (分页,很简单)</p>
</li>
<li><p>Tree (树, 使用递归组件即可, 如果要做节点多选, 管理选择状态会比较麻烦.)</p>
</li>
<li><p>Select, Checkbox, Radio, Switch (自定义组件v-model即可,简单)</p>
</li>
<li><p>Spin (请求时间很长的时候, 可以弹出model,并构建一个假的进度条. 上传文件的时候也能用到,当然这时候的进度是真实的.通过onprogress获取)</p>
</li>
<li><p>BackToTop (回到顶部, 加个贝塞尔动画就好了)</p>
</li>
<li><p>Scroller (自定义非原生滚动条, 建议直接用css来设置原生scroll样式.目前应该firefox不支持设置原生滚动条样式)</p>
</li>
<li><p>Img (hover时候出现蒙层.点击时候出现查看器)</p>
</li>
</ul>

    <h2 id="%E5%BB%BA%E8%AE%AE" class="heading">
      <a href="#%E5%BB%BA%E8%AE%AE" class="heading-anchor"></a>建议
    </h2>
  <ol>
<li><p>如果对组件进行for命令,必须加上:key,这是官方指定.
 但对于原生dom进行for循环时候.其实可以不加:key,或者使用index作为key. 
 一旦设置了key,只有key得值不一样,会直接销毁重建dom. 那么用index作为key的话,则只会更新dom而不会销毁重建</p>
</li>
<li><p>任何通过addEventListeners添加的监听事件,销毁时最好使用removeEventListeners给去掉</p>
</li>
<li><p>如果不需要运行时构建,可以在webpack中指定使用vue.runtime.js, 会剩了几十k体积</p>
</li>
<li><p>sass-loader前再加一层sass-resources-loader可以将一些变量或者方法全局引入,那就不用到处import了.</p>
</li>
</ol>

      <div class="hljs code">
        <pre>    {
        loader: &#39;sass-resources-loader&#39;,
        options: {
            resources: [path.resolve(__dirname, &#39;..&#x2F;src&#x2F;sass&#x2F;variable.scss&#39;)]
        }
    }</pre>
      </div>
    
    <h2 id="%E5%AE%89%E5%88%A9" class="heading">
      <a href="#%E5%AE%89%E5%88%A9" class="heading-anchor"></a>安利
    </h2>
  <p><a href="https://fundebug.com/">Fundebug</a></p>
<p><a href="https://www.easy-mock.com/">EasyMock</a></p>
<p><a href="http://apizza.cc/account">Apizza</a></p>
]]></description><link>http://zwingz.github.io/posts/275254986.html</link><guid isPermaLink="false">275254986</guid><category><![CDATA[front-end]]></category><category><![CDATA[js]]></category><category><![CDATA[vue]]></category><category><![CDATA[webpack]]></category><dc:creator><![CDATA[zWingz]]></dc:creator><pubDate>Mon, 20 Nov 2017 07:02:07 GMT</pubDate></item></channel></rss>