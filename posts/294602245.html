<!doctype html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="description" content="Just a blog."><link rel="stylesheet" href="/css/style.css"><title>Eventloop中的microtask和macrotask - zWing</title><link rel="stylesheet" href="/css/highlight.ocean.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"></head><body><canvas id="ribbon"></canvas><div class="main"><div class="header"><a class="logo" href="/">zWing</a><div class="menu"><a href="/archives/">Archives</a><a href="/about/">About</a></div><div class="social"><a target="_blank" href="https://github.com/zWingz/my-blog-config/issues"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"></path></svg></a><a target="_blank" href="/rss.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.18,15.64A2.18,2.18 0 0,1 8.36,17.82C8.36,19 7.38,20 6.18,20C5,20 4,19 4,17.82A2.18,2.18 0 0,1 6.18,15.64M4,4.44A15.56,15.56 0 0,1 19.56,20H16.73A12.73,12.73 0 0,0 4,7.27V4.44M4,10.1A9.9,9.9 0 0,1 13.9,20H11.07A7.07,7.07 0 0,0 4,12.93V10.1Z"></path></svg></a></div></div><div id="post" class="center"><div class="toc"><div class="stay"><ul><li><a href="#eventloop">EventLoop</a><ul><li><a href="#microtask">microtask</a></li><li><a href="#macrotask">macrotask</a></li><li><a href="#%E4%BC%98%E5%85%88%E7%BA%A7">优先级</a></li><li><a href="#%E5%BA%94%E7%94%A8">应用</a></li></ul></li></ul><span class="toc-icon"></span></div></div><div class="post-content"><p class="time">February 06, 2018</p><h1 class="title">Eventloop中的microtask和macrotask</h1><div class="content"><h1 id="eventloop" class="heading"><a href="#eventloop" class="heading-anchor"></a>EventLoop</h1><p>js是单线程的, 所有异步都需要经过Eventloop(事件循环).这里不介绍eventloop</p><p>主要记录下eventloop中的microtask 和macrotask</p><h2 id="microtask" class="heading"><a href="#microtask" class="heading-anchor"></a>microtask</h2><ul><li>process.nextTick</li><li>Promise</li><li>Object.observe</li><li>MutationObserver</li></ul><h2 id="macrotask" class="heading"><a href="#macrotask" class="heading-anchor"></a>macrotask</h2><ul><li>setTimeout</li><li>setImmediate</li><li>setInterval</li><li>UI rendering</li><li>网络I/O以及用户I/O</li><li>network</li></ul><h2 id="%E4%BC%98%E5%85%88%E7%BA%A7" class="heading"><a href="#%E4%BC%98%E5%85%88%E7%BA%A7" class="heading-anchor"></a>优先级</h2><ul><li>microtask &gt; macrotask</li><li>process.nextTick &gt; promise (process.nextTick只在node使用)</li><li>setTimeout和setImmediate在无IO操作下,两者执行顺序不确定,但是在IO操作下,setImmediate比setTimeout优先级高. 且setImmediate只在IE下有效</li></ul><h2 id="%E5%BA%94%E7%94%A8" class="heading"><a href="#%E5%BA%94%E7%94%A8" class="heading-anchor"></a>应用</h2><p>Vue.nextTick源码中,分别使用了microtask和macrotask</p><p>在Vue2.4版本之前,默认都是使用microtask.优先判断是否支持promise,如果不支持则退回到MutationObserver,如果再不支持则回退到setTimeout</p><p>但在后续更新中,Vue已经修改nextTick实现方式.默认使用microtask, 同时也提供方法强制使用macrotask,例如由v-on绑定的事件处理.</p><p>原因就是因为microtask优先级太高.甚至高于事件冒泡. 而macrotask则会引起一些问题.</p><p>详情请看<a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L20:4">Vue.nextTick源码</a></p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
</pre></td><td class="code"><pre><span class="hljs-comment">// Here we have async deferring wrappers using both micro and macro tasks.</span>
<span class="hljs-comment">// In &lt; 2.4 we used micro tasks everywhere, but there are some scenarios where</span>
<span class="hljs-comment">// micro tasks have too high a priority and fires in between supposedly</span>
<span class="hljs-comment">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span>
<span class="hljs-comment">// event (#6566). However, using macro tasks everywhere also has subtle problems</span>
<span class="hljs-comment">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span>
<span class="hljs-comment">// Here we use micro task by default, but expose a way to force macro task when</span>
<span class="hljs-comment">// needed (e.g. in event handlers attached by v-on).</span>
<span class="hljs-keyword">let</span> microTimerFunc
<span class="hljs-keyword">let</span> macroTimerFunc
<span class="hljs-keyword">let</span> useMacroTask = <span class="hljs-literal">false</span>

<span class="hljs-comment">// Determine (macro) Task defer implementation.</span>
<span class="hljs-comment">// Technically setImmediate should be the ideal choice, but it's only available</span>
<span class="hljs-comment">// in IE. The only polyfill that consistently queues the callback after all DOM</span>
<span class="hljs-comment">// events triggered in the same loop is by using MessageChannel.</span>
<span class="hljs-comment">/* istanbul ignore if */</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(setImmediate)) {
  macroTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setImmediate(flushCallbacks)
  }
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> MessageChannel !== <span class="hljs-string">'undefined'</span> &amp;&amp; (
  isNative(MessageChannel) ||
  <span class="hljs-comment">// PhantomJS</span>
  MessageChannel.toString() === <span class="hljs-string">'[object MessageChannelConstructor]'</span>
)) {
  <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> MessageChannel()
  <span class="hljs-keyword">const</span> port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    port.postMessage(<span class="hljs-number">1</span>)
  }
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">/* istanbul ignore next */</span>
  macroTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setTimeout(flushCallbacks, <span class="hljs-number">0</span>)
  }
}

<span class="hljs-comment">// Determine MicroTask defer implementation.</span>
<span class="hljs-comment">/* istanbul ignore next, $flow-disable-line */</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(<span class="hljs-built_in">Promise</span>)) {
  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve()
  microTimerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    p.then(flushCallbacks)
    <span class="hljs-comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span>
    <span class="hljs-comment">// it can get stuck in a weird state where callbacks are pushed into the</span>
    <span class="hljs-comment">// microtask queue but the queue isn't being flushed, until the browser</span>
    <span class="hljs-comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span>
    <span class="hljs-comment">// "force" the microtask queue to be flushed by adding an empty timer.</span>
    <span class="hljs-keyword">if</span> (isIOS) setTimeout(noop)
  }
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// fallback to macro</span>
  microTimerFunc = macroTimerFunc
}</pre></td></tr></tbody></table></div></div><div class="comments"><div id="gitalk-container"></div></div></div></div></div><div class="footer"><div class="center">zWing / Powered by <a target="_blank" href="https://github.com/acyortjs/acyort">AcyOrt</a> / Theme <a target="_blank" href="https://github.com/acyortjs/theme-donob">donob</a></div></div><script src="/script/post.js"></script><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script>const gitalkConfig = JSON.parse('{"owner":"zWingz","repo":"my-blog-config","admin":["zWingz"],"clientID":"0438ed96c0cb944693a7","clientSecret":"23e7aa3152f5d03d8f20029540741d6f886c9f5b","number":8}')
  var gitalk = new Gitalk({
    ...gitalkConfig
  })
  gitalk.render('gitalk-container')</script><script defer="defer" src="/script/ribbon.js"></script></body></html>