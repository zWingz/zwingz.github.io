<!doctype html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="description" content="Just a blog."><link rel="stylesheet" href="/css/style.css"><title>Promise/A+规范以及实现 - zWing</title><link rel="stylesheet" href="/css/highlight.ocean.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"></head><body><canvas id="ribbon"></canvas><div class="main"><div class="header"><a class="logo" href="/">zWing</a><div class="menu"><a href="/archives/">Archives</a><a href="/about/">About</a></div><div class="social"><a target="_blank" href="https://github.com/zWingz/my-blog-config/issues"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"></path></svg></a><a target="_blank" href="/rss.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.18,15.64A2.18,2.18 0 0,1 8.36,17.82C8.36,19 7.38,20 6.18,20C5,20 4,19 4,17.82A2.18,2.18 0 0,1 6.18,15.64M4,4.44A15.56,15.56 0 0,1 19.56,20H16.73A12.73,12.73 0 0,0 4,7.27V4.44M4,10.1A9.9,9.9 0 0,1 13.9,20H11.07A7.07,7.07 0 0,0 4,12.93V10.1Z"></path></svg></a></div></div><div id="post" class="center"><div class="toc"><div class="stay"><ul><li><a href="#promise-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">Promise 实现原理</a><ul><li><a href="#promise%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">Promise基本用法</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">实现过程</a><ul><li><a href="#%E6%A0%B9%E6%8D%AEpromisea%E8%A7%84%E8%8C%83%E4%BB%A5%E4%B8%8B%E7%AE%80%E7%A7%B0%E8%A7%84%E8%8C%83%E4%B8%AD%E6%89%80%E8%AF%B4%E7%9A%84">根据<code>Promise/A+规范</code>(以下简称规范)中所说的</a></li><li><a href="#%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AAthen%E6%96%B9%E6%B3%95%E6%B2%A1%E6%9C%89%E5%AE%8C%E6%88%90-%E5%85%88%E7%9C%8B%E4%B8%8B%E8%A7%84%E8%8C%83%E6%80%8E%E4%B9%88%E8%AF%B4">还有一个<code>then</code>方法没有完成. 先看下规范怎么说</a></li><li><a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%BB%A7%E7%BB%AD%E7%9C%8B%E4%B8%8B%E8%A7%84%E8%8C%83%E6%80%8E%E4%B9%88%E8%AF%B4">接下来继续看下规范怎么说</a></li><li><a href="#%E8%A7%84%E8%8C%83%E5%A4%96%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF">规范外的一些东西</a><ul><li><a href="#catch">catch</a></li><li><a href="#finally-es2018%E5%BC%95%E5%85%A5%E6%A0%87%E5%87%86">finally (ES2018引入标准)</a></li><li><a href="#promiseresolve%E5%92%8Cpromisereject-%E8%BF%99%E9%87%8C%E6%98%AF%E4%BB%8Ees6%E5%85%A5%E9%97%A8%E4%B8%AD%E7%9C%8B%E5%88%B0%E7%9A%84%E5%AE%9A%E4%B9%89">Promise.resolve和Promise.reject (这里是从ES6入门中看到的定义)</a></li></ul></li><li><a href="#%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98">开发过程中遇到其他问题</a><ul><li><a href="#node%E4%B8%AD%E7%9A%84unhandledrejection%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84uncaught-in-promise-%E6%8F%90%E7%A4%BA">node中的<code>unhandledRejection</code>和浏览器中的<code>Uncaught (in promise)</code> 提示</a></li></ul></li></ul></li><li><a href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">存在的问题</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul></li></ul><span class="toc-icon"></span></div></div><div class="post-content"><p class="time">April 20, 2018</p><h1 class="title">Promise/A+规范以及实现</h1><div class="content"><h1 id="promise-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" class="heading"><a href="#promise-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" class="heading-anchor"></a>Promise 实现原理</h1><p><a href="https://github.com/zWingz/Promise">源码</a></p><h2 id="promise%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" class="heading"><a href="#promise%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" class="heading-anchor"></a>Promise基本用法</h2><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
</pre></td><td class="code"><pre>new Promise(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(resolve, reject)</span> {</span>
    resolve()
}).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val)</span> {</span>
    <span class="hljs-keyword">return</span> val
}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> {</span>
    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">error</span>)
}).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> {</span>
    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">error</span>)
})</pre></td></tr></tbody></table></div><p>Promise对象基本方法是<code>then</code>, 而<code>catch</code>是<code>then</code>的一个变形, 相当于<code>then(undefined, onReject)</code></p><h2 id="%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B" class="heading"><a href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B" class="heading-anchor"></a>实现过程</h2><p>根据Promise用法, 我们初步想到需要实现的方法是</p><ul><li>构造函数</li><li>resolve函数</li><li>reject函数</li><li>then函数</li></ul><p>此时Promise原型应为</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
</pre></td><td class="code"><pre><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">'PENDING'</span>
<span class="hljs-keyword">const</span> RESOLVED = <span class="hljs-string">'RESOLVED'</span>
<span class="hljs-keyword">const</span> REJECT = <span class="hljs-string">'REJECT'</span>

<span class="hljs-keyword">class</span> <span class="hljs-built_in">Promise</span> {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">func</span>) {}
    resolve(){}
    reject(){}
    then(onReslove, onReject){}
}</pre></td></tr></tbody></table></div><h3 id="%E6%A0%B9%E6%8D%AEpromisea%E8%A7%84%E8%8C%83%E4%BB%A5%E4%B8%8B%E7%AE%80%E7%A7%B0%E8%A7%84%E8%8C%83%E4%B8%AD%E6%89%80%E8%AF%B4%E7%9A%84" class="heading"><a href="#%E6%A0%B9%E6%8D%AEpromisea%E8%A7%84%E8%8C%83%E4%BB%A5%E4%B8%8B%E7%AE%80%E7%A7%B0%E8%A7%84%E8%8C%83%E4%B8%AD%E6%89%80%E8%AF%B4%E7%9A%84" class="heading-anchor"></a>根据<code>Promise/A+规范</code>(以下简称规范)中所说的</h3><ul><li>Promise有三个状态 <code>PENDING</code>, <code>RESOLVED</code>, <code>REJECTED</code></li><li>状态只会从<code>PENDING</code>转换到<code>RESOLVED</code>或者<code>REJECTED</code>其中一个, 并且之后不会再改变</li><li>当Promise处于执行态时, 会有一个终值, 并且该值不会再改变</li><li>当Promise处于拒绝态时, 会有一个据因, 并且该据因不会再改变</li><li>当Promise由PENDING转换为RESOLVED时, 会触发<code>onResolve</code>回调, 并且只执行一次</li><li>当Promise由PENDING转换为REJECTED时, 会触发<code>onReject</code>回调, 并且只执行一次</li><li>Promise状态的转换时机在于开发者何时调用promise的resolve或者reject函数</li></ul><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
</pre></td><td class="code"><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>{
    <span class="hljs-keyword">constructor</span>(func) {
        <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span> <span class="hljs-comment">// 终值或者据因</span>
        <span class="hljs-keyword">this</span>.status = PENDING <span class="hljs-comment">// 状态</span>
        <span class="hljs-keyword">this</span>.onResolveCallBack = [] <span class="hljs-comment">// resolved 回调</span>
        <span class="hljs-keyword">this</span>.onRejectCallBack = [] <span class="hljs-comment">// rejected 回调</span>
        <span class="hljs-keyword">try</span> {
            func(<span class="hljs-keyword">this</span>.resolve.bind(<span class="hljs-keyword">this</span>), <span class="hljs-keyword">this</span>.reject.bind(<span class="hljs-keyword">this</span>))
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-keyword">this</span>.reject(e)
        }
    }
    resolve(<span class="hljs-keyword">val</span>){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === PENDING) {
            <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">val</span> <span class="hljs-comment">// 设置终值</span>
            <span class="hljs-keyword">this</span>.status = RESOLVED <span class="hljs-comment">// 设置状态</span>
            <span class="hljs-keyword">this</span>.onResolveCallBack.forEach(each =&gt; {
                each(<span class="hljs-keyword">val</span>) <span class="hljs-comment">// 执行回调</span>
            })
        }
    }
    reject(reason){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === PENDING) {
            <span class="hljs-keyword">this</span>.value = reason <span class="hljs-comment">// 设置据因</span>
            <span class="hljs-keyword">this</span>.status = REJECT <span class="hljs-comment">// 设置状态</span>
            <span class="hljs-keyword">this</span>.onRejectCallBack.forEach(each =&gt; {
                each(reason) <span class="hljs-comment">// 执行回调</span>
            })
        }
    }
    then(onReslove, onReject){}
}</pre></td></tr></tbody></table></div><p>这里可能有人会说Promise应该是一个异步的过程, 在上面代码中并没有看到任何的异步. 比如说: setTimeout。</p><p>解答：</p><p>其实当创建一个Promise实例的时候，整个过程是同步的。</p><p>也就是说</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
</pre></td><td class="code"><pre><span class="hljs-keyword">const</span> ins = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
    res(<span class="hljs-number">10</span>)
})
<span class="hljs-built_in">console</span>.log(ins)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after ins'</span>)

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// Promise {&lt;resolved&gt;: 10}</span>
<span class="hljs-comment">// after ins</span>
</pre></td></tr></tbody></table></div><p>当你执行完这一句， ins的状态会马上变成<code>RESOLVED</code>. 说明在构造方法中并没有执行异步操作。如果真的需要异步的话，则需要主动在调用<code>res</code>前，加上<code>setTimeout</code>来触发异步。</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
</pre></td><td class="code"><pre><span class="hljs-keyword">const</span> ins = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        res(<span class="hljs-number">10</span>)
    })
})
<span class="hljs-built_in">console</span>.log(ins)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after ins'</span>)

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// Promise {&lt;pending&gt;}</span>
<span class="hljs-comment">// after ins</span></pre></td></tr></tbody></table></div><h3 id="%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AAthen%E6%96%B9%E6%B3%95%E6%B2%A1%E6%9C%89%E5%AE%8C%E6%88%90-%E5%85%88%E7%9C%8B%E4%B8%8B%E8%A7%84%E8%8C%83%E6%80%8E%E4%B9%88%E8%AF%B4" class="heading"><a href="#%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AAthen%E6%96%B9%E6%B3%95%E6%B2%A1%E6%9C%89%E5%AE%8C%E6%88%90-%E5%85%88%E7%9C%8B%E4%B8%8B%E8%A7%84%E8%8C%83%E6%80%8E%E4%B9%88%E8%AF%B4" class="heading-anchor"></a>还有一个<code>then</code>方法没有完成. 先看下规范怎么说</h3><ul><li>一个promise必须提供一个<code>then</code>方法以访问当前值, 终止和据因</li><li>then接受两个参数<code>then(onResolve, onReject)</code></li><li>onResolve和onReject都是可选, 如果不是函数则被忽略</li><li>onResolve方法在promise执行结束后被调用, 其第一个参数为promise的终值, 被调用次数不超过一次</li><li>onReject方法在promise被拒绝后被调用, 其第一个参数为promise的据因, 同样被调用次数不超过一次</li><li>onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用</li><li>如果onResolve和onReject返回一个值x, 则执行 <strong>Promise解决过程</strong></li><li>then方法必须返回一个<code>promise</code>对象</li></ul><p>简单说就是</p><ul><li>如果promise处于pending, 则将then回调放入promise的回调列表中</li><li>如果promise处于resolved, 则实行then方法中的onResolve</li><li>如果promise处于rejected, 则执行then方法中的onReject</li><li>then方法要确保onResolve和onReject异步执行</li><li>onResolve和onReject返回的值都将用来解决下一个promise(后面再讲解)</li><li>返回新的promise(注意: 一定是新的promise)</li></ul><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
</pre></td><td class="code"><pre><span class="hljs-keyword">class</span> <span class="hljs-constructor">Promise()</span> {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">then</span>(onResolve, onReject){
        const self = this
        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">nextResolve</span>, <span class="hljs-params">nextReject</span>)</span> {
            <span class="hljs-keyword">if</span>(self.status<span class="hljs-operator"> === </span>PENDING) {
                <span class="hljs-comment">// 加入到任务队列</span>
                self.onResolveCallback.push(onResolve)
                self.onRejectCallback.push(onReject)
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(self.status<span class="hljs-operator"> === </span>RESOLVED) {
                <span class="hljs-comment">// 异步执行</span>
                set<span class="hljs-constructor">Timeout(<span class="hljs-params">onResolve</span>, 0, <span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 异步执行</span>
                set<span class="hljs-constructor">Timeout(<span class="hljs-params">onReject</span>, 0, <span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>
            }
        })
    }
}</pre></td></tr></tbody></table></div><p>此时Promise已经可以完成异步操作. 但是Promise还有一个关键特点是可以链式调用. 目前是还没有实现链式调用这一步. 具体代码看<a href="https://github.com/zWingz/Promise/blob/master/promise2.js">promise2.js</a></p><h3 id="%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%BB%A7%E7%BB%AD%E7%9C%8B%E4%B8%8B%E8%A7%84%E8%8C%83%E6%80%8E%E4%B9%88%E8%AF%B4" class="heading"><a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%BB%A7%E7%BB%AD%E7%9C%8B%E4%B8%8B%E8%A7%84%E8%8C%83%E6%80%8E%E4%B9%88%E8%AF%B4" class="heading-anchor"></a>接下来继续看下规范怎么说</h3><p>Promise 解决过程</p><ul><li>blablabla 这里比较长</li></ul><p><strong>简单说就是</strong></p><p><code>x</code>为<code>then</code>方法中<code>onResolve</code>或者<code>onReject</code>中返回的值, <code>promise2</code>为<code>then</code>方法返回的新<code>promise</code>.</p><p><code>promise</code>的解决过程是一个抽象步骤. 需要输入一个<code>promise</code>和一个<strong>值</strong>. 表示为<code>[[Resolve]](promise, x)</code></p><ul><li>如果<code>x</code>和<code>promise2</code>相等, 则以<code>TypeError</code>为据因拒绝执行promise2</li><li>如果<code>x</code>为<code>Promise</code>实例, 则让<code>promise2</code>接受x的状态</li><li>如果<code>x</code>为<code>thenable</code>对象, 则调用其<code>then</code>方法</li><li>如果都不满足, 则用<code>x</code>为参数执行<code>promise2</code></li></ul><p>继续修改then方法, 以及添加<code>resolvePromise</code>来执行<code>Promise</code>解决过程</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
<span>75</span>
<span>76</span>
<span>77</span>
<span>78</span>
<span>79</span>
<span>80</span>
<span>81</span>
<span>82</span>
<span>83</span>
<span>84</span>
<span>85</span>
<span>86</span>
<span>87</span>
<span>88</span>
<span>89</span>
<span>90</span>
<span>91</span>
<span>92</span>
<span>93</span>
<span>94</span>
<span>95</span>
<span>96</span>
<span>97</span>
<span>98</span>
<span>99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
<span>115</span>
<span>116</span>
<span>117</span>
<span>118</span>
<span>119</span>
<span>120</span>
</pre></td><td class="code"><pre><span class="hljs-keyword">function</span> <span class="hljs-constructor">_isFunction(<span class="hljs-params">val</span>)</span> {
  return typeof <span class="hljs-keyword">val</span><span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>'
}
<span class="hljs-keyword">function</span> <span class="hljs-constructor">_isThenable(<span class="hljs-params">x</span>)</span> {
  return <span class="hljs-constructor">_isFunction(<span class="hljs-params">x</span>)</span><span class="hljs-operator"> || </span>(typeof x<span class="hljs-operator"> === </span>'object'<span class="hljs-operator"> &amp;&amp; </span>x !== null)
}

<span class="hljs-comment">/**
 * Promise 解决过程
 * 如果是thenable对象, 则触发该对象的then方法
 * 如果是一个值, 则直接调用resolve解析这个值
 * @param {Promise}} promise
 * @param {Object} x
 * @param {Function} resolve
 * @param {Function} reject
 */</span>
<span class="hljs-keyword">function</span> resolve<span class="hljs-constructor">Promise(<span class="hljs-params">promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> {
  <span class="hljs-comment">// 要求每次返回新的promise</span>
  <span class="hljs-comment">// 如果返回是当前的promise, 则抛出typeError</span>
  <span class="hljs-keyword">if</span> (x<span class="hljs-operator"> === </span>promise) {
    reject(<span class="hljs-keyword">new</span> <span class="hljs-constructor">TypeError('Chaining <span class="hljs-params">cycle</span> <span class="hljs-params">detected</span> <span class="hljs-params">for</span> <span class="hljs-params">promise</span>')</span>)
  }
  <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>
  <span class="hljs-comment">// 判断是否thenable对象</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-constructor">_isThenable(<span class="hljs-params">x</span>)</span>) {
    <span class="hljs-keyword">try</span> {
      const { <span class="hljs-keyword">then</span> } = x
      <span class="hljs-keyword">if</span> (<span class="hljs-constructor">_isFunction(<span class="hljs-params">then</span>)</span>) {
        <span class="hljs-keyword">then</span>.call(
          x,
         <span class="hljs-function"> <span class="hljs-params">val</span> =&gt;</span> {
            <span class="hljs-keyword">if</span> (!called) {
              called = <span class="hljs-literal">true</span>
              <span class="hljs-comment">// 如果不断的返回thenable</span>
              <span class="hljs-comment">// 则需要不断地递归</span>
              <span class="hljs-comment">// 但是实际上不应该不断的返回thenable</span>
              resolve<span class="hljs-constructor">Promise(<span class="hljs-params">promise</span>, <span class="hljs-params">val</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>
            }
          },
         <span class="hljs-function"> <span class="hljs-params">reason</span> =&gt;</span> {
            <span class="hljs-keyword">if</span> (!called) {
              called = <span class="hljs-literal">true</span>
              reject(reason)
            }
          }
        )
      } <span class="hljs-keyword">else</span> {
        resolve(x)
      }
    } catch (e) {
      <span class="hljs-keyword">if</span> (called) {
        return
      }
      called = <span class="hljs-literal">true</span>
      reject(e)
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//  非thenable, 则以该值来执行resolve</span>
    resolve(x)
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-constructor">Promise()</span> {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">/**
   * then方法
   * @param {Function} [onFulfilled] 前then的resolve函数, 当promise为RESOLVE时,处理当前结果
   * @param {Function} onRejected 当前then的reject函数, 当promise被REJECT时调用
   * @returns {Promise}
   * @memberof Promise
   */</span>
  <span class="hljs-keyword">then</span>(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled<span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>' ? onFulfilled :<span class="hljs-function"> <span class="hljs-params">val</span> =&gt;</span> <span class="hljs-keyword">val</span>
    onRejected =
      typeof onRejected<span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>'
        ? onRejected
        :<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> {
            throw err
          }
    const self = this
    <span class="hljs-comment">// 如果有then方法调用, 则将hasThenHandle设为true</span>
    <span class="hljs-comment">// console.log(this);</span>
    this.hasThenHandle = <span class="hljs-literal">true</span>
    <span class="hljs-comment">/**
     * 返回一个新的promise, 用于链式调用
     */</span>
    const ret = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> {
      <span class="hljs-comment">// 用try..catch包裹执行方法</span>
      const tryCatchWrapper = <span class="hljs-keyword">function</span>(fnc) {
        return <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> {
          <span class="hljs-keyword">try</span> {
            fnc<span class="hljs-literal">()</span>
          } catch (e) {
            reject(e)
          }
        }
      }
      <span class="hljs-comment">// 封装resolve方法回调</span>
      const doResolve = <span class="hljs-keyword">try</span><span class="hljs-constructor">CatchWrapper(<span class="hljs-params">function</span>()</span> {
        resolve<span class="hljs-constructor">Promise(<span class="hljs-params">ret</span>, <span class="hljs-params">onFulfilled</span>(<span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>, resolve, reject)
      })
      <span class="hljs-comment">// 封装reject方法回调</span>
      <span class="hljs-comment">// 如果当前then没有相应的reject回调</span>
      const doReject = <span class="hljs-keyword">try</span><span class="hljs-constructor">CatchWrapper(<span class="hljs-params">function</span>()</span> {
        resolve<span class="hljs-constructor">Promise(<span class="hljs-params">ret</span>, <span class="hljs-params">onRejected</span>(<span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>, resolve, reject)
      })
      <span class="hljs-keyword">if</span> (self.status<span class="hljs-operator"> === </span>PENDING) {
        <span class="hljs-comment">// 如果当前promise还未执行完毕, 则设置回调</span>
        self.onResolveCallback.push(doResolve)
        self.onRejectCallback.push(doReject)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status<span class="hljs-operator"> === </span>RESOLVED) {
        <span class="hljs-comment">// 如果为RESOLVE, 则异步执行resolve</span>
        set<span class="hljs-constructor">Timeout(<span class="hljs-params">doResolve</span>, 0)</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 如果为REJECT, 则异步执行reject</span>
        set<span class="hljs-constructor">Timeout(<span class="hljs-params">doReject</span>, 0)</span>
      }
    })
    return ret
  }
}</pre></td></tr></tbody></table></div><p>至此一个<code>Promise</code>可以说基本完成了.(完整代码请看<a href="https://github.com/zWingz/Promise/blob/master/index.js">index.js</a>)</p><h3 id="%E8%A7%84%E8%8C%83%E5%A4%96%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF" class="heading"><a href="#%E8%A7%84%E8%8C%83%E5%A4%96%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF" class="heading-anchor"></a>规范外的一些东西</h3><p>其实规范中定义的是<code>Promise</code>的构建和执行过程.</p><p>而我们日常用到的却不至于规范中所提到的.</p><p>比如</p><ul><li>catch</li><li>finally</li><li>Promise.resolve</li><li>Promise.reject</li><li>all (未实现)</li><li>race (未实现)</li></ul><p>那接下来就说下关于这部分的实现</p><h4 id="catch" class="heading"><a href="#catch" class="heading-anchor"></a>catch</h4><p>上面有提到. catch其实是<code>then(undefined, reject)</code> 的简写. 所以这里比较简单</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
</pre></td><td class="code"><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span></span>() {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">catch</span>(reject) {
        <span class="hljs-comment">// 相当于新加入一个then方法</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(undefined, reject)
    }
}</pre></td></tr></tbody></table></div><h4 id="finally-es2018%E5%BC%95%E5%85%A5%E6%A0%87%E5%87%86" class="heading"><a href="#finally-es2018%E5%BC%95%E5%85%A5%E6%A0%87%E5%87%86" class="heading-anchor"></a>finally (ES2018引入标准)</h4><p>finally函数作用我想大家都应该知道, 就是无论当前promise状态是如何. 都一定会执行回调.</p><p>finally方法中, 不接收任何参数, 所以并不能知道前面的Promise的状态.</p><p>同时, 他不会对promise产生影响.总是返回原来的值 所以在<code>finally</code>中的操作,应该是与状态无关, 不依赖于promise的执行结果</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
</pre></td><td class="code"><pre><span class="hljs-keyword">class</span> <span class="hljs-built_in">Promise</span>() {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">finally</span>(fnc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> {
            fnc()
            <span class="hljs-keyword">return</span> val
        }, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
            fnc()
            <span class="hljs-keyword">throw</span> err
        })
    }
}</pre></td></tr></tbody></table></div><h4 id="promiseresolve%E5%92%8Cpromisereject-%E8%BF%99%E9%87%8C%E6%98%AF%E4%BB%8Ees6%E5%85%A5%E9%97%A8%E4%B8%AD%E7%9C%8B%E5%88%B0%E7%9A%84%E5%AE%9A%E4%B9%89" class="heading"><a href="#promiseresolve%E5%92%8Cpromisereject-%E8%BF%99%E9%87%8C%E6%98%AF%E4%BB%8Ees6%E5%85%A5%E9%97%A8%E4%B8%AD%E7%9C%8B%E5%88%B0%E7%9A%84%E5%AE%9A%E4%B9%89" class="heading-anchor"></a>Promise.resolve和Promise.reject (这里是从ES6入门中看到的定义)</h4><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
</pre></td><td class="code"><pre><span class="hljs-comment">// 调用形式</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve(arg)
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(arg)</pre></td></tr></tbody></table></div><ul><li><p>Promise.resolve</p><p>根据arg的不同, 会执行不同的操作</p><div class="hljs"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
</pre></td><td class="code"><pre> - arg为Promise实例, 则原封不动的返回这个实例
 - arg为thenable对象, 则会将arg转成promise, 并且立即执行&#x60;arg.then&#x60;方法(并不代表同步, 而是本轮事件循环结束时执行)
 - arg不满足上述情况, 则返回一个新的Promise实例, 状态为resolved, 终值为arg</pre></td></tr></tbody></table></div><p>因此<code>Promise.resolve</code>是一个更方便的创建<code>Promise</code>实例的方法.</p></li><li><p>Promise.reject</p><p>这里就不会区分arg, 而是原封不动的把arg作为据因, 执行后续方法的调用.</p></li></ul><p>实现代码</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
</pre></td><td class="code"><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span>() </span>{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">/**
     * Promise.resolve
     * 将参数转成Promise对象
     * @static
     * @param {any} val
     * @returns {MPromise}
     * @memberof MPromise
     */</span>
    <span class="hljs-keyword">static</span> resolve(x) {
        <span class="hljs-comment">// 如果为MPromise实例</span>
        <span class="hljs-comment">// 则返回该实例</span>
        <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {
            <span class="hljs-keyword">return</span> val
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_isThenable(x)) {
            <span class="hljs-comment">// 如果为具有then方法的对象</span>
            <span class="hljs-comment">// 则转为MPromise对象, 并且执行thenable</span>
            <span class="hljs-comment">/**
             * @example
             * MPromise.resolve({
             *      then(res) {
             *          console.log('do promise')
             *          res(10)
             *      }
             *  })
             */</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
                <span class="hljs-comment">// 执行异步</span>
                setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    val.then(res, rej)
                }, <span class="hljs-number">0</span>)
            })
        }
        <span class="hljs-comment">// 如果val为一个原始值,或者不具有then方法的对象</span>
        <span class="hljs-comment">// 则返回一个新的MPromise对象,状态为resolved</span>
        <span class="hljs-comment">/**
         * @example
         * MPromise.resolve()
         */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>{res(x)})
    }
    <span class="hljs-comment">/**
     * reject方法参数会原封不动的作为据因而变成后续方法的参数
     * 且初始状态为REJECT
     * 不存在判别thenable
     * @static
     * @param {any} reason 
     * @returns 
     * @memberof MPromise
     */</span>
    <span class="hljs-keyword">static</span> reject(reason) {
        <span class="hljs-comment">/**
         * @example
         * MPromise.reject('some error')
         */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{rej(reason)})
    }
}</pre></td></tr></tbody></table></div><h3 id="%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" class="heading"><a href="#%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" class="heading-anchor"></a>开发过程中遇到其他问题</h3><h4 id="node%E4%B8%AD%E7%9A%84unhandledrejection%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84uncaught-in-promise-%E6%8F%90%E7%A4%BA" class="heading"><a href="#node%E4%B8%AD%E7%9A%84unhandledrejection%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84uncaught-in-promise-%E6%8F%90%E7%A4%BA" class="heading-anchor"></a>node中的<code>unhandledRejection</code>和浏览器中的<code>Uncaught (in promise)</code> 提示</h4><p>在Promise中产生的所有错误都会被Promise吞掉. 当没有相应的错误处理函数时候, node和浏览器分别有不同的表现.</p><p>但是这并不是一个新的错误, 因为不能用<code>try{} catch(){}</code> 捕获.</p><p>所以在浏览器端, 是一个<code>console.error</code>的错误提示, 在<code>node</code>中, 这个算是一个事件. 具体可以通过<code>process.on</code>来监听</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
</pre></td><td class="code"><pre>process.on(<span class="hljs-string">'unhandledRejection'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, p)</span> </span>{
  <span class="hljs-keyword">throw</span> err;
});</pre></td></tr></tbody></table></div><p>在编写代码中, 一开始卡在这一步挺久.</p><p>由于无法知道promise实例后续是否有相应的错误处理函数.</p><p>简单的判断<code>onReject === undefined</code> 是不行的.</p><p>形如:</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
</pre></td><td class="code"><pre><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(<span class="hljs-number">10</span>)
<span class="hljs-comment">// 或者</span>
<span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">res</span>, <span class="hljs-params">rej</span>)</span> {
    rej(<span class="hljs-number">10</span>)
})</pre></td></tr></tbody></table></div><p>这类是同步执行的, <code>onReject === undefined</code> 恒为<code>true</code>.</p><p>我的做法是给promise实例添加一个<code>hasThenHandle</code>的属性, 在<code>then</code>方法中将其设为<code>true</code></p><p>在<code>reject</code>方法中使用<code>setTimeout</code>异步判断该值是否为<code>true</code>, 如果不是则通过<code>console.error</code>抛出提示.</p><p>其实在原生Promise中, 抛出的<code>unhandledRejection</code> 也是属于异步的.</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
</pre></td><td class="code"><pre><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">10</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after Promise.reject'</span>)
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>{
    rej(<span class="hljs-number">10</span>)
})
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after new Promise'</span>)

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// after Promise.reject</span>
<span class="hljs-comment">// after new Promise</span>
<span class="hljs-comment">// Uncaught (in promise) 10</span>
<span class="hljs-comment">// Uncaught (in promise) 10</span></pre></td></tr></tbody></table></div><p>于是这个问题也能得到很好地解决.</p><p>至此完整代码已经结束, 具体看<code>index.js</code>.</p><h2 id="%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" class="heading"><a href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" class="heading-anchor"></a>存在的问题</h2><ul><li>由于用的是setTimeout模拟, 所以优先级不能保证高于setTimeout<ul><li>浏览器中可以用MessageChannel(macrotask)</li><li>node中可以用setImmediate(优先级在某些情况下比setTimeout高一些)</li><li>setTimeout和setImmediate在无IO操作下,两者执行顺序不确定,但是在IO操作下,setImmediate比setTimeout优先级高. 且setImmediate只在IE下有效</li></ul></li></ul><h2 id="%E5%8F%82%E8%80%83" class="heading"><a href="#%E5%8F%82%E8%80%83" class="heading-anchor"></a>参考</h2><p><a href="http://www.ituring.com.cn/article/66566">【翻译】Promises/A+规范</a></p><p><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-prototype-finally">ECMAScript 6入门</a></p></div><div class="comments"><div id="gitalk-container"></div></div></div></div></div><div class="footer"><div class="center">zWing / Powered by <a target="_blank" href="https://github.com/acyortjs/acyort">AcyOrt</a> / Theme <a target="_blank" href="https://github.com/acyortjs/theme-donob">donob</a></div></div><script src="/script/post.js"></script><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script>const gitalkConfig = JSON.parse('{"owner":"zWingz","repo":"my-blog-config","admin":["zWingz"],"clientID":"0438ed96c0cb944693a7","clientSecret":"23e7aa3152f5d03d8f20029540741d6f886c9f5b","number":16}')
  var gitalk = new Gitalk({
    ...gitalkConfig
  })
  gitalk.render('gitalk-container')</script><script defer="defer" src="/script/ribbon.js"></script></body></html>