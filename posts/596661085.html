<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="description" content="利用泛型+类型推导定义伪GraphQL模型"><meta name="keywords" content=""><link rel="stylesheet" href="/css/prism.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><title>利用泛型+类型推导定义伪GraphQL模型 - zWing</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6650629ba7ddbfe98e2f63700c2e6923";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><div class="indicator"></div><canvas id="ribbon"></canvas><main class="main"><header class="header"><a class="logo" href="/">zWing</a><nav class="menu"><a href="/archives/">Archives</a><a href="/tags/">Tags</a><a href="/about/">About</a><a href="/repo/">Repo</a></nav><div class="social"><a target="_blank" href="/rss.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.18,15.64A2.18,2.18 0 0,1 8.36,17.82C8.36,19 7.38,20 6.18,20C5,20 4,19 4,17.82A2.18,2.18 0 0,1 6.18,15.64M4,4.44A15.56,15.56 0 0,1 19.56,20H16.73A12.73,12.73 0 0,0 4,7.27V4.44M4,10.1A9.9,9.9 0 0,1 13.9,20H11.07A7.07,7.07 0 0,0 4,12.93V10.1Z"></path></svg> </a><a target="_blank" href="https://github.com/zWingz/my-blog-config/issues"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"></path></svg></a></div></header><div class="content-container center"><div id="post" class="flex"><aside class="toc"><div class="stay"><ul><li><a href="#%E4%BE%8B%E5%AD%90">例子</a></li><li><a href="#squiggly">Squiggly</a></li><li><a href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E7%9A%84%E6%96%B9%E5%BC%8F">最简单粗暴的方式</a></li><li><a href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%94%B9%E8%BF%9B">进一步改进</a></li><li><a href="#%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0">最终实现</a><ul><li><a href="#%E5%AE%9A%E4%B9%89fields%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B">定义fields以及类型</a></li><li><a href="#%E5%AE%9E%E7%8E%B0render%E6%96%B9%E6%B3%95">实现render方法</a></li><li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li><li><a href="#%E6%9B%B4%E5%A4%9A%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81">更多类型支持</a></li><li><a href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8">组合使用</a></li><li><a href="#%E9%85%8D%E5%90%88axios%E4%BD%BF%E7%94%A8">配合axios使用</a><ul><li><a href="#%E6%9C%80%E7%B2%97%E6%9A%B4%E7%9A%84%E6%96%B9%E5%BC%8F">最粗暴的方式</a></li><li><a href="#%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E6%96%B9%E5%BC%8F">更方便的方式</a></li></ul></li></ul></li><li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li></ul><span class="toc-icon"></span></div></aside><article class="post-content"><time class="time">April 08, 2020</time><h1 class="title">利用泛型+类型推导定义伪GraphQL模型</h1><div class="content"><p>接触过前端的应该都有听过<a href="https://graphql.org/">GraphQL</a></p><p>简单来说就是前端自行定义接口所需要返回的数据, 想要尝试的可以试着调用<a href="https://developer.github.com/v4/">GithubAPI V4</a>.</p><p>而对于我们常用的<code class="language-text">xhr</code>请求能否也做到跟<code class="language-text">GraphQL</code>一样能自定义接口返回的数据?</p><p>答案是可以, 但是提前必须是后端必须提供足够的数据让前端自行选择.</p><h2 id="例子" class="heading"><a href="#%E4%BE%8B%E5%AD%90" aria-hidden="true"><span class="icon icon-link"></span></a>例子</h2><p>假设目前后端定义了一个<code class="language-text">User</code>模型, 包含了十几项数据</p><div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Example</span>
<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    id<span class="token punctuation">,</span>
    username<span class="token punctuation">,</span>
    created<span class="token punctuation">,</span>
    updated<span class="token punctuation">,</span>
    <span class="token comment">// .. 省略好几个人</span>
<span class="token punctuation">}</span></code></pre></div><p>任何接口如果有涉及到拿<code class="language-text">User</code>数据的, 都会把该<code class="language-text">User</code>的数据全量返回, 也就是说前端能从接口中拿到<code class="language-text">User</code>相关的十多项数据.</p><p>但实际上并不是每个接口都需要这么多数据, 可能部分接口我们只需要用到<code class="language-text">username</code>和<code class="language-text">id</code>. 但对于后端来说, 他们只管写通过逻辑, 而不去管<code class="language-text">UI</code>上需要哪些数据.</p><p>这样一来, 每个接口都有可能返回大量无用的数据, 如果数据嵌套过深, 极端情况可能有上兆的数据.</p><p>因此前端需要做到像<code class="language-text">GraphQL</code>一样能够自行定义所需的数据. (前提还是需要后端支持)</p><h2 id="squiggly" class="heading"><a href="#squiggly" aria-hidden="true"><span class="icon icon-link"></span></a>Squiggly</h2><p>如果后端是用<code class="language-text">JAVA</code>开发, 那么可以使用<a href="https://github.com/bohnman/squiggly">squiggly</a>来支持前端数据自定义</p><p>根据这个库的介绍, 可以通过自定义<code class="language-text">filter</code>形式来过滤掉<code class="language-text">JAVA</code>类中数据的输出</p><p>用<code class="language-text">javascript</code>以及上面的<code class="language-text">User</code>作为例子的话, 假设我们的<code class="language-text">filter</code>是<code class="language-text">username,id</code>, 那么当我们<code class="language-text">log(User)</code>时候只会输出<code class="language-text">username</code>和<code class="language-text">id</code>两个数据, 其他都被过滤掉</p><p>当然还支持其他过滤方式, 但下面都是以<strong>精确匹配</strong>方式来完成数据定义</p><h2 id="最简单粗暴的方式" class="heading"><a href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E7%9A%84%E6%96%B9%E5%BC%8F" aria-hidden="true"><span class="icon icon-link"></span></a>最简单粗暴的方式</h2><p>直接在请求中带上自定义请求头, 值设为所需要返回的字段</p><div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> fileds <span class="token operator">=</span> <span class="token string">'name,user.username,user.id'</span>
axios<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'/example'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    fields
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这样后端返回的字段只有</p><div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
  <span class="token property">"user"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"username"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">""</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种方法存在弊端</p><ul><li>定义<code class="language-text">fileds</code>会很麻烦</li><li><code class="language-text">fields</code>不利于复用</li><li><code class="language-text">fields</code>中定义的字段无法反应到<code class="language-text">response</code>中</li></ul><h2 id="进一步改进" class="heading"><a href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%94%B9%E8%BF%9B" aria-hidden="true"><span class="icon icon-link"></span></a>进一步改进</h2><p>基于上面的问题, 我所期待的效果应该如下:</p><ul><li>更容易以及明确的定义<code class="language-text">fileds</code></li><li><code class="language-text">fields</code>易于继承和扩展</li><li>定义<code class="language-text">fileds</code>同时能定义其类型, 并且反应到<code class="language-text">response</code>上</li></ul><p>解决上面上个问题可以从两个方法入手</p><ul><li>通过类的方法定义<code class="language-text">fileds</code></li><li>借助<code class="language-text">typescript</code>完成类型定义</li></ul><p>似乎只用<code class="language-text">typescript</code> + <code class="language-text">interface</code>就能很好的解决上述功能</p><p><strong>定义类型</strong></p><div class="gatsby-highlight" data-language="typescript"><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">ResData</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span>
  user<span class="token operator">:</span> <span class="token punctuation">{</span>
    username<span class="token operator">:</span> <span class="token builtin">string</span>
    id<span class="token operator">:</span> <span class="token builtin">number</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>借助<code class="language-text">ts</code>可以很容易定义一个类型, 只要把它赋值给<code class="language-text">axios</code>就能很容易定义<code class="language-text">response</code></p><p>接下来只需要想办法把<code class="language-text">interface</code>转成字符串</p><p>但其实类型和字符串是两个层面的东西, 类型属于<code class="language-text">ts</code>, 而字符串是实实在在的<code class="language-text">js</code>变量, 将两个层面连接一起的通道其实就是<code class="language-text">AST</code>, 我们可以通过解析<code class="language-text">ts</code>语法, 通过<code class="language-text">transform</code>转成<code class="language-text">js</code>代码</p><p>于是乎发现了一个<a href="https://github.com/cevek/ttypescript">ttypescript</a>, 可以自行实现<code class="language-text">transformer</code>来完成编译, 同时发现了一个很合适的<a href="https://github.com/nullcc/ts-interface-keys-transformer#readme">transformer</a></p><p>而这篇<a href="https://nullcc.github.io/2019/07/18/TypeScript%E4%B8%AD%E5%88%A9%E7%94%A8transformer%E8%8E%B7%E5%8F%96interface%20keys/">文章</a>整体思路跟我都是很相似, 这里就不在展开</p><p>但是说下这个方法的一些弊端</p><ul><li>不支持嵌套类型</li><li>不支持数组类型</li><li>对继承不友好</li></ul><h2 id="最终实现" class="heading"><a href="#%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0" aria-hidden="true"><span class="icon icon-link"></span></a>最终实现</h2><h3 id="定义fields以及类型" class="heading"><a href="#%E5%AE%9A%E4%B9%89fields%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B" aria-hidden="true"><span class="icon icon-link"></span></a>定义fields以及类型</h3><p>最终要达到的目的其实就是: <strong>定义字段同时定义返回类型</strong>, 而上面的方法是从<code class="language-text">ts</code>层面出发, 我们可以试着从<code class="language-text">js</code>层面出发, 利用<code class="language-text">ts</code>的类型推到功能完成</p><p>举个例子</p><div class="gatsby-highlight" data-language="typescript"><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
  user<span class="token operator">:</span> <span class="token punctuation">{</span>
    username<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
    id<span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> a
</code></pre></div><p>借助<code class="language-text">ts</code>的类型推到可以很容易得出</p><div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span>
  user<span class="token operator">:</span> <span class="token punctuation">{</span>
    username<span class="token operator">:</span> <span class="token builtin">string</span>
    id<span class="token operator">:</span> <span class="token builtin">number</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>有了这个例子, 我们就可以很容易完成我们的目标</p><div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> NumberType <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// type: number</span>
<span class="token keyword">const</span> StringType <span class="token operator">=</span> <span class="token string">''</span> <span class="token comment">// type: string</span>
<span class="token keyword">const</span> BooleanType <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// type: boolean</span>
<span class="token keyword">const</span> AnyType <span class="token operator">=</span> <span class="token string">''</span> <span class="token keyword">as</span> <span class="token builtin">any</span> <span class="token comment">// type: any</span>

<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> StringType<span class="token punctuation">,</span>
  user<span class="token operator">:</span> <span class="token punctuation">{</span>
    username<span class="token operator">:</span> StringType<span class="token punctuation">,</span>
    id<span class="token operator">:</span> NumberType
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">{</span>
  key1<span class="token operator">:</span> BooleanType<span class="token punctuation">,</span>
  key2<span class="token operator">:</span> <span class="token punctuation">{</span>
    key3<span class="token operator">:</span> <span class="token punctuation">{</span>
      key4<span class="token operator">:</span> <span class="token punctuation">{</span>
        key5<span class="token operator">:</span> NumberType
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过定义变量+类型推导就能很轻松完成<code class="language-text">fileds</code>的定义</p><h3 id="实现render方法" class="heading"><a href="#%E5%AE%9E%E7%8E%B0render%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="icon icon-link"></span></a>实现render方法</h3><p><code class="language-text">render</code>方法作用其实就是将上面定义好的变量转成字符串形式的<code class="language-text">fields</code></p><div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 实现方法其实很简单, 就是遍历object输出key</span>
  <span class="token comment">// 遇到nested或者array就递归</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这时候我们可以这样</p><div class="gatsby-highlight" data-language="typescript"><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> fileds <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
axios<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">request</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">typeof</span> a<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  url<span class="token operator">:</span> <span class="token string">'/example'</span><span class="token punctuation">,</span>
  headers<span class="token operator">:</span> <span class="token punctuation">{</span>
    fields
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>到这里其实就达到了最终的目标<strong>定义fileds同时定义返回类型</strong></p><p>但是目前这样维护起来不太容易, 我们需要<strong>继承</strong>以及更多的<strong>类型支持</strong></p><h3 id="继承" class="heading"><a href="#%E7%BB%A7%E6%89%BF" aria-hidden="true"><span class="icon icon-link"></span></a>继承</h3><p>继承的目标就是在已有的<code class="language-text">fileds</code>上继续扩展, <code class="language-text">Object.assign</code>就能满足</p><p>但<code class="language-text">assign</code>本身是不带类型的, 因此需要给他加入类型以便<code class="language-text">ts</code>进行类型推导</p><div class="gatsby-highlight" data-language="typescript"><pre class="language-typescript"><code class="language-typescript"><span class="token comment">// 最简单的继承</span>
<span class="token keyword">function</span> <span class="token function">extend</span><span class="token punctuation">(</span>t0<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> t0<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>剩下要做的只需要对它进行重载以满足类型推导</p><div class="gatsby-highlight" data-language="typescript"><pre class="language-typescript"><code class="language-typescript"><span class="token comment">// 举个例子</span>
<span class="token comment">// 我们只需要使用泛型来重载它的输入和输入类型</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">extend</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T0</span> <span class="token keyword">extends</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token constant">T1</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  t<span class="token operator">:</span> <span class="token constant">T0</span><span class="token punctuation">,</span>
  u<span class="token operator">:</span> <span class="token constant">T1</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token punctuation">(</span><span class="token constant">T0</span> <span class="token operator">&amp;</span> <span class="token constant">T1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token constant">T0</span> <span class="token operator">&amp;</span> <span class="token constant">T1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">extend</span><span class="token punctuation">(</span>t0<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> t0<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> c<span class="token operator">:</span> <span class="token string">''</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> a
<span class="token comment">// A = { a: number, c: string }</span>
</code></pre></div><h3 id="更多类型支持" class="heading"><a href="#%E6%9B%B4%E5%A4%9A%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81" aria-hidden="true"><span class="icon icon-link"></span></a>更多类型支持</h3><p>在<code class="language-text">typescript</code>还有高级类型比如<code class="language-text">pick</code>, <code class="language-text">omit</code>, <code class="language-text">union</code>等</p><p>要实现他们, 原理跟继承一样, 都通泛型以及重载实现</p><div class="gatsby-highlight" data-language="typescript"><pre class="language-typescript"><code class="language-typescript"><span class="token comment">// 再举个例子</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">constant</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arg
<span class="token punctuation">}</span>

<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">constant</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> a
<span class="token comment">// A = 1, 而不是number</span>
</code></pre></div><h3 id="组合使用" class="heading"><a href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8" aria-hidden="true"><span class="icon icon-link"></span></a>组合使用</h3><div class="gatsby-highlight" data-language="typescript"><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> StringType
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  user<span class="token operator">:</span> <span class="token punctuation">{</span>
    username<span class="token operator">:</span> StringType<span class="token punctuation">,</span>
    id<span class="token operator">:</span> NumberType
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token constant">C</span> <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span>
  <span class="token punctuation">{</span>
    c<span class="token operator">:</span> BooleanType
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token constant">A</span><span class="token punctuation">,</span>
  <span class="token constant">B</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> <span class="token class-name">TypeC</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> c
<span class="token comment">// { name: string, user: { username: string, id: number }, c: boolean}</span>

<span class="token keyword">const</span> <span class="token constant">D</span> <span class="token operator">=</span> <span class="token function">pick</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'user'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">type</span> <span class="token class-name">TypeD</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> <span class="token constant">D</span>
<span class="token comment">// { user: { username: string, id: number } }</span>

<span class="token keyword">const</span> <span class="token constant">E</span> <span class="token operator">=</span> <span class="token function">omit</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'user'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">type</span> <span class="token class-name">TypeE</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> <span class="token constant">E</span>
<span class="token comment">// { name: string, c: boolean }</span>
</code></pre></div><p>通过一系列的辅助方法, 就可以很好的达到我们的目的: 定义<code class="language-text">fileds</code>同时定义类型</p><h3 id="配合axios使用" class="heading"><a href="#%E9%85%8D%E5%90%88axios%E4%BD%BF%E7%94%A8" aria-hidden="true"><span class="icon icon-link"></span></a>配合axios使用</h3><h4 id="最粗暴的方式" class="heading"><a href="#%E6%9C%80%E7%B2%97%E6%9A%B4%E7%9A%84%E6%96%B9%E5%BC%8F" aria-hidden="true"><span class="icon icon-link"></span></a>最粗暴的方式</h4><div class="gatsby-highlight" data-language="typescript"><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> StringType
<span class="token punctuation">}</span>
<span class="token keyword">const</span> fileds <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">)</span>
axios<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">request</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">typeof</span> <span class="token constant">A</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  url<span class="token operator">:</span> <span class="token string">'/example'</span><span class="token punctuation">,</span>
  headers<span class="token operator">:</span> <span class="token punctuation">{</span>
    fields
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="更方便的方式" class="heading"><a href="#%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E6%96%B9%E5%BC%8F" aria-hidden="true"><span class="icon icon-link"></span></a>更方便的方式</h4><p>还是借用了泛型+类型推导</p><div class="gatsby-highlight" data-language="typescript"><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">request</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>fieldsDeclare<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> fields <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">(</span>fieldsDeclare<span class="token punctuation">)</span>
  <span class="token comment">// 在这里借用了类型推导</span>
  <span class="token keyword">return</span> Axios<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">request</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    url<span class="token punctuation">,</span>
    headers<span class="token operator">:</span> <span class="token punctuation">{</span>
      fields
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">''</span>
<span class="token punctuation">}</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>r <span class="token operator">=></span> <span class="token punctuation">{</span>
  r<span class="token punctuation">.</span>data <span class="token comment">// typeof A { name: string }</span>
  r<span class="token punctuation">.</span>data<span class="token punctuation">.</span>name <span class="token comment">// string</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="结语" class="heading"><a href="#%E7%BB%93%E8%AF%AD" aria-hidden="true"><span class="icon icon-link"></span></a>结语</h2><p>有了以上基础，其实要实现真正的<code class="language-text">GraphQL</code>也是可以的，只需要实现<code class="language-text">render</code>方法即可。</p><p>基于<code class="language-text">ts</code>的泛型+类型推导其实能实现很多强大的功能，比如<a href="https://github.com/zWingz/vuex-ts-enhance">vuex-ts-enhance</a>，就是借助泛型+类型推导，完成了<code class="language-text">vuex</code>中<code class="language-text">mapXXX</code>方法的类型推导，有兴趣可以试用下。</p></div><div class="comments"><div id="gitalk-container"></div></div></article></div></div></main><footer class="footer"><div class="center">Powered by <a target="_blank" href="https://github.com/acyortjs/acyort">AcyOrt</a> / Theme <a target="_blank" href="https://github.com/acyortjs/theme-donob">donob</a></div></footer><script src="/script/post.js"></script><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script>const gitalkConfig = JSON.parse('{"owner":"zWingz","repo":"my-blog-config","admin":["zWingz"],"clientID":"0438ed96c0cb944693a7","clientSecret":"23e7aa3152f5d03d8f20029540741d6f886c9f5b","number":42}')
  var gitalk = new Gitalk({
    ...gitalkConfig
  })
  gitalk.render('gitalk-container')</script><script defer="defer" src="/script/ribbon.js"></script></body></html>