<!doctype html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="description" content="Just a blog."><link rel="stylesheet" href="/css/style.css"><title>记一下从Vue转向React的感想 - zWing</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"></head><body><canvas id="ribbon"></canvas><div class="main"><div class="header"><a class="logo" href="/">zWing</a><div class="menu"><a href="/archives/">Archives</a><a href="/about/">About</a></div><div class="social"><a target="_blank" href="https://github.com/zWingz/my-blog-config/issues"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"></path></svg></a><a target="_blank" href="/rss.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.18,15.64A2.18,2.18 0 0,1 8.36,17.82C8.36,19 7.38,20 6.18,20C5,20 4,19 4,17.82A2.18,2.18 0 0,1 6.18,15.64M4,4.44A15.56,15.56 0 0,1 19.56,20H16.73A12.73,12.73 0 0,0 4,7.27V4.44M4,10.1A9.9,9.9 0 0,1 13.9,20H11.07A7.07,7.07 0 0,0 4,12.93V10.1Z"></path></svg></a></div></div><div id="post" class="center"><p class="time">July 10, 2018</p><h1 class="title">记一下从Vue转向React的感想</h1><div class="content"><h1><a href="#关于React, 想说几点" id="关于React, 想说几点" class="heading"></a>关于React, 想说几点</h1><p>没有干货, 只有感想. 没有源码分析, 只有需求实现.</p><h2><a href="#React跟Vue对比" id="React跟Vue对比" class="heading"></a>React跟Vue对比</h2><p>之前写过一篇<a href="https://zwing.site/posts/275254986.html">vue后台系统开发实践</a></p><p>那时候主要写<code>vue</code>, 有时间也会关注下<code>React</code>相关内容, 但没有实际开发经验.</p><p>最近终于从<code>vue</code>转向了<code>React</code></p><p>虽说两者都是<code>MVVM</code>框架, 都是数据驱动型, 但是两者区别还真的很明显.</p><p>曾经看过一段话, 大概是这么一个意思</p><p><code>vue</code>就是帮你封装了所有东西, 比如数据监听、指令、模板渲染等等</p><p>写起来就像是一门新的语言一样,你只要按照他的语法, 你就能很轻易的写出一套系统.</p><p>而<code>React</code>只提供了最基础的东西, 比如<code>vnode</code>, dom渲染等, 其余得都要靠自己去组合实现. 写起来就跟写原生<code>JavaScript</code>没什么区别. 可以玩出很多花样.</p><p>我是很赞同这个说法</p><p>在刚开始写<code>React</code>时候, 时不时都会带上<code>vue</code>的思想去写</p><p>耳边偶尔会响起一句话 &#39;怎么React这么麻烦, 我用vue一下子就能完成的东西, 在这里要写半天&#39;</p><p>例子? <code>Form</code>表单的双向绑定就是一个例子.</p><h3><a href="#初探React" id="初探React" class="heading"></a>初探React</h3><p>刚开始写, 由于不太熟练, 就选择了<code>Antd</code>作为UI框架.</p><p>但其实我是不太喜欢使用第三方库的</p><p>在刚开始写<code>vue</code>时候, 也是选择<code>ElementUI</code>, 后面熟练之后也逐步抛弃, 改用自己实现的组件</p><p>除了几个特别麻烦的, 比如 <code>DataPicker</code> . 我还是选择使用第三方.</p><p>我也写过一个<a href="https://zwing.site/posts/295960409.html">固定表格组件</a>, 个人感觉挺良好. 666</p><p>那么对于<code>React</code>, 我也选择了同样的入手方式, 先从第三方库用起, 后续逐步替代.</p><p>当然, <code>Antd</code> 用起来也是很麻烦, 花了几天勉强搭起了一个简单功能的后台.</p><p>当时的想法就是, 这么几个页面, 用<code>vue</code>一天就搞定, 这个<code>react</code>花了我几天.</p><p>可能当时也是太年轻了.</p><p>后来开发第二个系统, 就开始结合上文所说的<code>vue后台实践</code> 所提到的几个要点去重新写系统</p><h2><a href="#React的router选择" id="React的router选择" class="heading"></a>React的router选择</h2><p>react的路由选择目前有两种, 一种是官方的<code>react-router</code>, 另一个是刚出不久的<code>reach-router</code>.</p><p>而<code>react-router</code>也是从<code>v3</code>升级到了<code>v4</code>, 这次升级可以说是颠覆了传统的声明式路由</p><p>改成了路由组件化, 而不是传统的配置形式。</p><p>对于, <code>reach-router</code>可以说是麻雀虽小五脏俱全， 可以满足基本的路由功能,, <code>API</code>和路由组件使用起来也是比较简单的。</p><p>刚搭建项目时候，我从<code>v3</code>和<code>v4</code>中做过选择， 最后决定使用<code>v4</code>, 因为我个人喜欢用新不用旧。</p><p>在开发过程中，可能由于自己对<code>React</code>还不够熟悉， 在使用<code>Router</code>上也遇到不少问题。</p><p>比如最简单的路由跳转</p><p><code>v3</code>只需要直接调用<code>api</code>即可完成跳转</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
</pre></td><td class="code"><pre><span class="hljs-comment">/* react-router v3*/</span>
<span class="hljs-keyword">import</span> { browserHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router'</span>; 
browserHistory.<span class="hljs-keyword">push</span>(<span class="hljs-string">'/some/path'</span>);</pre></td></tr></tbody></table></div><p><code>v4</code>需要引入高阶组件后才能从<code>props</code>中调用api.</p><div class="hljs javascript"><table><tbody><tr><td class="line"><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
</pre></td><td class="code"><pre><span class="hljs-comment">/* react-router v3*/</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">React</span> from <span class="hljs-symbol">'reac</span>t'
<span class="hljs-keyword">import</span> { withRouter } from <span class="hljs-symbol">'react</span>-router'
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-comment">// ...</span>
    push() {
        <span class="hljs-keyword">this</span>.props.history.push('/some/path')
    }
       <span class="hljs-comment">// ...</span>
}
export <span class="hljs-keyword">default</span> withRouter(<span class="hljs-type">Component</span>)</pre></td></tr></tbody></table></div><p>但是<code>v4</code>也有优点, 就是路由配置很灵活, 在需要用到的地方引入<code>Route</code>即可。</p><p>但是中途用着不爽，我就直接换成了<code>reach-router</code>。</p><p>这会<code>reach-router</code>用起来可爽了, 简单直接。</p><p>可是由于还不足够的成熟, 用了一段时间后，我又很无耻的改回了<code>react-router</code></p><p>不过我个人还是很欣赏<code>reach-router</code>, 希望后续能真正的发展起来。</p><h2><a href="#React+mobx结合" id="React+mobx结合" class="heading"></a>React+mobx结合</h2><p>一般看到<code>React</code>, 一般也会伴随着<code>Redux</code>。</p><p>而我从<code>vue</code>和<code>vuex</code>那套过来的，不是很喜欢<code>Redux</code>那套复杂的规则和写法。</p><p>当然，也有很多成熟的解决方案，比如<code>dva</code>, <code>rematch</code>等, 轮子可不少啊。</p><p>但是我个人更偏向于使用<code>mobx</code>，或者跟<code>vuex</code>脱不了干系吧。</p><p>使用多<code>store</code>组合，或许能让组件更加的灵活。而且使用简单，不需要复杂的流程。</p><h2><a href="#React在项目中使用" id="React在项目中使用" class="heading"></a>React在项目中使用</h2><p>主要是根据以往的<a href="https://zwing.site/posts/275254986.html">vue开发实践</a>，将其搬到<code>react</code>中来。</p><ul><li>用户登录态管理</li><li>router的钩子</li><li>列表页的数据加载，数据展示流程控制</li><li>列表页查询参数与url查询参数双向绑定</li><li>部分组件的实现</li></ul><p>...后续再补</p></div><div class="comments"><div id="gitalk-container"></div></div></div></div><div class="footer"><div class="center">zWing / Powered by <a target="_blank" href="https://github.com/acyortjs/acyort">AcyOrt</a> / Theme <a target="_blank" href="https://github.com/acyortjs/theme-donob">donob</a></div></div><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script>const gitalkConfig = JSON.parse('{"owner":"zWingz","repo":"my-blog-config","admin":["zWingz"],"clientID":"0438ed96c0cb944693a7","clientSecret":"23e7aa3152f5d03d8f20029540741d6f886c9f5b","number":17}')
  var gitalk = new Gitalk({
    ...gitalkConfig
  })
  gitalk.render('gitalk-container')</script><script defer="defer" src="/script/ribbon.js"></script></body></html>